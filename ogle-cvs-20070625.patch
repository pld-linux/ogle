diff -urN -x CVS -x .cvsignore ogle-0.9.2/Autogen_problems ogle/Autogen_problems
--- ogle-0.9.2/Autogen_problems	1970-01-01 01:00:00.000000000 +0100
+++ ogle/Autogen_problems	2004-03-07 14:56:24.000000000 +0100
@@ -0,0 +1,16 @@
+If you don't have all your m4 files installed in a common directory
+and your aclocal is not set up to scan all the different m4 directories,
+the autogen.sh script might fail with something like this:
+
++ aclocal 
+aclocal: configure.in: 12: macro `AM_PROG_LIBTOOL' not found in library
+aclocal: configure.in: 551: macro `AM_PATH_XML2' not found in library
+
+To fix this you will have to enter the lines that are in the autogen.sh script
+manually, changing the aclocal line to include the necessary directories.
+
+aclocal -I <libtool m4 dir> -I <xml m4 dir "xml2-config --prefix"/share/aclocal>
+
+example:
+aclocal -I /usr/.../libtool-1.5/share/aclocal -I /usr/.../libxml2-2.6.2/share/aclocal
+
diff -urN -x CVS -x .cvsignore ogle-0.9.2/INCOMPATIBILITIES ogle/INCOMPATIBILITIES
--- ogle-0.9.2/INCOMPATIBILITIES	1970-01-01 01:00:00.000000000 +0100
+++ ogle/INCOMPATIBILITIES	2001-06-19 22:39:43.000000000 +0200
@@ -0,0 +1,23 @@
+SHM_SHARE_MMU (shmat): SOLARIS has it, LINUX does not
+just fixed by doing
+#ifndef SHM_SHARE_MMU
+#define SHM_SHARE_MMU 0
+#endif
+
+sem_init: SOLARIS needs -lrt or -lposix4, LINUX needs -lrt or -lpthread
+sem_init: so use -lrt
+
+clock_gettime: SOLARIS has it, LINUX has not (fallback to gettimeofday?)
+clock_gettime: with glibc 2.2 Linux does indeed have clock_gettime.
+clock_gettiem: <time.h>, gettimeofday <sys/time.h>
+
+getopt: SOLARIS in <stdlib.h>, LINUX in <unistd.h>
+
+getsubopt: SOLARIS in <stdlib.h>, LINUX in <stdlib.h> but #ifdef __USE_XOPEN_EXTENDED
+
+linking: having one shared library depend on another that isn't in the standard
+linking: library search path does not work with with binutils version < 2.11
+linking: i.e the encoded run path in the first library isn't searched
+
+libtool: does not work correctly with shared library dependency 
+libtool: versions < 1.4 fail for different reasons
diff -urN -x CVS -x .cvsignore ogle-0.9.2/ac3/Makefile.am ogle/ac3/Makefile.am
--- ogle-0.9.2/ac3/Makefile.am	2003-10-14 03:05:15.000000000 +0200
+++ ogle/ac3/Makefile.am	2004-07-29 11:37:18.000000000 +0200
@@ -17,7 +17,7 @@
 
 pkglib_PROGRAMS = ogle_ac3_p ogle_audio
 
-AM_CPPFLAGS = @TOP_INCLUDES@ @A52_CPPFLAGS@ @MAD_CPPFLAGS@ @XML_CFLAGS@
+AM_CPPFLAGS = @TOP_INCLUDES@ @A52_CPPFLAGS@ @MAD_CPPFLAGS@ @XML_CPPFLAGS@
 
 AM_CFLAGS = @O_CFLAGS@
 
diff -urN -x CVS -x .cvsignore ogle-0.9.2/ac3/a52_decoder.c ogle/ac3/a52_decoder.c
--- ogle-0.9.2/ac3/a52_decoder.c	1970-01-01 01:00:00.000000000 +0100
+++ ogle/ac3/a52_decoder.c	2003-03-02 16:50:03.000000000 +0100
@@ -0,0 +1,799 @@
+/* Ogle - A video player
+ * Copyright (C) 2000, 2001 Björn Englund, Håkan Hjort
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <inttypes.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/shm.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <string.h>
+
+#ifndef SHM_SHARE_MMU
+#define SHM_SHARE_MMU 0
+#endif
+
+#include <ogle/msgevents.h>
+
+#include "debug_print.h"
+#include "common.h"
+#include "queue.h"
+#include "timemath.h"
+#include "sync.h"
+
+#include <a52dec/a52.h>
+#include <libao/audio_out.h>
+#include <a52dec/mm_accel.h>
+
+#include "parse_config.h"
+
+/* A/52 */
+static ao_instance_t * output = NULL;
+static sample_t * samples;
+static int disable_dynrng = 0;
+static clocktime_t a52_decode_data(uint8_t *start, uint8_t *end);
+
+
+
+static int get_q();
+static int attach_ctrl_shm(int shmid);
+static int attach_stream_buffer(uint8_t stream_id, uint8_t subtype, int shmid);
+
+static void handle_events(MsgEventQ_t *q, MsgEvent_t *ev);
+
+static int ctrl_data_shmid;
+static ctrl_data_t *ctrl_data;
+static ctrl_time_t *ctrl_time;
+
+static int stream_shmid;
+static char *stream_shmaddr;
+
+static int data_buf_shmid;
+static char *data_buf_shmaddr;
+
+static int msgqid = -1;
+static MsgEventQ_t *msgq;
+
+static int flush_to_scrid = -1;
+static int prev_scr_nr = 0;
+
+static int speaker_flags = -1;
+
+char *program_name;
+
+void usage()
+{
+  fprintf(stderr, "Usage: %s  [-m <msgid>]\n", program_name);
+}
+
+static int get_speaker_flags(void)
+{
+  int front, rear, sub;
+  int result = 0;
+  
+  front = get_num_front_speakers();
+  rear = get_num_rear_speakers();
+  sub = get_num_sub_speakers();
+
+  if(front == 2 && rear == 0) {
+    result = A52_STEREO;
+    /* if(dolby) result = A52_DOLBY; */
+  } else if(front == 3 && rear == 0) {
+    result = A52_3F;
+  } else if(front == 2 && rear == 2) {
+    result = A52_2F2R;
+  } else if(front == 3 && rear == 2) {
+    result = A52_3F2R;
+  } else if(front == 2 && rear == 1) {
+    result = A52_2F1R;
+  } else if(front == 3 && rear == 1) {
+    result = A52_3F1R;
+  }
+  if(sub == 1) {
+    result |= A52_LFE;
+  }
+  return result;
+}
+
+
+static void open_output(int flags)
+{
+  int i;
+  int driver_num = 0;
+  ao_driver_t * drivers;
+  int ch_avail;
+
+  /* Ideally, we would just pass `flags' through to liba52, since that
+   * seems to be how it works internally, however until it offers
+   * such an interface, we figure out which "driver" it needs.
+   */
+
+  switch(flags & A52_CHANNEL_MASK) {
+  case A52_CHANNEL:
+  case A52_STEREO:
+  case A52_DOLBY:
+    ch_avail = 2;
+    break;
+  case A52_3F:
+  case A52_2F1R:
+    ch_avail = 3;
+    break;
+  case A52_3F1R:
+  case A52_2F2R:
+    ch_avail = 4;
+    break;
+  case A52_3F2R:
+    ch_avail = 5;
+    break;
+  default:
+    ch_avail = 0;
+  }
+
+  if(flags & A52_LFE) {
+    ch_avail++;
+  }
+
+  drivers = ao_drivers ();
+  for(i = 0; drivers[i].name; i++) {
+    if(!strcmp("oss", drivers[i].name)
+      || !strcmp("solaris", drivers[i].name)) {
+      if(ch_avail == 2) {
+        printf("opening a 2 channel audio driver\n");
+        driver_num = i;
+      }
+    } else if(!strcmp("oss4", drivers[i].name)) {
+      if(ch_avail == 4) {
+        printf("opening a 4 channel audio driver\n");
+        driver_num = i;
+      }
+    } else if(!strcmp("oss6", drivers[i].name)) {
+      if(ch_avail == 6) {
+        printf("opening a 6 channel audio driver\n");
+        driver_num = i;
+      }
+    }
+  }
+
+  if(output) {
+    ao_close(output);
+    free(output);
+  }
+  output = ao_open(drivers[driver_num].open, get_audio_device());
+  if(output == NULL) {
+    FATAL("Can not open audio output\n");
+    exit(1);
+  }
+}
+
+int main(int argc, char *argv[])
+{
+  MsgEvent_t ev;
+  int c;
+  
+  program_name = argv[0];
+  
+  /* Parse command line options */
+  while ((c = getopt(argc, argv, "m:h?")) != EOF) {
+    switch (c) {
+    case 'm':
+      msgqid = atoi(optarg);
+      break;
+    case 'h':
+    case '?':
+      usage();
+      return 1;
+    }
+  }
+
+  if(msgqid == -1) {
+    if(argc - optind != 1){
+      usage();
+      return 1;
+    }
+  }
+  
+  if(parse_config() == -2) {
+    FATAL("Couldn't read config files\n");
+    exit(1);
+  }
+
+  {
+    uint32_t accel;
+    accel = MM_ACCEL_MLIB;
+
+    open_output(get_speaker_flags());
+
+    samples = a52_init(accel);
+    if(samples == NULL) {
+        FATAL("A/52 init failed\n");
+        exit(1);
+    }
+  }
+
+  if(msgqid != -1) {
+    if((msgq = MsgOpen(msgqid)) == NULL) {
+      FATAL("couldn't get message q\n");
+      exit(1);
+    }
+    
+    ev.type = MsgEventQRegister;
+    ev.registercaps.capabilities = DECODE_AC3_AUDIO;
+    if(MsgSendEvent(msgq, CLIENT_RESOURCE_MANAGER, &ev, 0) == -1) {
+      DPRINTF(1, "a52: register capabilities\n");
+    }
+    
+    while(ev.type != MsgEventQDecodeStreamBuf) {
+      if(MsgNextEvent(msgq, &ev) != -1) {
+	handle_events(msgq, &ev);
+      }
+    }
+
+  } else {
+    FATAL("what? need a msgid\n");
+  }
+
+  while(1) {
+    get_q();
+  }
+
+  return 0;
+}
+
+
+static void handle_events(MsgEventQ_t *q, MsgEvent_t *ev)
+{
+  
+  switch(ev->type) {
+  case MsgEventQNotify:
+    DPRINTF(1, "a52: got notify\n");
+    break;
+  case MsgEventQFlushData:
+    DPRINTF(1, "a52: got flush\n");
+    flush_to_scrid = ev->flushdata.to_scrid;
+    break;
+  case MsgEventQDecodeStreamBuf:
+    DPRINTF(1, "a52: got stream %x, %x buffer \n",
+	    ev->decodestreambuf.stream_id,
+	    ev->decodestreambuf.subtype);
+    attach_stream_buffer(ev->decodestreambuf.stream_id,
+			  ev->decodestreambuf.subtype,
+			  ev->decodestreambuf.q_shmid);
+    
+    break;
+  case MsgEventQCtrlData:
+    attach_ctrl_shm(ev->ctrldata.shmid);
+    break;
+  case MsgEventQSpeed:
+    if(ev->speed.speed == 1.0) {
+      set_speed(&ctrl_time[prev_scr_nr].sync_point, ev->speed.speed);
+    } else {
+      if(ctrl_time[prev_scr_nr].sync_point.speed == 1.0) {
+	set_speed(&ctrl_time[prev_scr_nr].sync_point, ev->speed.speed);
+	if((ctrl_time[prev_scr_nr].sync_master == SYNC_AUDIO)) {
+	  ctrl_time[prev_scr_nr].sync_master = SYNC_NONE;
+	}
+      }
+    }
+    break;
+  default:
+    DNOTE("unrecognized event type: %d\n", ev->type);
+    break;
+  }
+}
+
+
+
+
+int attach_ctrl_shm(int shmid)
+{
+  char *shmaddr;
+  
+  if(shmid >= 0) {
+    if((shmaddr = shmat(shmid, NULL, SHM_SHARE_MMU)) == (void *)-1) {
+      perror("a52: attach_ctrl_data(), shmat()");
+      return -1;
+    }
+    
+    ctrl_data_shmid = shmid;
+    ctrl_data = (ctrl_data_t*)shmaddr;
+    ctrl_time = (ctrl_time_t *)(shmaddr+sizeof(ctrl_data_t));
+  }    
+  
+  return 0;
+}
+
+int attach_stream_buffer(uint8_t stream_id, uint8_t subtype, int shmid)
+{
+  char *shmaddr;
+  q_head_t *q_head;
+
+  //DNOTE("a52_decoder: shmid: %d\n", shmid);
+  
+  if(shmid >= 0) {
+    if((shmaddr = shmat(shmid, NULL, SHM_SHARE_MMU)) == (void *)-1) {
+      perror("ac52_decoder: attach_decoder_buffer(), shmat()");
+      return -1;
+    }
+    
+    stream_shmid = shmid;
+    stream_shmaddr = shmaddr;
+  }    
+
+  q_head = (q_head_t *)stream_shmaddr;
+  shmid = q_head->data_buf_shmid;
+  
+  if(shmid >= 0) {
+    if((shmaddr = shmat(shmid, NULL, SHM_SHARE_MMU)) == (void *)-1) {
+      perror("a52_decoder: attach_data_buffer(), shmat()");
+      return -1;
+    }
+    
+    data_buf_shmid = shmid;
+    data_buf_shmaddr = shmaddr;
+  }    
+
+  return 0;
+}
+
+
+
+
+int get_q()
+{
+  q_head_t *q_head;
+  q_elem_t *q_elems;
+  data_buf_head_t *data_head;
+  data_elem_t *data_elems;
+  data_elem_t *data_elem;
+  int elem;
+  uint8_t *data_buffer;
+  uint8_t PTS_DTS_flags;
+  uint64_t PTS;
+  uint64_t DTS;
+  int scr_nr;
+  int off;
+  int len;
+  static clocktime_t time_offset = { 0, 0 };
+  static clocktime_t last_rt = { -1, 0 };
+  static clocktime_t in_outputbuf = { 0, 0 };
+  static clocktime_t prev_scr_time = { 0, 0 };
+  MsgEvent_t ev;
+  
+  q_head = (q_head_t *)stream_shmaddr;
+  q_elems = (q_elem_t *)(stream_shmaddr+sizeof(q_head_t));
+  elem = q_head->read_nr;
+
+  while(MsgCheckEvent(msgq, &ev) != -1) {
+    handle_events(msgq, &ev);
+  }
+  
+  if(!q_elems[elem].in_use) {
+    q_head->reader_requests_notification = 1;
+    
+    while(!q_elems[elem].in_use) {
+      DPRINTF(1, "a52: waiting for notification1\n");
+      if(MsgNextEvent(msgq, &ev) != -1) {
+	handle_events(msgq, &ev);
+      }
+    }
+  }
+
+  data_head = (data_buf_head_t *)data_buf_shmaddr;
+  data_buffer = data_buf_shmaddr + data_head->buffer_start_offset;
+  data_elems = (data_elem_t *)(data_buf_shmaddr+sizeof(data_buf_head_t));
+  
+  data_elem = &data_elems[q_elems[elem].data_elem_index];
+  
+  PTS_DTS_flags = data_elem->PTS_DTS_flags;
+  PTS = data_elem->PTS;
+  DTS = data_elem->DTS;
+  scr_nr = data_elem->scr_nr;
+  /*
+    p[0] is the number of frames of audio which have a sync code in this pack
+    p[1]<<8 | p[2] is the starting index of the frame which 
+      the PTS value belong to
+  */
+  off = data_elem->off + 3;
+  len = data_elem->len - 3;
+
+  if(flush_to_scrid != -1) {
+    if(ctrl_time[scr_nr].scr_id < flush_to_scrid) {
+
+      q_head->read_nr = (q_head->read_nr+1)%q_head->nr_of_qelems;
+      
+      // release elem
+      data_elem->in_use = 0;
+      q_elems[elem].in_use = 0;
+      
+      if(q_head->writer_requests_notification) {
+	q_head->writer_requests_notification = 0;
+	ev.type = MsgEventQNotify;
+	if(MsgSendEvent(msgq, q_head->writer, &ev, 0) == -1) {
+	  WARNING("couldn't send notification\n");
+	}
+      }
+      return 0;
+    } else {
+      flush_to_scrid = -1;
+    }
+  }
+  if(ctrl_data->speed == 1.0) {
+    clocktime_t real_time, scr_time;
+    
+    clocktime_get(&real_time);
+    
+    if(PTS_DTS_flags & 0x2) {
+      PTS_TO_CLOCKTIME(scr_time, PTS);
+    }
+    
+    if(ctrl_time[scr_nr].sync_master <= SYNC_AUDIO) {
+      clocktime_t tmptime;
+      ctrl_time[scr_nr].sync_master = SYNC_AUDIO;
+      
+      if(ctrl_time[scr_nr].offset_valid == OFFSET_NOT_VALID) {
+	if(PTS_DTS_flags & 0x2) {
+	  
+	  // time_offset is our guess to how much is in the output q
+
+	  if(TIME_S(last_rt) != -1) {
+	    tmptime = last_rt;
+	  } else {
+	    tmptime = real_time;
+	  }
+	  
+	  timeadd(&tmptime, &tmptime, &in_outputbuf);
+	  {
+	    clocktime_t t1, t2;
+	    timesub(&t1, &scr_time, &prev_scr_time);
+	    timesub(&t2, &t1, &in_outputbuf);
+	    /*
+	    if((TIME_SS(t2) < -CT_FRACTION/10000) ||
+	       (TIME_SS(t2) > CT_FRACTION/10000)) {
+	      fprintf(stderr, "*** diff: %ld.%09ld\n",
+		      TIME_S(t2), TIME_SS(t2));
+	    }
+	    */
+	  }
+	  
+	  fprintf(stderr, "*rt: %ld.%09ld, last_rt: %ld.%09ld\n "
+		  "bt: %ld.%09ld,  tmptime: %ld.%09ld\n scr: %ld.%09ld\n",
+		  (long)TIME_S(real_time), (long)TIME_SS(real_time),
+		  (long)TIME_S(last_rt), (long)TIME_SS(last_rt),
+		  (long)TIME_S(in_outputbuf), (long)TIME_SS(in_outputbuf),
+		  (long)TIME_S(tmptime), (long)TIME_SS(tmptime),
+		  (long)TIME_S(scr_time), (long)TIME_SS(scr_time));
+	    
+      	  set_sync_point(&ctrl_time[scr_nr],
+			 &tmptime,
+			 &scr_time,
+			 ctrl_data->speed);
+	  prev_scr_time = scr_time;
+
+	}
+	
+      } else {
+	/* offset valid */
+	if(PTS_DTS_flags & 0x2) {
+	  clocktime_t t1, t2;
+	  /* clocktime_t calc_scr_time; */
+	  
+
+	  if(TIME_S(last_rt) != -1) {
+	    tmptime = last_rt;
+	  } else {
+	    tmptime = real_time;
+	  }
+	  
+	  timeadd(&tmptime, &tmptime, &in_outputbuf);
+	  
+	  timesub(&t1, &scr_time, &prev_scr_time);
+	  timesub(&t2, &t1, &in_outputbuf);
+	    
+	  if((TIME_SS(t2) < -CT_FRACTION/10000) ||
+	     (TIME_SS(t2) > CT_FRACTION/10000)) {
+	    /* diff */
+	    /*
+	    fprintf(stderr, "** diff: %ld.%09ld\n",
+		    TIME_S(t2), TIME_SS(t2));
+	    */
+	    /*
+	    timeadd(&calc_scr_time, &scr_time, &in_outputbuf);
+	    
+	    set_sync_point(&ctrl_time[scr_nr],
+			   &tmptime,
+			   &calc_scr_time,
+			   ctrl_data->speed);
+	    prev_scr_time = scr_time;
+	    
+	    timeadd(&last_rt, &last_rt, &in_outputbuf);
+	    */
+	  }
+	  /*
+	    else {
+	    // no diff
+	  */
+	    
+	  /*  
+	      fprintf(stderr, "rt: %ld.%09ld, last_rt: %ld.%09ld\n bt: %ld.%09ld,  tmptime: %ld.%09ld\n scr: %ld.%09ld\n",
+	      TIME_S(real_time), TIME_SS(real_time),
+	      TIME_S(last_rt), TIME_SS(last_rt),
+	      TIME_S(in_outputbuf), TIME_SS(in_outputbuf),
+	      TIME_S(tmptime), TIME_SS(tmptime),
+	      TIME_S(scr_time), TIME_SS(scr_time));
+	      
+	    set_sync_point(&ctrl_time[scr_nr],
+			   &tmptime,
+			   &scr_time,
+			   ctrl_data->speed);
+	  */
+	    prev_scr_time = scr_time;
+	  
+	    /*
+	  }
+	    */
+	} else {
+	  /* not pts set */
+	  clocktime_t calc_scr_time;
+	  
+	  timeadd(&calc_scr_time, &scr_time, &in_outputbuf);
+	  if(TIME_S(last_rt) != -1) {
+	    tmptime = last_rt;
+	  } else {
+	    tmptime = real_time;
+	  }
+	  
+	  timeadd(&tmptime, &tmptime, &in_outputbuf);
+	  {
+	    clocktime_t t1, t2;
+	    timesub(&t1, &calc_scr_time, &prev_scr_time);
+	    timesub(&t2, &t1, &in_outputbuf);
+	    
+	    if((TIME_SS(t2) < -1000) || (TIME_SS(t2) > 1000)) {
+	      fprintf(stderr, "**** diff: %ld.%09ld\n",
+		      (long)TIME_S(t2), (long)TIME_SS(t2));
+	    }
+	    
+	  }
+	  
+	  fprintf(stderr, "rt: %ld.%09ld, last_rt: %ld.%09ld\n "
+		  "bt: %ld.%09ld,  tmptime: %ld.%09ld\n calc_scr: %ld.%09ld\n",
+		  (long)TIME_S(real_time), (long)TIME_SS(real_time),
+		  (long)TIME_S(last_rt), (long)TIME_SS(last_rt),
+		  (long)TIME_S(in_outputbuf), (long)TIME_SS(in_outputbuf),
+		  (long)TIME_S(tmptime), (long)TIME_SS(tmptime),
+		  (long)TIME_S(calc_scr_time), (long)TIME_SS(calc_scr_time));
+	  
+	  set_sync_point(&ctrl_time[scr_nr],
+			 &tmptime,
+			 &calc_scr_time,
+			 ctrl_data->speed);
+	  prev_scr_time = scr_time;
+
+	  timeadd(&last_rt, &last_rt, &in_outputbuf);
+	  
+	}
+      }
+      if(PTS_DTS_flags & 0x2) {
+	calc_realtime_left_to_scrtime(&time_offset, &real_time,
+				      &scr_time,
+				      &(ctrl_time[scr_nr].sync_point));
+      }
+      
+      /*
+       * primitive resync in case output buffer is emptied 
+       */
+      
+      if(TIME_SS(time_offset) < 0 || TIME_S(time_offset) < 0) {
+	TIME_S(time_offset) = 0;
+	TIME_SS(time_offset) = 0;
+	NOTE("resetting offset\n");
+	set_sync_point(&ctrl_time[scr_nr],
+		       &real_time,
+		       &scr_time,
+		       ctrl_data->speed);
+	//DNOTE("offset reset\n");
+      }
+    }
+
+    if(PTS_DTS_flags & 0x2) {
+      calc_realtime_from_scrtime(&last_rt,
+				 &scr_time,
+				 &(ctrl_time[scr_nr].sync_point));
+
+      calc_realtime_left_to_scrtime(&time_offset, &real_time,
+				    &scr_time,
+				    &(ctrl_time[scr_nr].sync_point));
+
+      if(TIME_S(time_offset) > 10) {
+	TIME_S(time_offset) = 0;
+	TIME_SS(time_offset) = 0;
+	//DNOTE("more than 10 secs in audio output buffer, somethings wrong?\n");
+      }
+    }
+
+    if(ctrl_data->speed == 1.0) {
+      
+      /** TODO this is just so we don't buffer alot in the pipe **/
+      
+      if(PTS_DTS_flags & 0x2) {
+#ifndef HAVE_CLOCK_GETTIME
+	struct timespec bepa;
+	clocktime_t apa = {0, 100000};
+	timesub(&apa, &time_offset, &apa);
+	bepa.tv_sec = apa.tv_sec;
+	bepa.tv_nsec = apa.tv_usec*1000;
+	
+	if(bepa.tv_nsec > 10000 || bepa.tv_sec > 0) {
+	  nanosleep(&bepa, NULL);
+	}
+#else
+	
+	clocktime_t apa = {0, 100000000};
+	timesub(&apa, &time_offset, &apa);
+	
+	if(TIME_SS(apa) > 10000000 || TIME_S(apa) > 0) {
+	  nanosleep(&apa, NULL);
+	}
+	
+#endif 
+      }
+    }
+  }
+  prev_scr_nr = scr_nr;
+  q_head->read_nr = (q_head->read_nr+1)%q_head->nr_of_qelems;
+  
+  if(ctrl_data->speed == 1.0) {
+    in_outputbuf = a52_decode_data(data_buffer+off, data_buffer+off+len);  
+  } else {
+    TIME_S(in_outputbuf) = 0;
+    TIME_SS(in_outputbuf) = 0;
+  }
+
+  // release elem
+  data_elem->in_use = 0;
+  q_elems[elem].in_use = 0;
+  
+  if(q_head->writer_requests_notification) {
+    q_head->writer_requests_notification = 0;
+    ev.type = MsgEventQNotify;
+    if(MsgSendEvent(msgq, q_head->writer, &ev, 0) == -1) {
+      WARNING("couldn't send notification\n");
+    }
+  }
+
+  return 0;
+}
+
+static clocktime_t a52_decode_data(uint8_t *start, uint8_t *end) {
+  static a52_state_t state;
+  
+  static uint8_t buf[3840];
+  static uint8_t *bufptr = buf;
+  static uint8_t *bufpos = buf + 7;
+  clocktime_t buf_time = {0, 0};
+  int blocks = 0;
+  /*
+   * sample_rate and flags are static because this routine could
+   * exit between the a52_syncinfo() and the ao_setup(), and we want
+   * to have the same values when we get back !
+   */
+  
+  static int sample_rate;
+  static int flags;
+  int print_skip = 0, print_error = 0;
+  
+  while(start < end) {
+    *bufptr++ = *start++;
+    if(bufptr == bufpos) {
+      if(bufpos == buf + 7) {
+	int coded_flags, bit_rate, length;
+	
+	if(print_error) {
+	  DNOTE("A/52 error while decoding, restarting\n");
+	  print_error = 0;
+	}
+
+	length = a52_syncinfo(buf, &coded_flags, &sample_rate, &bit_rate);
+	if(!length) {
+	  print_skip = 1;
+	  for(bufptr = buf; bufptr < buf + 6; bufptr++)
+	    bufptr[0] = bufptr[1];
+	  continue;
+	}
+	bufpos = buf + length;
+      } else {
+	sample_t level, bias;
+	int i;	
+	if(print_skip) {
+	  print_skip = 0;
+	  DNOTE("skipped data to find a valid frame\n");
+	}
+ 	
+	/* Verify or set the sample rate and retrive flags, level and bias */
+	if(ao_setup(output, sample_rate, &flags, &level, &bias)) {
+	  DNOTE("ao_setup() error\n");
+          open_output(get_speaker_flags());
+	  if(ao_setup(output, sample_rate, &flags, &level, &bias)) {
+	    goto error;
+	    //exit(1);
+	  }
+	  speaker_flags = flags;
+	  DNOTE("ao_setup() averted\n");
+	}
+	
+	if(speaker_flags == -1)
+	  speaker_flags = flags;
+	
+	flags = speaker_flags;
+	flags |= A52_ADJUST_LEVEL;
+	memset(&state, 0, sizeof(a52_state_t));
+	/* flags (speaker) [in/out] level [in/out] bias [in] */
+	if(a52_frame(&state, buf, &flags, &level, bias)) {
+	  DNOTE("a52_frame() error\n");
+	  goto error;
+	}
+
+	if(disable_dynrng)
+	  a52_dynrng(&state, NULL, NULL);
+	for(i = 0; i < 6; i++) {
+	  if(a52_block(&state, samples)) {
+	    DNOTE("a52_block() error\n");
+	    goto error;
+	  }
+	  /* flags (output from decoder) verified by ao_play */
+	  if(ao_play(output, flags, samples)) {
+	    int flags2;
+	    sample_t level2, bias2; // Dummy parameters
+	    DNOTE("ao_play() error\n");
+	    /* re-open... */
+	    open_output(get_speaker_flags());
+	    /* re-setup (set sample rate) */
+	    if(ao_setup(output, sample_rate, &flags2, &level2, &bias2))
+	      goto error;
+	    speaker_flags = flags;
+	    /* set the output mode to what ever flags is (hopefully) */
+	    if(ao_play(output, flags, samples))
+	      goto error;
+	    DNOTE("ao_play() averted\n");
+	  }
+	  blocks++;
+	}
+	bufptr = buf;
+	bufpos = buf + 7;
+	//print_fps(0);
+	continue;
+      error:
+	print_error = 1;
+	bufptr = buf;
+	bufpos = buf + 7;
+      }
+    }
+  }
+
+  if(sample_rate != 0) {
+    TIME_S(buf_time) = (int32_t)(((int64_t)(256*blocks)*(int64_t)CT_FRACTION/sample_rate) / CT_FRACTION);
+    TIME_SS(buf_time) = (int32_t)(((int64_t)(256*blocks)*(int64_t)CT_FRACTION/sample_rate) % CT_FRACTION);
+  } else {
+    TIME_S(buf_time) = 0;
+    TIME_SS(buf_time) = 0;
+  }
+
+  return buf_time;
+}
diff -urN -x CVS -x .cvsignore ogle-0.9.2/ac3/ac3dec_wrap.c ogle/ac3/ac3dec_wrap.c
--- ogle-0.9.2/ac3/ac3dec_wrap.c	2003-03-02 16:50:03.000000000 +0100
+++ ogle/ac3/ac3dec_wrap.c	2004-07-29 12:11:30.000000000 +0200
@@ -21,14 +21,10 @@
 #include <stdlib.h>
 #include <sys/types.h>
 #include <sys/stat.h>
-#include <sys/shm.h>
 #include <fcntl.h>
 #include <unistd.h>
 #include <string.h>
 
-#ifndef SHM_SHARE_MMU
-#define SHM_SHARE_MMU 0
-#endif
 
 #include <ogle/msgevents.h>
 
@@ -37,7 +33,7 @@
 #include "queue.h"
 #include "timemath.h"
 #include "sync.h"
-
+#include "shm.h"
 
 
 
@@ -48,7 +44,8 @@
 static void handle_events(MsgEventQ_t *q, MsgEvent_t *ev);
 
 
-static char *program_name;
+char *program_name;
+int dlevel;
 
 static FILE *outfile;
 
@@ -62,13 +59,13 @@
 static int data_buf_shmid;
 static char *data_buf_shmaddr;
 
-static int msgqid = -1;
 static MsgEventQ_t *msgq;
 
 static int flush_to_scrid = -1;
 
 static int prev_scr_nr = 0;
 
+static int standalone = 1;
 
 void usage()
 {
@@ -81,13 +78,29 @@
 {
   MsgEvent_t ev;
   int c; 
+#ifdef SOCKIPC
+  char *msgqid;
+  MsgEventQType_t msgq_type;
+#else
+  int msgqid = -1;
+#endif
+
   program_name = argv[0];
-  
+  GET_DLEVEL();
+
   /* Parse command line options */
   while ((c = getopt(argc, argv, "m:h?")) != EOF) {
     switch (c) {
     case 'm':
+#ifdef SOCKIPC
+      if(get_msgqtype(optarg, &msgq_type, &msgqid) == -1) {
+	fprintf(stderr, "unknown msgq type\n");
+	return 1;
+      }
+#else
       msgqid = atoi(optarg);
+#endif
+      standalone = 0;
       break;
     case 'h':
     case '?':
@@ -96,7 +109,7 @@
     }
   }
 
-  if(msgqid == -1) {
+  if(standalone) {
     if(argc - optind != 1){
       usage();
       return 1;
@@ -107,8 +120,12 @@
   outfile = fopen("/tmp/ac3", "w");
   
 
-  if(msgqid != -1) {
+  if(!standalone) {
+#ifdef SOCKIPC
+    if((msgq = MsgOpen(msgq_type, msgqid, strlen(msgqid))) == NULL) {
+#else
     if((msgq = MsgOpen(msgqid)) == NULL) {
+#endif
       fprintf(stderr, "ac3wrap: couldn't get message q\n");
       exit(-1);
     }
@@ -186,8 +203,8 @@
 {
   char *shmaddr;
   
-  if(shmid >= 0) {
-    if((shmaddr = shmat(shmid, NULL, SHM_SHARE_MMU)) == (void *)-1) {
+  if(shmid != -1) {
+    if((shmaddr = ogle_shmat(shmid)) == (void *)-1) {
       perror("ac3wrap: attach_ctrl_data(), shmat()");
       return -1;
     }
@@ -207,8 +224,8 @@
 
   fprintf(stderr, "ac3: shmid: %d\n", shmid);
   
-  if(shmid >= 0) {
-    if((shmaddr = shmat(shmid, NULL, SHM_SHARE_MMU)) == (void *)-1) {
+  if(shmid != -1) {
+    if((shmaddr = ogle_shmat(shmid)) == (void *)-1) {
       perror("ac3: attach_decoder_buffer(), shmat()");
       return -1;
     }
@@ -220,8 +237,8 @@
   q_head = (q_head_t *)stream_shmaddr;
   shmid = q_head->data_buf_shmid;
   
-  if(shmid >= 0) {
-    if((shmaddr = shmat(shmid, NULL, SHM_SHARE_MMU)) == (void *)-1) {
+  if(shmid != -1) {
+    if((shmaddr = ogle_shmat(shmid)) == (void *)-1) {
       perror("ac3: attach_data_buffer(), shmat()");
       return -1;
     }
diff -urN -x CVS -x .cvsignore ogle-0.9.2/ac3/audio_config.c ogle/ac3/audio_config.c
--- ogle-0.9.2/ac3/audio_config.c	2003-04-13 17:42:56.000000000 +0200
+++ ogle/ac3/audio_config.c	2005-07-30 17:02:18.000000000 +0200
@@ -18,6 +18,7 @@
 
 #include <stdio.h>
 #include <string.h>
+#include <errno.h>
 
 #include "audio_types.h"
 #include "parse_config.h"
@@ -234,28 +235,31 @@
 	}
 	if(drivers[n].name == NULL) {
 	  NOTE("Audio driver '%s' not found\n", driver_str);
+	  driver_n = 0;
 	}
       }
-
-      NOTE("Using audio driver '%s'\n", drivers[driver_n].name);
-	     
-      if(drivers[driver_n].open != NULL) {
-	char *dev_string;
-	if(!strcmp("alsa", drivers[driver_n].name)) {
-	  dev_string = get_audio_alsa_name();
+      
+      do {
+	NOTE("Using audio driver '%s'\n", drivers[driver_n].name);
+	
+	if(drivers[driver_n].open != NULL) {
+	  char *dev_string;
+	  if(!strcmp("alsa", drivers[driver_n].name)) {
+	    dev_string = get_audio_alsa_name();
+	  } else {
+	    dev_string = get_audio_device();
+	  }
+	  aconf->adev_handle = ogle_ao_open(drivers[driver_n].open, dev_string);
+	  if(!aconf->adev_handle) {
+	    ERROR("Failed opening the %s audio driver at %s: %s\n",
+		  drivers[driver_n].name, dev_string, strerror(errno));
+	    driver_n++;
+	  }
 	} else {
-	  dev_string = get_audio_device();
-	}
-	aconf->adev_handle = ogle_ao_open(drivers[driver_n].open, dev_string);
-	if(!aconf->adev_handle) {
-	  FATAL("failed opening the %s audio driver at %s\n",
-		drivers[driver_n].name, dev_string);
+	  FATAL("%s", "ogle_ao_open not taken, no audio ouput driver!\n");
 	  exit(1);
 	}
-      } else {
-	FATAL("%s", "ogle_ao_open not taken, no audio ouput driver!\n");
-	exit(1);
-      }
+      } while(!aconf->adev_handle);
     }
     // DNOTE("%s", "ogle_ao_open passed\n");
   }
@@ -263,7 +267,7 @@
     aconf->ainfo = malloc(sizeof(ogle_ao_audio_info_t));
     aconf->ainfo->chlist = NULL;
   }
-
+  
   if(aconf->dst_format.sample_format == SampleFormat_IEC61937) {
     aconf->ainfo->sample_rate = sample_rate;
     aconf->ainfo->sample_resolution = sample_resolution;
diff -urN -x CVS -x .cvsignore ogle-0.9.2/ac3/audio_out.c ogle/ac3/audio_out.c
--- ogle-0.9.2/ac3/audio_out.c	2003-06-19 17:47:26.000000000 +0200
+++ ogle/ac3/audio_out.c	2004-08-21 10:00:31.000000000 +0200
@@ -24,12 +24,9 @@
 #include <string.h>
 #include <sys/types.h>
 #include <sys/stat.h>
-#include <sys/shm.h>
 #include <fcntl.h>
 
-#ifndef SHM_SHARE_MMU
-#define SHM_SHARE_MMU 0
-#endif
+
 
 #include <ogle/msgevents.h>
 
@@ -39,6 +36,7 @@
 #include "timemath.h"
 #include "sync.h"
 #include "mpeg.h"
+#include "shm.h"
 
 #include "parse_config.h"
 #include "decode.h"
@@ -64,7 +62,8 @@
 static int data_buf_shmid;
 static char *data_buf_shmaddr;
 
-static int msgqid = -1;
+static int standalone = 1;
+
 static MsgEventQ_t *msgq;
 
 static int flush_to_scrid = -1;
@@ -84,6 +83,12 @@
 {
   MsgEvent_t ev;
   int c;
+#ifdef SOCKIPC
+  MsgEventQType_t msgq_type;
+  char *msgqid;
+#else
+  int msgqid = -1;
+#endif
   
   program_name = argv[0];
   GET_DLEVEL();
@@ -92,7 +97,15 @@
   while ((c = getopt(argc, argv, "m:h?")) != EOF) {
     switch (c) {
     case 'm':
+#ifdef SOCKIPC
+      if(get_msgqtype(optarg, &msgq_type, &msgqid) == -1) {
+	fprintf(stderr, "unknown msgq type: %s\n", optarg);
+	return 1;
+      }
+#else
       msgqid = atoi(optarg);
+#endif
+      standalone = 0;
       break;
     case 'h':
     case '?':
@@ -101,7 +114,7 @@
     }
   }
 
-  if(msgqid == -1) {
+  if(standalone) {
     if(argc - optind != 1){
       usage();
       return 1;
@@ -114,8 +127,12 @@
   }
 
 
-  if(msgqid != -1) {
+  if(!standalone) {
+#ifdef SOCKIPC
+    if((msgq = MsgOpen(msgq_type, msgqid, strlen(msgqid))) == NULL) {
+#else
     if((msgq = MsgOpen(msgqid)) == NULL) {
+#endif
       FATAL("%s", "couldn't get message q\n");
       exit(1);
     }
@@ -196,18 +213,18 @@
 {
   char *shmaddr;
   
-  if(shmid >= 0) {
-    if((shmaddr = shmat(shmid, NULL, SHM_SHARE_MMU)) == (void *)-1) {
-      perror("a52: attach_ctrl_data(), shmat()");
+  if(shmid != -1) {  
+    if((shmaddr = ogle_shmat(shmid)) == (void *)-1) {
       return -1;
     }
-    
+
     ctrl_data_shmid = shmid;
     ctrl_data = (ctrl_data_t*)shmaddr;
     ctrl_time = (ctrl_time_t *)(shmaddr+sizeof(ctrl_data_t));
   }    
   
   return 0;
+
 }
 
 int attach_stream_buffer(uint8_t stream_id, uint8_t subtype, int shmid)
@@ -217,22 +234,20 @@
 
   //DNOTE("a52_decoder: shmid: %d\n", shmid);
   
-  if(shmid >= 0) {
-    if((shmaddr = shmat(shmid, NULL, SHM_SHARE_MMU)) == (void *)-1) {
-      perror("ac52_decoder: attach_decoder_buffer(), shmat()");
+  if(shmid != -1) {
+    if((shmaddr = ogle_shmat(shmid)) == (void *)-1) {
       return -1;
     }
     
     stream_shmid = shmid;
     stream_shmaddr = shmaddr;
   }    
-
+  
   q_head = (q_head_t *)stream_shmaddr;
   shmid = q_head->data_buf_shmid;
   
-  if(shmid >= 0) {
-    if((shmaddr = shmat(shmid, NULL, SHM_SHARE_MMU)) == (void *)-1) {
-      perror("a52_decoder: attach_data_buffer(), shmat()");
+  if(shmid != -1) {
+    if((shmaddr = ogle_shmat(shmid)) == (void *)-1) {
       return -1;
     }
     
@@ -241,6 +256,7 @@
   }    
 
   return 0;
+
 }
 
 
@@ -270,7 +286,8 @@
   uint8_t stream_id;
   uint8_t subtype;
   AudioType_t new_audio_type;
-
+  volatile int *in_use;
+  volatile int *writer_requests_notification;
 
   q_head = (q_head_t *)stream_shmaddr;
   q_elems = (q_elem_t *)(stream_shmaddr+sizeof(q_head_t));
@@ -280,10 +297,11 @@
     handle_events(msgq, &ev);
   }
   
-  if(!q_elems[elem].in_use) {
+  in_use = &(q_elems[elem].in_use);
+  if(!*in_use) {
     q_head->reader_requests_notification = 1;
     
-    while(!q_elems[elem].in_use) {
+    while(!*in_use) {
       DPRINTF(1, "a52: waiting for notification1\n");
       if(MsgNextEvent(msgq, &ev) != -1) {
 	handle_events(msgq, &ev);
@@ -508,6 +526,7 @@
 
 
 	  
+  writer_requests_notification = &(q_head->writer_requests_notification);
   
   if(flush_to_scrid != -1) {
     if(ctrl_time[scr_nr].scr_id < flush_to_scrid) {
@@ -515,11 +534,13 @@
       q_head->read_nr = (q_head->read_nr+1)%q_head->nr_of_qelems;
       
       // release elem
-      data_elem->in_use = 0;
-      q_elems[elem].in_use = 0;
+      in_use = &(data_elem->in_use);
+      *in_use = 0;
+      in_use = &(q_elems[elem].in_use);
+      *in_use = 0;
       
-      if(q_head->writer_requests_notification) {
-	q_head->writer_requests_notification = 0;
+      if(*writer_requests_notification) {
+	*writer_requests_notification = 0;
 	ev.type = MsgEventQNotify;
 	if(MsgSendEvent(msgq, q_head->writer, &ev, 0) == -1) {
 	  WARNING("%s", "couldn't send notification\n");
@@ -573,11 +594,13 @@
   }
   
   // release elem
-  data_elem->in_use = 0;
-  q_elems[elem].in_use = 0;
+  in_use = &(data_elem->in_use);
+  *in_use = 0;
+  in_use = &(q_elems[elem].in_use);
+  *in_use = 0;
   
-  if(q_head->writer_requests_notification) {
-    q_head->writer_requests_notification = 0;
+  if(*writer_requests_notification) {
+    *writer_requests_notification = 0;
     ev.type = MsgEventQNotify;
     if(MsgSendEvent(msgq, q_head->writer, &ev, 0) == -1) {
       WARNING("%s", "couldn't send notification\n");
diff -urN -x CVS -x .cvsignore ogle-0.9.2/ac3/conversion.c ogle/ac3/conversion.c
--- ogle-0.9.2/ac3/conversion.c	2003-05-23 22:55:21.000000000 +0200
+++ ogle/ac3/conversion.c	2004-08-21 10:00:31.000000000 +0200
@@ -210,19 +210,31 @@
 
 static int convert_mad_fixed_to_s16(mad_fixed_t *m, int16_t *s16,
 				    int nr_samples,
-				    int nr_channels, int *channels)
+				    audio_format_t *src_format,
+				    audio_format_t *dst_format)
 {
   int i;
-  
+  int n;
+  int dst_ch = dst_format->nr_channels;
+
   // assert(nr_channels == 2);    
+  if(src_format->nr_channels > 2) {
+    FATAL("REPORT BUG: convert from %d mpeg channels not implemented\n",
+	  src_format->nr_channels);
+    exit(1);
+  }
   
   for (i = 0; i < nr_samples; i++) {
-    s16[2*i] = convert_mad(m[i]);
-    s16[2*i+1] = convert_mad(m[i+1152]);
+    for(n = 0; n < dst_ch; n++) {
+      if(ch_transform[n] != -1) {
+	s16[dst_ch*i+n] = convert_mad(m[i+ch_transform[n]*1152]);
+      } else {
+	s16[dst_ch*i+n] = 0;
+      }
+    }
   }
-
   
-  return 0;
+  return nr_samples*dst_format->sample_frame_size;  
 }
 
 static int convert_s16be_to_s16ne(int16_t *s16be, int16_t *s16ne,
@@ -384,11 +396,11 @@
   int src_ch = src_format->nr_channels;
   int unaligned = ((uint32_t)lpcm) % 2;
 
-  if(src_format->nr_channels != 2) {
+  if(src_format->nr_channels > 2) {
     FATAL("REPORT BUG: convert from %d lpcm channels not implemented\n",
 	  src_format->nr_channels);
     exit(1);
-  } else if (dst_format->nr_channels != 2) {
+  } else if (dst_format->nr_channels > 2) {
     FATAL("REPORT BUG: convert to %d lpcm channels not implemented\n",
 	  dst_format->nr_channels);
     exit(1);
@@ -522,10 +534,11 @@
     h->output_buf_ptr += 2*2*nr_samples;
     break;
   case 2:
-    convert_mad_fixed_to_s16((mad_fixed_t *)samples,
-			     (int16_t *)h->output_buf_ptr, 
-			     nr_samples, 2, NULL);
-    h->output_buf_ptr += 2*2*nr_samples; // 2ch 2byte
+    h->output_buf_ptr += convert_mad_fixed_to_s16((mad_fixed_t *)samples,
+						  (int16_t *)h->output_buf_ptr,
+						  nr_samples,
+						  src_format, dst_format);
+    //h->output_buf_ptr += 2*2*nr_samples; // 2ch 2byte
     break;
   case 3:
     convert_ac3frame_to_iec61937frame(samples,
diff -urN -x CVS -x .cvsignore ogle-0.9.2/ac3/decode_a52.c ogle/ac3/decode_a52.c
--- ogle-0.9.2/ac3/decode_a52.c	2003-04-13 17:42:56.000000000 +0200
+++ ogle/ac3/decode_a52.c	2003-12-21 01:25:14.000000000 +0100
@@ -491,7 +491,7 @@
     return NULL;
   }
   
-  memset(&handle->handle, 0, sizeof(struct adec_handle_s));
+  memset(&handle->handle, 0, sizeof(adec_a52_handle_t));
   // not set: drain  
   handle->handle.decode = (audio_decode_t) decode_a52;  // function pointers
   handle->handle.flush  = (audio_flush_t)  flush_a52;
diff -urN -x CVS -x .cvsignore ogle-0.9.2/ac3/decode_dts.c ogle/ac3/decode_dts.c
--- ogle-0.9.2/ac3/decode_dts.c	2003-05-23 21:28:56.000000000 +0200
+++ ogle/ac3/decode_dts.c	2004-08-21 10:22:48.000000000 +0200
@@ -163,7 +163,7 @@
 	tmpstr = (amode <= 48) ? "User defined" : "Invalid";
 	break;
       }
-      fprintf(stderr, "%s\n", tmpstr);
+      DNOTEC("%s\n", tmpstr);
       
       DNOTE("%s", "DTS: sample rate: ");
       switch(sfreq) {
@@ -216,7 +216,7 @@
 	tmpstr = "Invalid";
 	break;
       }
-      fprintf(stderr, "%s kHz\n", tmpstr);
+      DNOTEC("%s kHz\n", tmpstr);
 
       DNOTE("%s", "DTS: bit rate: ");
       switch(rate) {
@@ -318,9 +318,9 @@
 	break; 
       }
       if(rate < 30) {
-	fprintf(stderr, "%s kbps\n", tmpstr);
+	DNOTEC("%s kbps\n", tmpstr);
       } else {
-	fprintf(stderr, "%s\n", tmpstr);
+	DNOTEC("%s\n", tmpstr);
       }
       
       {
@@ -442,7 +442,7 @@
     return NULL;
   }
   
-  memset(&handle->handle, 0, sizeof(struct adec_handle_s));
+  memset(&handle->handle, 0, sizeof(adec_dts_handle_t));
   // not set: drain  
   handle->handle.decode = (audio_decode_t) decode_dts;  // function pointers
   handle->handle.flush  = (audio_flush_t)  flush_dts;
diff -urN -x CVS -x .cvsignore ogle-0.9.2/ac3/decode_lpcm.c ogle/ac3/decode_lpcm.c
--- ogle-0.9.2/ac3/decode_lpcm.c	2003-09-22 09:08:14.000000000 +0200
+++ ogle/ac3/decode_lpcm.c	2004-08-10 21:31:30.000000000 +0200
@@ -60,6 +60,9 @@
   
   
   switch(nr_ch) {
+  case 1:
+    chtypemask = ChannelType_Left;
+    break;
   case 2:
     chtypemask = ChannelType_Left | ChannelType_Right;
     break;
@@ -82,9 +85,13 @@
   uint8_t new_lpcm_info;
   uint8_t dynamic_range;
   ChannelType_t chtypemask;
+  int audio_emphasis;
+  int audio_mute;
 
   //header data
-  audio_frame_number = start[0];
+  audio_emphasis = (start[0] >> 7) & 0x1;
+  audio_mute = (start[0] >> 6) & 0x1;
+  audio_frame_number = start[0] & 0x1f;
   new_lpcm_info = start[1];
   dynamic_range = start[2];
 
@@ -94,6 +101,10 @@
 
   bytes_left = len-3;
 
+  if(audio_emphasis || audio_mute) {
+    WARNING("please send bug report first use emphasis :%d, mut: %d\n",
+	    audio_emphasis, audio_mute);
+  }
 
   if(new_lpcm_info != handle->lpcm_info) {
     int new_ch = 0;
@@ -104,23 +115,30 @@
     audio_format_t new_format;
     
     handle->lpcm_info = new_lpcm_info;
-    if(new_lpcm_info & 0x10) {
-      new_sample_rate = 96000;
-    } else {
+    switch((new_lpcm_info >> 4) & 0x3) {
+    case 0:
       new_sample_rate = 48000;
+      break;
+    case 1:
+      new_sample_rate = 96000;
+      break;
+    default:
+      WARNING("send bug report lpcm sample rate: %d\n",
+	      (new_lpcm_info >> 4) & 0x3);
+      break;
     }
-    if((new_ch = (new_lpcm_info & 0x07))) {
-      new_ch = new_ch + 1;
-    } else {
-      DNOTE("%s", "REPORT BUG: is mono 2ch(dual mono) or really 1 ch"); 
-      new_ch = 2; // is mono 2ch(dual mono) or really 1 ch ?
+    if((new_lpcm_info >> 3) & 0x1) { // DVD-A ?
+      WARNING("send bug report lpcm sample rate extra: %d\n",
+	      (new_lpcm_info >> 3) & 0x1);
     }
 
+    new_ch = (new_lpcm_info & 0x7) + 1;
+
     if(new_ch > 2) {
       ERROR("%s", "REPORT BUG: lpcm > 2 channels not supported\n");
     }
 
-    new_quantization_word_length = (new_lpcm_info & 0xC0) >> 6;
+    new_quantization_word_length = (new_lpcm_info >> 6 ) & 0x3;
 
     switch(new_quantization_word_length) {
     case 0:
@@ -132,7 +150,7 @@
       new_quantization_word_length = 20;
       new_sample_size = 3; // ? 20bit contained in ? bytes
       ERROR("%s", "REPORT BUG lpcm: 20bit format not supported\n");
-      handle->super_frame_size = new_ch * new_sample_size;
+      handle->super_frame_size = new_ch * 2 * 2 + new_ch;
       break;
     case 2:
       new_quantization_word_length = 24;
@@ -167,8 +185,16 @@
 
     
     new_format.ch_array = malloc(handle->channels * sizeof(ChannelType_t));
-    new_format.ch_array[0] = ChannelType_Left;
-    new_format.ch_array[1] = ChannelType_Right;
+    switch(handle->channels) {
+    case 2:
+      new_format.ch_array[1] = ChannelType_Right;
+    case 1:
+      new_format.ch_array[0] = ChannelType_Left;
+      break;
+    default:
+      break;
+    }
+
     if(handle->channels > 2) {
       FATAL("%d lpcm channels, not implemented, REPORT BUG\n",
 	    handle->channels);
@@ -266,7 +292,7 @@
     return NULL;
   }
   
-  memset(&handle->handle, 0, sizeof(struct adec_handle_s));
+  memset(&handle->handle, 0, sizeof(adec_lpcm_handle_t));
   // not set: drain
   handle->handle.decode = (audio_decode_t) decode_lpcm;  // function pointers
   handle->handle.flush  = (audio_flush_t)  flush_lpcm;
@@ -278,9 +304,9 @@
   handle->PTS = 0;
   handle->pts_valid = 0;
   handle->scr_nr = 0;
-  handle->sample_rate = 0;
-  //  handle->decoded_format = NULL;
-
+  // Should really be an invalid value to force the init code in decode_lpcm
+  // run the first time (calles audio_config & init_sample_conversion).
+  handle->lpcm_info = 0xff;
   
   return (adec_handle_t *)handle;
 }
diff -urN -x CVS -x .cvsignore ogle-0.9.2/ac3/decode_mpeg.c ogle/ac3/decode_mpeg.c
--- ogle-0.9.2/ac3/decode_mpeg.c	2003-01-02 22:05:56.000000000 +0100
+++ ogle/ac3/decode_mpeg.c	2004-08-21 10:00:31.000000000 +0200
@@ -51,6 +51,7 @@
   int availflags;
   int output_flags;
   int decoding_flags;
+  int mode; //channels
 
   /* libmad */
   struct mad_stream stream;
@@ -61,6 +62,25 @@
 } adec_mpeg_handle_t;
 
 
+
+static int mpeg_mode_to_channels(enum mad_mode mode)
+{
+  ChannelType_t chtypemask = 0;
+  
+  switch(mode) {
+  case MAD_MODE_SINGLE_CHANNEL:
+    chtypemask = ChannelType_Mono;
+    break;
+  case MAD_MODE_DUAL_CHANNEL:
+  case MAD_MODE_JOINT_STEREO:
+  case MAD_MODE_STEREO:
+    chtypemask = ChannelType_Left | ChannelType_Right;
+    break;
+  }
+  
+  return chtypemask;
+}
+
 static int decode_mpeg(adec_mpeg_handle_t *h, uint8_t *start, int len,
 		       int pts_offset, uint64_t new_PTS, int scr_nr)
 {
@@ -151,16 +171,26 @@
 	int frame_scr_nr;
 	mad_synth_frame(&h->synth, &h->frame);
 	
-	if(h->frame.header.samplerate != h->sample_rate) {
+	if((h->frame.header.samplerate != h->sample_rate) ||
+	   (h->frame.header.mode != h->mode)) {
 	  audio_format_t new_format;
+	  int num_channels;
 	  
+	  num_channels = MAD_NCHANNELS(&h->frame.header);
 	  h->sample_rate = h->frame.header.samplerate;
-	  audio_config(h->handle.config, 2, h->sample_rate, 16);
-	  
-	  new_format.ch_array = malloc(2 * sizeof(ChannelType_t));
-	  new_format.ch_array[0] = ChannelType_Left;
-	  new_format.ch_array[1] = ChannelType_Right;
+	  h->mode = h->frame.header.mode;
 	  
+	  audio_config(h->handle.config, 
+		       mpeg_mode_to_channels(h->mode),
+		       h->sample_rate, 16);
+	  new_format.nr_channels = num_channels;
+	  new_format.ch_array = malloc(num_channels * sizeof(ChannelType_t));
+	  if(num_channels == 1) {
+	    new_format.ch_array[0] = ChannelType_Mono;
+	  } else {
+	    new_format.ch_array[0] = ChannelType_Left;
+	    new_format.ch_array[1] = ChannelType_Right;
+	  }
 	  new_format.sample_rate = h->sample_rate;
 	  new_format.sample_resolution = 16;
 	  new_format.sample_format = SampleFormat_MadFixed;
@@ -248,7 +278,7 @@
     return NULL;
   }
   
-  memset(&handle->handle, 0, sizeof(struct adec_handle_s));
+  memset(&handle->handle, 0, sizeof(adec_mpeg_handle_t));
   // not set: drain
   handle->handle.decode = (audio_decode_t) decode_mpeg;  // function pointers
   handle->handle.flush  = (audio_flush_t)  flush_mpeg;
diff -urN -x CVS -x .cvsignore ogle-0.9.2/autogen.sh ogle/autogen.sh
--- ogle-0.9.2/autogen.sh	2001-11-22 23:27:51.000000000 +0100
+++ ogle/autogen.sh	2004-03-07 14:57:51.000000000 +0100
@@ -2,10 +2,11 @@
 set -x
 
 aclocal
+#aclocal -I <libtool m4 dir> -I <`xml2-config --prefix`/share/aclocal>
 libtoolize --copy --automake
 #autoheader
 #add --include-deps if you want to bootstrap with any other compiler than gcc
 #automake --copy --add-missing --include-deps
 automake --copy --add-missing
 autoconf
-rm -f config.cache
\ No newline at end of file
+rm -f config.cache
diff -urN -x CVS -x .cvsignore ogle-0.9.2/common/Makefile.am ogle/common/Makefile.am
--- ogle-0.9.2/common/Makefile.am	2003-10-14 03:05:15.000000000 +0200
+++ ogle/common/Makefile.am	2004-07-29 11:39:52.000000000 +0200
@@ -20,4 +20,4 @@
 AM_CPPFLAGS = @TOP_INCLUDES@
 AM_CFLAGS = @O_CFLAGS@
 
-libcommon_a_SOURCES = sync.c timemath.c
+libcommon_a_SOURCES = sync.c timemath.c shm.c
diff -urN -x CVS -x .cvsignore ogle-0.9.2/common/shm.c ogle/common/shm.c
--- ogle-0.9.2/common/shm.c	1970-01-01 01:00:00.000000000 +0100
+++ ogle/common/shm.c	2004-08-21 10:13:46.000000000 +0200
@@ -0,0 +1,562 @@
+/* Ogle - A video player
+ * Copyright (C) 2004 Björn Englund
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/ipc.h>
+#include <sys/shm.h>
+#include <errno.h>
+#include <string.h>
+
+#include "debug_print.h"
+#include "shm.h"
+
+#ifdef HAVE_POSIX_SHM
+
+#include <unistd.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
+#endif //HAVE_POSIX_SHM
+
+
+
+#ifndef SHM_SHARE_MMU
+#define SHM_SHARE_MMU 0
+#endif
+
+typedef struct {
+  int *shmids;
+  int len;
+} shmid_array_t;
+
+static shmid_array_t created_sysv_shmids = { NULL, 0 };
+
+
+static int shmid_array_add(shmid_array_t *a, int shmid)
+{
+  int n;
+  int *p;
+
+  for(n = 0; n < a->len; n++) {
+    if(a->shmids[n] == -1) {
+      //we found a free position
+      a->shmids[n] = shmid;
+      return 0;
+    }
+  }
+  
+  //no free position, allocate some more
+  p = realloc(a->shmids, (a->len + 8)*sizeof(int));
+  if(p == NULL) {
+    ERROR("shmid_array_add, realloc: %s\n", strerror(errno));
+    return -1;
+  }
+  a->shmids = p;
+  a->len += 8;
+  a->shmids[n] = shmid;
+  n++;
+
+  //initialize the newly allocated positions
+  for(; n < a->len; n++) {
+    a->shmids[n] = -1;
+  }
+  
+  return 0;
+}
+
+
+static int shmid_array_remove(shmid_array_t *a, int shmid)
+{
+  int n;
+
+  if(a) {
+    for(n = 0; n < a->len; n++) {
+      if(a->shmids[n] == shmid) {
+	//we found the position
+	a->shmids[n] = -1;
+	return 0;
+      }
+    }
+  }
+  return -1;
+}
+
+static int remove_all_shmids(shmid_array_t *a, int(*rmfunc)(int))
+{
+  int n;
+  if(a) {
+    if(a->shmids) {
+      for(n = 0; n < a->len; n++) {
+	if(a->shmids[n] != -1) {
+	  //found a shmid, remove it
+	  rmfunc(a->shmids[n]);
+	}
+      }
+      free(a->shmids);
+      a->shmids = NULL;
+      a->len = 0;
+    }
+  }
+  return 0;
+}
+
+#ifdef HAVE_POSIX_SHM
+
+
+#if defined(__FreeBSD__)
+/*
+ * FreeBSD places posix shm objects in the normal filesystem.
+ */
+static const char *shmid_prefix = "/tmp/ogle";
+#else
+/*
+ * Solaris, Linux puts posix shm objects outside normal filesystem
+ * and the name must start with a '/' and not contain any more '/'.
+ * Solaris man page suggest a max of 14 characters for portability.
+ */
+static const char *shmid_prefix = "/ogle";
+#endif
+
+typedef  struct _shm_seg_t {
+  struct _shm_seg_t *next;
+  void *shmaddr;
+  size_t len;
+} shm_seg_t;
+
+static shm_seg_t *segment_list = NULL;
+
+static shmid_array_t created_shmids = { NULL, 0 };
+
+static int use_posix_shm = USE_POSIX_SHM;
+
+static int ogle_shm_initialized = 0;
+
+
+/*
+ * If the environment variable OGLE_USE_POSIX_SHM
+ * is set to '0', psoix shm will not be used, instead
+ * the ogle_shm* functions are redirected to the ogle_sysv_shm* functions.
+ * If it is set to anything other than '0', posix shm will be used.
+ * If not set, the default will be used (depends on configure)
+ */
+static void init_ogle_shm(void)
+{
+  char *env_val;
+  if((env_val = getenv("OGLE_USE_POSIX_SHM"))) {
+    if(!strcmp(env_val, "0")) {
+      use_posix_shm = 0;
+    } else {
+      use_posix_shm = 1;
+    }
+  }
+  ogle_shm_initialized = 1;
+}
+
+static char *no_pshm_str = "OGLE_USE_POSIX_SHM=0";
+
+/*
+ * This is called from the ogle_shm* functions when they fail on
+ * ENOSYS (function not implemented. 
+ * Several Linux distros don't mount tmpfs on /dev/shm by default,
+ * so they don't support POSIX shared memory.
+ * After this call all shm functions are redirected to 
+ * the ogle_sysv* functions instead.
+ */
+static void revert_to_sysv(void)
+{  
+  WARNING("%s", "Reverting to SYSV shm\n");
+  use_posix_shm = 0;
+  putenv(no_pshm_str);
+}
+ 
+
+/*
+ * Creates a shared memory object
+ * size - Requested size in bytes of the object
+ * mode - permissions of object
+ * Returns an int (shmid) that identifies the object or
+ * -1 if the object couldn't be created.
+ */
+int ogle_shmget(int size, int mode)
+{
+  int shmid;
+  int n;
+  int fd;
+  char shmname[64];
+  int retries = 20;
+  int pid;
+  static unsigned short shm_serial = 0;
+
+  if(!ogle_shm_initialized) {
+    init_ogle_shm();
+  }
+  
+  if(!use_posix_shm) {
+    return ogle_sysv_shmget(size, mode);
+  }
+
+  pid = getpid() & 0xffff;
+
+  for(n=0; n < retries; n++) {
+    shmid = pid << 16 | shm_serial;
+    shm_serial++;
+    snprintf(shmname, sizeof(shmname),
+	     "%s%08x", shmid_prefix, shmid);
+    
+    if((fd = shm_open(shmname, O_RDWR | O_CREAT | O_EXCL, mode)) == -1) {
+      switch(errno) {
+      case ENOSYS:
+	//shm_open not implemented, revert to sysv shm
+	WARNING("ogle_shmget, shm_open '%s': %s\n", shmname, strerror(errno));
+	revert_to_sysv();
+	return ogle_sysv_shmget(size, mode);
+	break;
+      case EEXIST:
+	continue;
+      default:
+	ERROR("ogle_shmget, shm_open '%s': %d %s\n",
+	      shmname, errno, strerror(errno));
+	return -1;
+	break;
+      }
+    } else {
+      break;
+    }
+  }
+  if(n == retries) {
+    ERROR("%s", "ogle_shmget: Failed to open a shm object\n");
+    return -1;
+  }
+  
+  if(ftruncate(fd, size) == -1) {
+    ERROR("ogle_shmget, ftruncate: %s\n", strerror(errno));
+    close(fd);
+    shm_unlink(shmname);
+    return -1;
+  }
+
+  close(fd);
+
+  shmid_array_add(&created_shmids, shmid);
+
+  return shmid;
+}
+
+/*
+ * Remove a shared memory object
+ * shmid -  Shared memory identifier produced by ogle_shmget
+ * Returns -1 on error and 0 on success
+ */
+int ogle_shmrm(int shmid)
+{
+  char shmname[64];
+
+  if(!ogle_shm_initialized) {
+    init_ogle_shm();
+  }
+  
+  if(!use_posix_shm) {
+    return ogle_sysv_shmrm(shmid);
+  }
+  
+  DNOTE("Removing shmid: %08x\n", shmid);
+
+  snprintf(shmname, sizeof(shmname),
+	   "%s%08x", shmid_prefix, shmid);
+  if(shm_unlink(shmname) == -1) {
+    switch(errno) {
+    case ENOSYS:
+      //shm_open not implemented, revert ot sysv shm
+      WARNING("ogle_shmrm, shm_unlink '%s': %s\n", shmname, strerror(errno));
+      revert_to_sysv();
+      return ogle_sysv_shmrm(shmid);
+      break;
+    default:
+      ERROR("ogle_shmrm, shm_unlink '%s': %s\n", shmname, strerror(errno));
+      break;
+    }
+  }
+  
+  shmid_array_remove(&created_shmids, shmid);
+
+  return 0;
+}
+
+
+/*
+ * Attach a shared memory object.
+ * shmid - Shared memory identifier produced by ogle_shmget.
+ * len - Will be filled in with the len of the object if call successful
+ * otherwise won't be changed.
+ * Returns the address that the shared memory is attached at or
+ * (void *)-1 on error.
+ */
+void *ogle_shmat(int shmid)
+{
+  char shmname[64];
+  void *shmaddr;
+  struct stat statbuf;
+  int fd;
+  shm_seg_t *shm_p;
+
+  if(!ogle_shm_initialized) {
+    init_ogle_shm();
+  }
+  
+  if(!use_posix_shm) {
+    return ogle_sysv_shmat(shmid);
+  }
+
+  snprintf(shmname, sizeof(shmname),
+	   "%s%08x", shmid_prefix, shmid);
+  
+  if((fd = shm_open(shmname, O_RDWR, 0)) == -1) {
+    switch(errno) {
+    case ENOSYS:
+      //shm_open not implemented, revert ot sysv shm
+      WARNING("ogle_shmat, shm_open '%s': %s\n", shmname, strerror(errno));
+      revert_to_sysv();
+      return ogle_sysv_shmat(shmid);
+      break;
+    default:
+      ERROR("ogle_shmat, shm_open '%s': %s\n", shmname, strerror(errno));
+      return (void *)-1;    
+    }
+  }
+  
+  if(fstat(fd, &statbuf) == -1) {
+    ERROR("ogle_shmat, fstat: %s\n", strerror(errno));
+    close(fd);
+    return (void *)-1;
+  }
+  
+  shmaddr = mmap(NULL, statbuf.st_size, PROT_READ | PROT_WRITE,
+		 MAP_SHARED, fd, 0);
+  if(shmaddr == MAP_FAILED) {
+    ERROR("ogle_shmat, mmap: %s\n", strerror(errno));
+    close(fd);
+    return (void *)-1;
+  }
+  close(fd);
+
+
+
+  /* put the shmaddr and len in a list so we can
+   * get the len from the shmaddr in ogle_shmdt
+   */
+  shm_p = malloc(sizeof(shm_seg_t));
+  shm_p->next = segment_list;
+  shm_p->shmaddr = shmaddr;
+  shm_p->len = statbuf.st_size;
+
+  segment_list = shm_p;
+
+
+  
+  return shmaddr;
+}
+
+
+/*
+ * Detach a shared memory object
+ * shmaddr - address of an object attached with ogle_shmat
+ * Returns 0 on success and -1 on error.
+ */
+int ogle_shmdt(void *shmaddr)
+{
+  shm_seg_t *p, **lp;
+  int len = 0;
+
+  if(!ogle_shm_initialized) {
+    init_ogle_shm();
+  }
+  
+  if(!use_posix_shm) {
+    return ogle_sysv_shmdt(shmaddr);
+  }
+
+  /* find the shmaddr previously stored in the segment list */
+  for(lp = &segment_list, p = NULL; *lp != NULL; lp = &((*lp)->next)) {
+    if((*lp)->shmaddr == shmaddr) {
+      p = *lp;
+      len = p->len;
+      *lp = (*lp)->next;
+      free(p);
+      break;
+    }
+  }
+  
+  if(p == NULL) {
+    /* shmaddr was not in list */
+    ERROR("%s", "ogle_shmdt: Address not attached\n");
+    return -1;
+  }
+
+  if(munmap(shmaddr, len) == -1) {
+    ERROR("ogle_shmdt: %s\n", strerror(errno));
+    return -1;
+  }
+  
+  return 0;
+}
+
+/*
+ * Returns 1 if POSIX shm will be  used or 0 if SYSV shm.
+ * Should be called first, before any other processes that use ogle_shm
+ * are fork()'d
+ */
+int ogle_shm_init(void)
+{
+  char shmname[64];
+  int fd;
+
+  if(!ogle_shm_initialized) {
+    init_ogle_shm();
+  }
+  
+  if(!use_posix_shm) {
+    return 0;
+  }
+  
+  snprintf(shmname, sizeof(shmname),
+	   "%s.%08x", shmid_prefix, getpid());
+  
+  if((fd = shm_open(shmname, O_RDWR | O_CREAT | O_EXCL, 0600)) == -1) {
+    switch(errno) {
+    case ENOSYS:
+      //shm_open not implemented, revert to sysv shm
+      WARNING("ogle_shm_init, shm_open: %s\n", strerror(errno));
+      revert_to_sysv();
+      return 0;
+      break;
+    default:
+      ERROR("ogle_shm_init, shm_open '%s': %d %s\n",
+	    shmname, errno, strerror(errno));
+      break;
+    }
+  } else {
+    close(fd);
+    shm_unlink(shmname);      
+  }
+
+  //shm_open works
+  
+  return 1;
+}
+
+#else
+
+int ogle_shm_init(void)
+{
+  return 0;
+}
+
+#endif //HAVE_POSIX_SHM
+
+/*
+ * Create a SYSV shared memory object.
+ * sise - Requested size of the object.
+ * mode - permissions of object.
+ * Returns a shmid or (void *)-1 on error.
+ */
+int ogle_sysv_shmget(size_t size, int mode)
+{
+  int shmid;
+  
+  DNOTE("Getting %d bytes sysv shm\n", size);
+  shmid = shmget(IPC_PRIVATE, size, mode | IPC_CREAT);
+  if(shmid == -1) {
+    ERROR("ogle_sysv_shmget: %s\n", strerror(errno));
+  }
+
+  shmid_array_add(&created_sysv_shmids, shmid);
+
+  return shmid;
+}
+
+/*
+ * Attach a SYSV shared memory object.
+ * shmid - identifier of object from ogle_sysv_shmget.
+ * Returns address where object is attached or (void *)-1 on error.
+ */
+void *ogle_sysv_shmat(int shmid)
+{
+  void *shmaddr;
+  
+  shmaddr = shmat(shmid, NULL, SHM_SHARE_MMU);
+
+  if(shmaddr == (void *)-1) {
+    ERROR("ogle_sysv_shmat: %s\n", strerror(errno));
+  }
+  
+  return shmaddr;
+}
+
+/*
+ * Detach a SYSV shared memory object
+ * shmaddr - address of object to detach
+ * Returns 0 on success or -1 on error
+ */
+int ogle_sysv_shmdt(void *shmaddr)
+{
+  int r;
+
+  r = shmdt(shmaddr);
+  if(r == -1) {
+    ERROR("ogle_sysv_shmdt: %s\n", strerror(errno));
+  }
+
+  return r;
+}
+
+/*
+ * Remove a SYSV shared memory object
+ * shmid - identifier of object to remove
+ * Returns 0 on success or -1 on failure.
+ */
+int ogle_sysv_shmrm(int shmid)
+{
+  int r;
+
+  DNOTE("Removing sysv shmid: %d\n", shmid);
+
+  r = shmctl(shmid, IPC_RMID, NULL);
+  if(r == -1) {
+    ERROR("ogle_sysv_shmrm: %s\n", strerror(errno));
+  }
+
+  shmid_array_remove(&created_sysv_shmids, shmid);
+
+  return r;
+}
+
+
+int ogle_shmrm_all(void)
+{
+  
+#ifdef HAVE_POSIX_SHM
+  remove_all_shmids(&created_shmids, ogle_shmrm);
+#endif
+  
+  remove_all_shmids(&created_sysv_shmids, ogle_sysv_shmrm);
+  
+  return 0;
+}
diff -urN -x CVS -x .cvsignore ogle-0.9.2/configure.in ogle/configure.in
--- ogle-0.9.2/configure.in	2003-11-04 12:18:41.000000000 +0100
+++ ogle/configure.in	2006-01-25 17:54:11.000000000 +0100
@@ -1,25 +1,45 @@
 dnl Process this file with autoconf to produce a configure script.
 AC_INIT(ac3/ac3dec_wrap.c)
-AM_INIT_AUTOMAKE(ogle, 0.9.2)
+AM_INIT_AUTOMAKE(ogle, 0.9.2-cvs)
 dnl AM_CONFIG_HEADER(config.h)
 AM_MAINTAINER_MODE
 AC_CANONICAL_HOST
-
+dnl check CFLAGS before AC_PROG_CC is run because it sets CFLAGS if not set
+USER_CFLAGS="$CFLAGS"
 dnl Checks for programs.
 AC_PROG_CC
-
 dnl AM_DISABLE_SHARED
 AM_PROG_LIBTOOL
-
 dnl Checks for typedefs, structures, and compiler characteristics.
 AC_C_BIGENDIAN
 AC_C_CONST
 AC_C_ALWAYS_INLINE
 AC_CHECK_GENERATE_INTTYPES([include])
 
+MANDATORY_MISSING_LIBS=""
 
 dnl Checks for header files.
 AC_CHECK_HEADERS([byteswap.h sys/bswap.h sys/endian.h sys/param.h stropts.h])
+AC_CHECK_HEADERS([poll.h sys/poll.h sys/select.h])
+AC_CHECK_FUNCS(poll)
+
+
+dnl ---------------------------------------------------------
+dnl libdir suffix
+dnl ---------------------------------------------------------
+
+libdir_suffix="lib"
+AC_ARG_WITH(libdir-suffix, 
+  AC_HELP_STRING([--with-libdir-suffix=suffix],
+                 [Specify the default libdir suffix to use.
+		 If you want libs to be searched for in PREFIX/lib64 use
+		 --with-libdir-suffix=lib64]), 
+  [libdir_suffix=$withval])
+
+dnl ---------------------------------------------------------
+dnl end libdir suffix
+dnl ---------------------------------------------------------
+
 
 dnl Find X Window System
 AC_PATH_XTRA
@@ -93,16 +113,22 @@
     jpeg_path=$ac_default_prefix
   fi  
 fi
+
+
 dnl Both this and the libdvdread should first test and see if any flags
 dnl beside -lname are needed. Then they the suggested path (+ some standard?)
+jpeg_lib="$jpeg_path/$libdir_suffix"
+jpeg_include="$jpeg_path/include"
+
 TMPCFLAGS=$CFLAGS
-CFLAGS="-L$jpeg_path/lib"
+CFLAGS="$CFLAGS -L$jpeg_lib"
 AC_CHECK_LIB(jpeg, main, 
-  [ JPEG_LIBS="-L$jpeg_path/lib -R$jpeg_path/lib -ljpeg"
-    JPEG_CPPFLAGS=-I$jpeg_path/include
+  [ JPEG_LIBS="-L$jpeg_lib -R$jpeg_lib -ljpeg"
+    JPEG_CPPFLAGS=-I$jpeg_include
   ],
-  [AC_MSG_ERROR([Need libjpeg, install it and/or specify it's location])], 
-  -L$jpeg_path/lib)
+  [AC_MSG_WARN([Need libjpeg, install it and/or specify it's location])
+    MANDATORY_MISSING_LIBS="${MANDATORY_MISSING_LIBS}libjpeg, " ], 
+  -L$jpeg_lib)
 
 CFLAGS=$TMPCFLAGS
 
@@ -123,7 +149,8 @@
 CPPFLAGS="-w $CPPFLAGS $JPEG_CPPFLAGS"
 AC_CHECK_HEADER(jpeglib.h,, 
   [ AC_MSG_WARN([Can not find jpeglib.h, need the libjpeg headers])
-    AC_MSG_ERROR([Install the headers and/or specify their location]) 
+    AC_MSG_WARN([Install the headers and/or specify their location])
+    MANDATORY_MISSING_LIBS="${MANDATORY_MISSING_LIBS}libjpeg headers, " 
   ])
 CPPFLAGS=$saved_CPPFLAGS
 
@@ -157,49 +184,80 @@
 AC_CHECK_FUNCS(madvise)
 
 
+
+dnl ---------------------------------------------------------
+dnl posix shm
+dnl ---------------------------------------------------------
+
+dnl shm_open is in librt on Solaris, Linux
+AC_CHECK_FUNC(shm_open, [ AC_DEFINE([HAVE_POSIX_SHM], 1, [ ]) ], 
+  AC_CHECK_LIB(rt, shm_open, 
+    [ AC_DEFINE([HAVE_POSIX_SHM], 1, [ ])
+      LIBS="$LIBS -lrt"
+    ]
+  )
+)
+dnl define to 1 for default use of posix shm or 
+dnl define to 0 for default not use posix shm
+dnl This should be autoselected based on platform
+dnl if there are any performance or other problems with
+dnl posix shm.
+dnl This can be overridden at runtime with the env var OGLE_USE_POSIX_SHM
+AC_DEFINE([USE_POSIX_SHM], 1, [ ])
+
+dnl ---------------------------------------------------------
+dnl end posix shm
+dnl ---------------------------------------------------------
+
+
 dnl ---------------------------------------------------------
 dnl dvdread
 dnl ---------------------------------------------------------
 
-dvd_path=""
-AC_ARG_WITH(dvdread, 
-  AC_HELP_STRING([--with-dvdread=path],
+dvdread_path=""
+AC_ARG_WITH(libdvdread, 
+  AC_HELP_STRING([--with-libdvdread=path],
                  [specify the install prefix to libdvdread]), 
-  [if test "x$with_dvdread" = xno; then
+  [if test "x$with_libdvdread" = xno; then
      AC_MSG_ERROR([You must have/use libdvdread])
    fi
-   if test "x$with_dvdread" != xyes; then
-     dvd_path=$with_dvdread
+   if test "x$with_libdvdread" != xyes; then
+     dvdread_path=$with_libdvdread
    fi])
-if test -z "$dvd_path"; then
+
+if test -z "$dvdread_path"; then
   dnl We have nothing better to go on, guess that it's installed in prefix
   if test "x$prefix" != xNONE; then
-    dvd_path=$prefix
+    dvdread_path=$prefix
   else
-    dvd_path=$ac_default_prefix
+    dvdread_path=$ac_default_prefix
   fi
 fi
 
-TMPCFLAGS=$CFLAGS
-CFLAGS="-L$dvd_path/lib"
+dvdread_lib="$dvdread_path/$libdir_suffix"
+dvdread_include="$dvdread_path/include"
 
+TMPCFLAGS=$CFLAGS
+CFLAGS="$CFLAGS -L$dvdread_lib"
 AC_CHECK_LIB(dvdread, DVDDiscID, 
-  [ DVDREAD_LIBS="-L$dvd_path/lib -R$dvd_path/lib -ldvdread" 
-    DVDREAD_CPPFLAGS=-I$dvd_path/include
+  [ DVDREAD_LIBS="-L$dvdread_lib -R$dvdread_lib -ldvdread" 
+    DVDREAD_CPPFLAGS=-I$dvdread_include
   ],
   [
     AC_CHECK_LIB(dvdread, DVDOpen, 
-      [ AC_MSG_ERROR([Upgrade libdvdread to 0.9.4 or later]) ],
-      [ AC_MSG_ERROR([Need libdvdread, install it or specify it's location])],
-      -L$dvd_path/lib)
-  ], -L$dvd_path/lib)
+      [ AC_MSG_WARN([Upgrade libdvdread to 0.9.4 or later]) 
+      MANDATORY_MISSING_LIBS="${MANDATORY_MISSING_LIBS}libdvdread >= 0.9.4, " ],
+      [ AC_MSG_WARN([Need libdvdread, install it or specify it's location])
+      MANDATORY_MISSING_LIBS="${MANDATORY_MISSING_LIBS}libdvdread, " ],
+      -L$dvdread_lib)
+  ], -L$dvdread_lib)
 
 CFLAGS=$TMPCFLAGS
 
-AC_ARG_WITH(dvdread-includes, 
-  AC_HELP_STRING([--with-dvdread-includes=path],
+AC_ARG_WITH(libdvdread-includes, 
+  AC_HELP_STRING([--with-libdvdread-includes=path],
               [specify location of libdvdread headers]), 
-  [DVDREAD_CPPFLAGS=-I$with_dvdread_includes])
+  [DVDREAD_CPPFLAGS=-I$with_libdvdread_includes])
 
 dnl if test x"$DVDREAD_CPPFLAGS" = x"-I/usr/local/include"; then
 dnl  DVDREAD_CPPFLAGS=""
@@ -217,7 +275,8 @@
 CPPFLAGS="-w $CPPFLAGS $DVDREAD_CPPFLAGS"
 AC_CHECK_HEADER(dvdread/dvd_reader.h,, 
   [ AC_MSG_WARN([Can not find dvd_reader.h, need the libdvdread headers])
-    AC_MSG_ERROR([Install the headers and/or specify their location]) 
+    AC_MSG_WARN([Install the headers and/or specify their location])
+    MANDATORY_MISSING_LIBS="${MANDATORY_MISSING_LIBS}libdvdread headers, " 
   ])
 CPPFLAGS=$saved_CPPFLAGS
 
@@ -293,7 +352,7 @@
   AC_HELP_STRING([--with-liba52=path],
                  [specify the install prefix to liba52 (a52dec)]), 
   [if test "x$with_liba52" = xno; then
-     AC_MSG_ERROR([You must have/use a52dec])
+     AC_MSG_WARN([You must have/use a52dec])
    fi
    if test "x$with_liba52" != xyes; then
      a52_path=$with_liba52
@@ -307,30 +366,34 @@
   fi
 fi
 
-TMPCFLAGS=$CFLAGS
-CFLAGS="-L$a52_path/lib"
+a52_lib="$a52_path/$libdir_suffix"
+a52_include="$a52_path/include"
 
+TMPCFLAGS=$CFLAGS
+CFLAGS="$CFLAGS -L$a52_lib"
 dnl a52_free is a new function in 0.7.3
 AC_CHECK_LIB(a52, a52_free, 
   [ 
-    A52_LIBS="-L$a52_path/lib -R$a52_path/lib -la52" 
-    A52_CPPFLAGS=-I$a52_path/include
+    A52_LIBS="-L$a52_lib -R$a52_lib -la52" 
+    A52_CPPFLAGS=-I$a52_include
   ],
   [
     if test "x$have_mlib" = xyes; then
       AC_CHECK_LIB(a52, a52_init, 
-        [ AC_MSG_ERROR([You have liba52 0.7.2 or earlier, need 0.7.3 or later])
-        ],
-        [ AC_MSG_ERROR([Need liba52, install a52dec or specify it's location])
-        ], -L$a52_path/lib -L$mlib_path/lib -lmlib -lm)
+        [ AC_MSG_WARN([You have liba52 0.7.2 or earlier, need 0.7.3 or later])
+	  MANDATORY_MISSING_LIBS="${MANDATORY_MISSING_LIBS}liba52 >= 0.7.3, " ],
+	[ AC_MSG_WARN([Need liba52, install a52dec or specify it's location])
+	  MANDATORY_MISSING_LIBS="${MANDATORY_MISSING_LIBS}liba52, " ],
+	-L$a52_lib -L$mlib_path/lib -lmlib -lm)
     else
       AC_CHECK_LIB(a52, a52_init, 
-        [ AC_MSG_ERROR([You have liba52 0.7.2 or earlier, need 0.7.3 or later])
-        ],
-        [ AC_MSG_ERROR([Need liba52, install a52dec or specify it's location])
-        ], -L$a52_path/lib -lm)
+        [ AC_MSG_WARN([You have liba52 0.7.2 or earlier, need 0.7.3 or later])
+          MANDATORY_MISSING_LIBS="${MANDATORY_MISSING_LIBS}liba52 >= 0.7.3, " ],
+        [ AC_MSG_WARN([Need liba52, install a52dec or specify it's location])
+	  MANDATORY_MISSING_LIBS="${MANDATORY_MISSING_LIBS}liba52, " ],
+	-L$a52_lib -lm)
     fi
-  ], [-L$a52_path/lib -lm])
+  ], [-L$a52_lib -lm])
 
 CFLAGS=$TMPCFLAGS
 
@@ -353,8 +416,8 @@
 CPPFLAGS="-w $CPPFLAGS $A52_CPPFLAGS"
 AC_CHECK_HEADER(a52dec/a52.h,, 
     [ AC_MSG_WARN([Can not find a52dec/a52.h, need the liba52 headers])
-      AC_MSG_ERROR([Install a52dec(-dev) and/or specify it's location]) 
-    ])
+      AC_MSG_WARN([Install a52dec(-dev) and/or specify it's location]) 
+      MANDATORY_MISSING_LIBS="${MANDATORY_MISSING_LIBS}liba52 headers, " ])
 CPPFLAGS=$saved_CPPFLAGS
 
 AC_SUBST(A52_CPPFLAGS)
@@ -373,7 +436,7 @@
   AC_HELP_STRING([--with-libmad=path],
                  [specify the install prefix to libmad]), 
   [if test "x$with_libmad" = xno; then
-     AC_MSG_ERROR([You must have/use libmad])
+     AC_MSG_WARN([You must have/use libmad])
    fi
    if test "x$with_libmad" != xyes; then
      mad_path=$with_libmad
@@ -387,15 +450,18 @@
   fi
 fi
 
-TMPCFLAGS=$CFLAGS
-CFLAGS="-L$mad_path/lib"
+mad_lib="$mad_path/$libdir_suffix"
+mad_include="$mad_path/include"
 
+TMPCFLAGS=$CFLAGS
+CFLAGS="$CFLAGS -L$mad_lib"
 AC_CHECK_LIB(mad, mad_frame_decode, 
   [ 
-    MAD_LIBS="-L$mad_path/lib -R$mad_path/lib -lmad" 
-    MAD_CPPFLAGS=-I$mad_path/include
-  ],[AC_MSG_ERROR([Need libmad, install it or specify it's location])],
-    [-L$mad_path/lib])
+    MAD_LIBS="-L$mad_lib -R$mad_lib -lmad" 
+    MAD_CPPFLAGS=-I$mad_include
+  ],[AC_MSG_WARN([Need libmad, install it or specify it's location])
+     MANDATORY_MISSING_LIBS="${MANDATORY_MISSING_LIBS}libmad, " ],
+    [-L$mad_lib])
 
 CFLAGS=$TMPCFLAGS
 
@@ -409,8 +475,8 @@
 CPPFLAGS="-w $CPPFLAGS $MAD_CPPFLAGS"
 AC_CHECK_HEADER(mad.h,, 
     [ AC_MSG_WARN([Can not find mad.h, need the libmad headers])
-      AC_MSG_ERROR([Install libmad and/or specify it's location]) 
-    ])
+      AC_MSG_WARN([Install libmad and/or specify it's location]) 
+      MANDATORY_MISSING_LIBS="${MANDATORY_MISSING_LIBS}libmad headers, " ])
 CPPFLAGS=$saved_CPPFLAGS
 
 AC_SUBST(MAD_CPPFLAGS)
@@ -431,7 +497,7 @@
     [  --disable-oss           make a version not using oss])
 if test "x$enable_oss" != xno; then
     case "$host" in
-    *-linux*|*-openbsd*|*-freebsd*|*-bsdi*)
+    *-linux*|*-openbsd*|*-freebsd*|*-bsdi*|*-darwin*)
 
 dnl check for headers.. only define LIBOGLEAO_OSS if library and headers found.
         AC_DEFINE([LIBOGLEAO_OSS],,[libogleao OSS audio support])
@@ -441,7 +507,7 @@
 	DEFAULT_AUDIO_DRIVER="oss"
 	DEFAULT_AUDIO_DEVICE="/dev/dsp"
     ;;
-    *-sun-solaris*|*-hpux*)
+    *-solaris*|*-hpux*)
         AC_CHECK_LIB([OSSlib],[OSS_init],
             [LIBOGLEAO_LIBS="$LIBOGLEAO_LIBS -lOSSlib"
              AC_DEFINE([LIBOGLEAO_OSS],,[libogleao OSS audio support])
@@ -474,7 +540,7 @@
     [  --disable-sunaudio      make a version not using Sun audio])
 if test "x$enable_sunaudio" != xno; then
     case "$host" in
-    *-sun-solaris*)
+    *-solaris*)
 
 dnl check for headers.. only define LIBOGLEAO_SOLARIS if headers are found.
         AC_DEFINE([LIBOGLEAO_SOLARIS],,[libogleao solaris audio support])
@@ -495,7 +561,7 @@
           [ 
 #include <sys/asoundlib.h>
 #if defined(SND_LIB_MAJOR) && defined(SND_LIB_MINOR)
-#if SND_LIB_MAJOR>0 || (SND_LIB_MAJOR==0 && SND_LIB_MINOR==5)
+#if SND_LIB_MAJOR==0 && SND_LIB_MINOR<6
 AP_maGiC_VALUE
 #endif
 #endif
@@ -549,7 +615,13 @@
 dnl ---------------------------------------------------------
 
 AM_PATH_XML2(2.4.19, AC_DEFINE(HAVE_XML, 1, [libxml found]),
-  [ AC_MSG_ERROR([Install libxml2(-dev) and/or specify it's location]) ])
+  [ AC_MSG_WARN([Install libxml2(-dev) and/or specify it's location])
+  MANDATORY_MISSING_LIBS="${MANDATORY_MISSING_LIBS}libxml2 and/or headers, " ])
+
+if test "x$XML_CPPFLAGS" = x; then
+   XML_CPPFLAGS=$XML_CFLAGS
+   AC_SUBST(XML_CPPFLAGS)
+fi
 
 dnl ---------------------------------------------------------
 dnl end libxml
@@ -619,6 +691,10 @@
 dnl end Xinerama
 dnl ---------------------------------------------------------
 
+AC_CHECK_LIB(nsl, socket)
+AC_CHECK_LIB(socket, socket)
+
+
 
 dnl ---------------------------------------------------------
 dnl config file
@@ -689,6 +765,10 @@
 
 if test "x$GCC" = xyes; then
   CFLAGS="$CFLAGS -Wall"
+  GCC_VERSION=`$CC -v 2>&1 | grep version | awk '/^gcc version/ { print $3 }'`
+  GCC_VERSION_MAJOR=`echo $GCC_VERSION | awk 'BEGIN { FS = "." } { print $1 }'`
+  GCC_VERSION_MINOR=`echo $GCC_VERSION | awk 'BEGIN { FS = "." } { print $2 }'`
+  GCC_VERSION_MICRO=`echo $GCC_VERSION | awk 'BEGIN { FS = "." } { print $3 }'`
 else
     dnl non-GCC flags - we probably need exact configuration triplets here.
     case "$host" in
@@ -715,6 +795,7 @@
 
 USE_MMX=
 USE_ALTIVEC=
+USE_ALTIVEC_DARWIN=
 USE_SPARCASM=
 case "$host_cpu" in
 i?86)
@@ -724,10 +805,24 @@
 dnl what about k6 / athlon
 dnl will it still assemble the mmx instructions when -march=i386
 dnl	  CFLAGS="$CFLAGS -march=$host_cpu"
-	  XCFLAGS="$CFLAGS -march=i586 -mcpu=pentiumpro"
+
+	  if ( test $GCC_VERSION_MAJOR -ge 4 ) || ( test $GCC_VERSION_MAJOR -eq 3 && test $GCC_VERSION_MINOR -ge 4 ); then
+	     CPU_SCHED="-mtune"
+	  else
+	     CPU_SCHED="-mcpu"
+	  fi
+	  XCFLAGS="-march=i586 $CPU_SCHED=pentiumpro"
 	fi
+	echo "$XCFLAGS"
 	USE_MMX=yes
 	;;
+x86_64)
+        if test "x$GCC" = xyes; then
+          O_CFLAGS="$O_CFLAGS -fomit-frame-pointer -funroll-loops"
+          XCFLAGS=""
+        fi
+        USE_MMX=yes
+        ;;
 sparc)
 	if test "x$GCC" = xyes; then
 	  O_CFLAGS="$O_CFLAGS -mcpu=ultrasparc -mvis"
@@ -738,10 +833,25 @@
 powerpc|ppc)
 	if test "x$GCC" = xyes; then
 	  O_CFLAGS="$O_CFLAGS -fomit-frame-pointer -funroll-loops"
+
+dnl On MacOS X with Apple's gcc3.3, -mcpu=7400 and -faltivec is used.
+dnl We assume that no other version of gcc is used in darwin
+
 dnl is the right? needed? use just -m7400 ? need new gcc for that..
 dnl is there a -mcpu -march flag that we should use?
 dnl should be a try compile on this line.. 
-	  XCFLAGS="-Wa,-m7400"
+
+dnl What are correct options for altivec on other platforms/os/gcc versions?
+	  case "$host_os" in
+	  darwin*)
+	  	XCFLAGS="-mcpu=7400 -faltivec -O3"
+dnl Apples gcc3.3 only understands 'old' motorola-style altivec asm.
+		USE_ALTIVEC_DARWIN=yes
+		;;
+	  *)
+	  	XCFLAGS="-Wa,-m7400"
+		;;
+	  esac
 dnl that sets USE_ALTIVEC depending on the success
 	  USE_ALTIVEC=yes
 	fi
@@ -775,6 +885,19 @@
   BUILD_MMX=1
   CFLAGS="$CFLAGS $XCFLAGS"
 fi
+GCCINFO=
+if test "x$GCC" = xyes; then
+   echo "int main(){return(0);}" > gcctest.c
+   gcc $CFLAGS $CPPFLAGS -S -fverbose-asm -o gcctest.s gcctest.c
+   GCCOPTLIST="gcc options: `grep '^#' gcctest.s`"
+   rm -f gcctest.c gcctest.s
+   for n in $GCCOPTLIST; do
+     GCCINFO="${GCCINFO}${n} "
+   done
+   GCCINFO="`echo $GCCINFO | sed s/#/:/g`"
+fi
+echo "$GCCINFO"
+
 BUILDINFO="`uname -m -r -s -v`"
 BUILDINFO="${BUILDINFO} `uname -p` `date`"
 BUILDINFO="${BUILDINFO}${BUILD_MMX:+ mmx}${BUILD_ALTIVEC:+ Altivec}"
@@ -787,13 +910,17 @@
 
 AC_SUBST(O_CFLAGS)
 AC_SUBST(BUILDINFO)
+AC_SUBST(GCCINFO)
 AC_SUBST(USE_MMX)
 AM_CONDITIONAL(USE_MMX, [test "x$USE_MMX" = xyes])
 AC_SUBST(USE_ALTIVEC)
 AM_CONDITIONAL(USE_ALTIVEC, [test "x$USE_ALTIVEC" = xyes])
+AC_SUBST(USE_ALTIVEC_DARWIN)
+AM_CONDITIONAL(USE_ALTIVEC_DARWIN, [test "x$USE_ALTIVEC" = xyes])
 AC_SUBST(USE_SPARCASM)
 AM_CONDITIONAL(USE_SPARCASM, [test "x$USE_SPARCASM" = xyes])
 
+
 dnl ---------------------------------------------------------
 dnl end Architecture specific stuff
 dnl ---------------------------------------------------------
@@ -830,6 +957,18 @@
   echo "  prefix: $ac_default_prefix"
 fi  
 
+echo "libdvdread CPPFLAGS: $DVDREAD_CPPFLAGS"
+echo "libdvdread LIBS: $DVDREAD_LIBS"
+echo "liba52 CPPFLAGS: $A52_CPPFLAGS"
+echo "liba52 LIBS: $A52_LIBS"
+echo "libmad CPPFLAGS: $MAD_CPPFLAGS"
+echo "libmad LIBS: $MAD_LIBS"
+echo "libjpeg CPPFLAGS: $JPEG_CPPFLAGS"
+echo "libjpeg LIBS: $JPEG_LIBS"
+
+echo "CFLAGS: $CFLAGS"
+echo "O_CFLAGS: $O_CFLAGS"
+
 echo ""
 
 if test "x$BUILD_MMX" = x1; then
@@ -880,3 +1019,12 @@
    echo "  obsd audio:    No"
 fi
 
+if test "x$MANDATORY_MISSING_LIBS" != x; then
+   AC_MSG_ERROR([
+The following *mandatory* libraries/headers are *not* installed
+or couldn't be located. See earlier output for more info.
+Missing libs:
+	$MANDATORY_MISSING_LIBS 
+These libraries are needed to build ogle!
+])
+fi
diff -urN -x CVS -x .cvsignore ogle-0.9.2/ctrl/ctrl.c ogle/ctrl/ctrl.c
--- ogle-0.9.2/ctrl/ctrl.c	2003-03-02 16:50:48.000000000 +0100
+++ ogle/ctrl/ctrl.c	2005-08-23 01:17:42.000000000 +0200
@@ -24,12 +24,14 @@
 #include <fcntl.h>
 #include <unistd.h>
 #include <sys/ipc.h>
-#include <sys/shm.h>
+#ifdef HAVE_SYSV_MSG
 #include <sys/msg.h>
+#endif
 #include <limits.h>
 #include <string.h>
 #include <errno.h>
 #include <signal.h>
+#include <sys/mman.h>
 
 #include <ogle/msgevents.h>
 #include "mpeg.h"
@@ -37,18 +39,17 @@
 #include "queue.h"
 #include "timemath.h"
 #include "debug_print.h"
+#include "shm.h"
 
-#ifndef SHM_SHARE_MMU
-#define SHM_SHARE_MMU 0
-#endif
 
 /* SA_SIGINFO isn't implemented yet on for example NetBSD */
 #if !defined(SA_SIGINFO)
 #define siginfo_t void
 #endif
 
-int create_msgq(void);
+int create_msgq(MsgEventQ_t *q);
 int init_decoder(char *msgqid_str, char *decoderstr);
+int get_sysv_buffer(int size, shm_bufinfo_t *bufinfo);
 int get_buffer(int size, shm_bufinfo_t *bufinfo);
 int create_q(int nr_of_elems, int buf_shmid, 
 	     MsgEventClient_t writer, MsgEventClient_t reader);
@@ -60,18 +61,15 @@
 void int_handler(int sig);
 void sigchld_handler(int sig, siginfo_t *info, void* context);
 
-void remove_q_shm(void);
-void add_q_shmid(int shmid);
-void remove_q_shmid(int shmid);
-void destroy_msgq(void);
+
+void destroy_msgq(MsgEventQ_t *q);
 
 void add_to_pidlist(pid_t pid, char *name);
 int remove_from_pidlist(pid_t pid);
 
-void cleanup_and_exit(void);
+void cleanup_and_exit(MsgEventQ_t *q);
 void slay_children(void);
 
-int msgqid;
 
 int ctrl_data_shmid;
 ctrl_data_t *ctrl_data;
@@ -79,7 +77,7 @@
 char *program_name;
 int dlevel;
 
-char msgqid_str[9];
+char msgqid_str[108];
 
 char *input_file;
 
@@ -155,6 +153,29 @@
 static caps_t *caps_array = NULL;
 static int nr_caps = 0;
 
+
+typedef struct _clientlist_t {
+  struct _clientlist_t *next;
+  MsgEventClient_t id;
+} clientlist_t;
+
+static clientlist_t *clients = NULL;
+
+int client_add(MsgEventClient_t id)
+{
+  clientlist_t *cl;
+  if((cl = malloc(sizeof(clientlist_t))) == NULL) {
+    perror("client_add, malloc");
+    return -1;
+  }
+  cl->id = id;
+  cl->next = clients;
+  clients = cl;
+  
+  return 0;
+}
+
+
 int register_capabilities(MsgEventClient_t client, int caps, cap_state_t state)
 {
   if(nr_caps >= 20) {
@@ -285,6 +306,9 @@
   } else if((capability & DECODE_DTS_AUDIO) == capability) {
     name = getenv("DVDP_DTS");
     *ret_capability = DECODE_DTS_AUDIO;
+  } else if((capability & DECODE_LPCM_AUDIO) == capability) {
+    name = getenv("DVDP_LPCM");
+    *ret_capability = DECODE_LPCM_AUDIO;
   } else if((capability & (DECODE_MPEG1_AUDIO | DECODE_MPEG2_AUDIO))
 	    == capability) {
     name = getenv("DVDP_MPEGAUDIO");
@@ -322,14 +346,14 @@
 
 
 
-static void cleanup(void)
+static void cleanup(MsgEventQ_t *q)
 {
   //DNOTE("waiting for children to really die\n"); 
   
   while(sleep(2)); // Continue sleeping if interupted 
 
   slay_children();
-  cleanup_and_exit();
+  cleanup_and_exit(q);
 }
 
 
@@ -364,7 +388,7 @@
   while(search_capabilities(cap, capclient, retcaps, &state) &&
 	(state != CAP_running)) {
     if(child_killed) {
-      cleanup();
+      cleanup(q);
     }
     if(MsgNextEventInterruptible(q, &r_ev) == -1) {
       switch(errno) {
@@ -406,9 +430,11 @@
 #if DEBUG
     DNOTE("_MsgEventQInitReq, new_id: %d\n", next_client_id);
 #endif
+    client_add(next_client_id);
     ev->type = MsgEventQInitGnt;
     ev->initgnt.newclientid = next_client_id++;
-    MsgSendEvent(q, CLIENT_UNINITIALIZED, ev, 0);
+    MsgSendEvent(q, ev->initreq.client, ev, 0);
+
     break;
   case MsgEventQRegister:
 #if DEBUG
@@ -439,40 +465,67 @@
       shm_bufinfo_t bufinfo;
       
 #if DEBUG
-      DNOTE("_got request for buffer size %d\n",
+      DNOTE("got request for buffer size %d\n",
 	      ev->reqbuf.size);
 #endif
+
       if(get_buffer(ev->reqbuf.size, &bufinfo) == -1) {
 	bufinfo.shmid = -1;
       }
-      
+
       s_ev.type = MsgEventQGntBuf;
       s_ev.gntbuf.shmid = bufinfo.shmid;
       s_ev.gntbuf.size = bufinfo.size;
       MsgSendEvent(q, ev->reqbuf.client, &s_ev, 0);
     }
     break;
+  case MsgEventQReqPicBuf:
+    {
+      shm_bufinfo_t bufinfo;
+      
+#if DEBUG
+      DNOTE("got request for picbuffer size %d\n",
+	      ev->reqpicbuf.size);
+#endif
+
+      if(get_sysv_buffer(ev->reqpicbuf.size, &bufinfo) == -1) {
+	bufinfo.shmid = -1;
+      }
+
+      s_ev.type = MsgEventQGntPicBuf;
+      s_ev.gntpicbuf.shmid = bufinfo.shmid;
+      s_ev.gntpicbuf.size = bufinfo.size;
+      MsgSendEvent(q, ev->reqpicbuf.client, &s_ev, 0);
+    }
+    break;
   case MsgEventQDestroyBuf:
     {
       //DNOTE("_got destroy buffer shmid %d\n", ev->destroybuf.shmid);
-      remove_q_shmid(ev->destroybuf.shmid);
+      ogle_shmrm(ev->destroybuf.shmid);
+      //remove_q_shmid(ev->destroybuf.shmid);
+    }
+    break;
+  case MsgEventQDestroyPicBuf:
+    {
+      //DNOTE("_got destroy picbuffer shmid %d\n", ev->destroypicbuf.shmid);
+      ogle_sysv_shmrm(ev->destroypicbuf.shmid);
     }
     break;
   case MsgEventQDestroyQ:
     {
       //DNOTE("_got destroy Q shmid %d\n", ev->detachq.q_shmid);
-      remove_q_shmid(ev->detachq.q_shmid);
+      ogle_shmrm(ev->detachq.q_shmid);
     }
     break;
   case MsgEventQReqStreamBuf:
     {
       int shmid;
       cap_state_t state = 0;
-      
+#ifdef DEBUG 
       DNOTE("_new stream %x, %x\n",
 	    ev->reqstreambuf.stream_id,
 	    ev->reqstreambuf.subtype);
-      
+#endif
       if(register_stream(ev->reqstreambuf.stream_id,
 			 ev->reqstreambuf.subtype)) {
 	// this stream is wanted
@@ -506,14 +559,19 @@
 				  CAP_started);
 	  }
  // DNOTE("starting decoder %d %s\n", capability, decodername);
-	  init_decoder(msgqid_str, decodername);
+	  if(init_decoder(msgqid_str, decodername) == -1) {
+	    ERROR("ReqStreamBuf: init_decoder: cap:%x, id:%02x, sub_id:%x\n",
+		  capability,
+		  ev->reqstreambuf.stream_id,
+		  ev->reqstreambuf.subtype);
+	  }
  // DNOTE("started decoder %d\n", capability);
 	}
 	
 	while(!search_capabilities(capability, &rcpt, NULL, &state) ||
 	      (state != CAP_running)) {
 	  if(child_killed) {
-	    cleanup();
+	    cleanup(q);
 	  }
 	  if(MsgNextEventInterruptible(q, &r_ev) == -1) {
 	    switch(errno) {
@@ -584,7 +642,7 @@
       }
     }
     break;
-  case MsgEventQReqPicBuf:
+  case MsgEventQReqPicQ:
     {
       int shmid;
       cap_state_t state;
@@ -613,7 +671,7 @@
       while(!search_capabilities(VIDEO_OUTPUT, &rcpt, NULL, &state) ||
 	    (state != CAP_running)) {
 	if(child_killed) {
-	  cleanup();
+	  cleanup(q);
 	}
 	if(MsgNextEventInterruptible(q, &r_ev) == -1) {
 	  switch(errno) {
@@ -643,23 +701,23 @@
       
       // lets create the buffer
 	
-      shmid = create_q(ev->reqpicbuf.nr_of_elems,
-		       ev->reqpicbuf.data_buf_shmid,
-		       ev->reqpicbuf.client,
+      shmid = create_q(ev->reqpicq.nr_of_elems,
+		       ev->reqpicq.data_buf_shmid,
+		       ev->reqpicq.client,
 		       rcpt);
       
       
       // let the writer know which picbuffer to connect to
-      s_ev.type = MsgEventQGntPicBuf;
-      s_ev.gntpicbuf.q_shmid = shmid;
+      s_ev.type = MsgEventQGntPicQ;
+      s_ev.gntpicq.q_shmid = shmid;
       
 #if DEBUG
       DNOTE("create_q, q_shmid: %d picture_buf_shmid: %d\n",
-	    shmid,  ev->reqpicbuf.data_buf_shmid);
+	    shmid,  ev->reqpicq.data_buf_shmid);
 #endif      
-      MsgSendEvent(q, ev->reqpicbuf.client, &s_ev, 0);
+      MsgSendEvent(q, ev->reqpicq.client, &s_ev, 0);
       
-      // connect the picbuf  to the reader
+      // connect the picq  to the reader
       
       s_ev.type = MsgEventQAttachQ;
       s_ev.attachq.q_shmid = shmid;
@@ -679,7 +737,6 @@
 #endif
       ctrl_data->speed = ev->speed.speed;
       
-      
 
       // send speed event to syncmasters
       {
@@ -699,6 +756,62 @@
       }
     }
     break;
+  case MsgEventQStop:
+    {
+      clocktime_t rt;
+      
+      clocktime_get(&rt);
+#if DEBUG
+      DNOTE("_MsgEventQSpeed\n");
+      DNOTE("speed: %.2f\n", ev->speed.speed);
+#endif
+      
+      if(ev->stop.state == 0) {
+	/* first pause play */
+	s_ev.type = MsgEventQSpeed;
+	s_ev.speed.speed = 0.000000001;
+	ctrl_data->speed = s_ev.speed.speed;
+	
+	// send speed event to syncmasters
+	{
+	  // TODO get decoders that do sync...
+	  //
+	  if(search_capabilities(DECODE_AC3_AUDIO, &rcpt, NULL, NULL)) {
+	    
+	    MsgSendEvent(q, rcpt, &s_ev, 0);
+	    
+	  }
+	  
+	  if(search_capabilities(VIDEO_OUTPUT, &rcpt, NULL, NULL)) {
+	    
+	    MsgSendEvent(q, rcpt, &s_ev, 0);
+	    
+	  }
+	}
+      }
+      
+      /* then send stop event */
+      s_ev.type = MsgEventQStop;
+      s_ev.stop.state = ev->stop.state;
+
+      // send stop event to all?
+      {
+	// TODO get decoders that do sync...
+	//
+	if(search_capabilities(DECODE_AC3_AUDIO, &rcpt, NULL, NULL)) {
+	  
+	  MsgSendEvent(q, rcpt, &s_ev, 0);
+	  
+	}
+
+	if(search_capabilities(VIDEO_OUTPUT, &rcpt, NULL, NULL)) {
+	  
+	  MsgSendEvent(q, rcpt, &s_ev, 0);
+	  
+	}
+      }
+    }
+    break;
   default:
     WARNING("handle_events: notice, msgtype %d not handled\n",
 	    ev->type);
@@ -722,7 +835,8 @@
   program_name = &argv[0][c];
 
   GET_DLEVEL();
-
+  
+  umask(0077);
   memset(&sig, 0, sizeof(struct sigaction));
   sig.sa_handler = int_handler;
   sig.sa_flags = 0;
@@ -806,26 +920,47 @@
   
   /* Print the version info so that we get it with bug reports. */
   NOTE("%s %s\n", PACKAGE, VERSION);
-  
+
+  ogle_shm_init();
+
   ctrl_data_shmid = create_ctrl_data();
-  
+
+#ifdef SOCKIPC
+  q.type = MsgEventQType_socket;
+#endif
   /* create msgq */  
-  create_msgq();
-  sprintf(msgqid_str, "%d", msgqid);
-  
+  create_msgq(&q);
+#ifdef SOCKIPC
+  switch(q.type) {
+#ifdef HAVE_SYSV_MSG
+  case MsgEventQType_msgq:
+    sprintf(msgqid_str, "msq:%d", q.msgq.msqid);
+    break;
+#endif
+  case MsgEventQType_socket:
+  snprintf(msgqid_str, sizeof(msgqid_str),
+	   "socket:%s", q.socket.server_addr.sun_path);
+  break;
+  case MsgEventQType_pipe:
+    break;
+  }
+#else
+  sprintf(msgqid_str, "%d", q.msqid);
+#endif  
+
 #if DEBUG
-  DNOTE("msgid: %d\n", msgqid);  
+#ifdef SOCKIPC
+#else
+  DNOTE("msgid: %d\n", q.msqid);  
   {
     struct msqid_ds msgqinfo;
     
-    msgctl(msgqid, IPC_STAT, &msgqinfo);
+    msgctl(q.msqid, IPC_STAT, &msgqinfo);
     
     DNOTE("max_bytes: %ld\n", (long)msgqinfo.msg_qbytes);
   }
 #endif
-
-  q.msqid = msgqid;
-  q.mtype = CLIENT_RESOURCE_MANAGER;
+#endif
 
   if(ui != NULL) {
     MsgEventClient_t ui_client;
@@ -835,7 +970,7 @@
       request_capability(&q, UI_DVD_GUI, &ui_client, NULL);
     } else {
       FATAL("%s", "no ui specified\n");
-      cleanup_and_exit();
+      cleanup_and_exit(&q);
     }
   }
   
@@ -853,7 +988,7 @@
   */
   while(1){
     if(child_killed) {
-      cleanup();
+      cleanup(&q);
     }
     if(MsgNextEventInterruptible(&q, &ev) == -1) {
       switch(errno) {
@@ -1156,40 +1291,154 @@
 }
 
 
-int create_msgq(void)
+int create_msgq(MsgEventQ_t *q)
 {
-  if((msgqid = msgget(IPC_PRIVATE, IPC_CREAT | 0600)) == -1) {
+#ifdef SOCKIPC
+  switch(q->type) {
+#ifdef HAVE_SYSV_MSG
+  case MsgEventQType_msgq:
+    if((q->msgq.msqid = msgget(IPC_PRIVATE, IPC_CREAT | 0600)) == -1) {
+      perror("*ctrl: msgget ipc_creat failed");
+      exit(1);
+    }
+    q->msgq.mtype = CLIENT_RESOURCE_MANAGER;
+    break;
+#endif
+  case MsgEventQType_socket:
+    {
+      char sock_dir[108];
+      struct sockaddr_un server_addr;
+      int server_sd;
+      char *tmpdir;
+      
+      if(!(tmpdir = getenv("TMPDIR"))) {
+	tmpdir = P_tmpdir;
+      }
+      snprintf(sock_dir, sizeof(sock_dir),
+	       "%s/%s.%d", tmpdir, "ogle", getpid());
+      
+      if(mkdir(sock_dir, 0700) == -1) {
+	perror("ctrl: mkdir");
+	exit(1);
+      }
+      
+      server_sd = socket(PF_UNIX, SOCK_DGRAM, 0);
+      if(server_sd == -1) {
+	perror("ctrl: socket");
+	exit(1);
+      }
+
+      server_addr.sun_family = AF_UNIX;
+      snprintf(server_addr.sun_path, sizeof(server_addr.sun_path),
+	       "%s/%ld", sock_dir, CLIENT_RESOURCE_MANAGER);
+      if(bind(server_sd, (struct sockaddr *)&server_addr,
+	      sizeof(server_addr)) == -1) {
+	perror("ctrl: bind");
+	exit(1);
+      }
+      
+      q->socket.clientid = CLIENT_RESOURCE_MANAGER;
+      q->socket.client_addr = server_addr;
+      q->socket.sd = server_sd;
+      q->socket.server_addr.sun_family = AF_UNIX;
+      snprintf(q->socket.server_addr.sun_path, 
+	       sizeof(q->socket.server_addr.sun_path),
+	       "%s", sock_dir);
+    }
+    break;
+  case MsgEventQType_pipe:
+    break;
+  }
+#else
+  if((q->msqid = msgget(IPC_PRIVATE, IPC_CREAT | 0600)) == -1) {
     perror("*ctrl: msgget ipc_creat failed");
     exit(1);
   }
-
+  q->mtype = CLIENT_RESOURCE_MANAGER;
+#endif
   return 0;
 }  
 
 
-void destroy_msgq(void)
+void destroy_msgq(MsgEventQ_t *q)
 {
-  if(msgctl(msgqid, IPC_RMID, NULL) != 0) {
+#ifdef SOCKIPC
+  clientlist_t *cl;
+  char sname[108];
+  
+  switch(q->type) {
+#ifdef HAVE_SYSV_MSG
+  case MsgEventQType_msgq:
+    if(msgctl(q->msgq.msqid, IPC_RMID, NULL) != 0) {
+      perror("*ctrl: msgctl ipc_rmid failed");
+    }
+    q->msgq.msqid = -1;
+    break;
+#endif
+  case MsgEventQType_socket:
+    unlink(q->socket.client_addr.sun_path);
+    close(q->socket.sd);
+    q->socket.sd = -1;
+    for(cl=clients; cl != NULL;) {
+      clientlist_t *next = cl->next;
+
+      snprintf(sname, sizeof(sname),
+	       "%s/%ld", q->socket.server_addr.sun_path, cl->id);
+      if(unlink(sname) == -1) {
+	if(errno != ENOENT) {
+	  perror("destroy_msgq, unlink");
+	  fprintf(stderr, "'%s'\n", sname);
+	}
+      }
+      free(cl);
+      cl = next;
+    }
+    clients = NULL;
+    if(rmdir(q->socket.server_addr.sun_path) == -1) {
+      perror("destroy_msgq, unlink");
+      fprintf(stderr, "'%s'\n", q->socket.server_addr.sun_path);
+    }
+    break;
+  case MsgEventQType_pipe:
+    break;
+  }
+#else
+  if(msgctl(q->msqid, IPC_RMID, NULL) != 0) {
     perror("*ctrl: msgctl ipc_rmid failed");
   }
-  msgqid = -1;
+  q->msqid = -1;
+#endif
 }
 
 
-int get_buffer(int size, shm_bufinfo_t *bufinfo)
+int get_sysv_buffer(int size, shm_bufinfo_t *bufinfo)
 {
   int shmid;
   /* This also creates the image buffers that will be sent to attached
    * from the X server if we use Xv.  So we need to make sure that it
    * has permissions to attach / read it.  */
-  if((shmid = shmget(IPC_PRIVATE,
-		     size,
-		     IPC_CREAT | 0644)) == -1) {
-    perror("*ctrl: get_buffer, shmget failed");
+  if((shmid = ogle_sysv_shmget(size, 0644)) == -1) {
+    ERROR("get_sysv_buffer, ogle_sysv_shmget: %s\n", strerror(errno));
     return -1;
   }
+  
 
-  add_q_shmid(shmid);
+  bufinfo->shmid = shmid;
+  bufinfo->size = size;
+  
+  return 0;
+}
+
+
+
+int get_buffer(int size, shm_bufinfo_t *bufinfo)
+{
+  int shmid;
+
+  if((shmid = ogle_shmget(size, 0600)) == -1) {
+    ERROR("get_buffer, ogle_shmget: %s\n", strerror(errno));
+    return -1;
+  }
 
   bufinfo->shmid = shmid;
   bufinfo->size = size;
@@ -1201,34 +1450,27 @@
 int create_q(int nr_of_elems, int buf_shmid,
 	     MsgEventClient_t writer,  MsgEventClient_t reader)
 {
-  
   int shmid;
   char *shmaddr;
   q_head_t *q_head;
   q_elem_t *q_elems;
   int n;
+  int size = sizeof(q_head_t) + nr_of_elems*sizeof(q_elem_t);
 
-  if((shmid = shmget(IPC_PRIVATE,
-		     sizeof(q_head_t) + nr_of_elems*sizeof(q_elem_t),
-		     IPC_CREAT | 0600)) == -1) {
-    perror("*ctrl: create_q, shmget failed");
+  if((shmid = ogle_shmget(size, 0600)) == -1) {
+    ERROR("create_q, ogle_shmget: %s\n", strerror(errno));
     return -1;
   }
   
-  
-  if((shmaddr = shmat(shmid, NULL, SHM_SHARE_MMU)) == (void *)-1) {
-    perror("*ctrl: create_q, shmat failed");
-    
-    if(shmctl(shmid, IPC_RMID, NULL) != 0) {
-      perror("*ctrl: create_q, shmctl ipc_rmid faild");
+  if((shmaddr = ogle_shmat(shmid)) == (void *)-1) {
+    ERROR("create_q, ogle_shmat: %s\n", strerror(errno));
+    if(ogle_shmrm(shmid) == -1) {
+      ERROR("create_q, ogle_shmrm: %s\n", strerror(errno));
     }
     return -1;
   }
 
-  add_q_shmid(shmid);
-  
   q_head = (q_head_t *)shmaddr;
-  
 
   q_head->data_buf_shmid = buf_shmid;
   q_head->nr_of_qelems = nr_of_elems;
@@ -1245,9 +1487,12 @@
   for(n = 0; n < nr_of_elems; n++) {
     q_elems[n].in_use = 0;
   }
-  if(shmdt(shmaddr) != 0) {
-    perror("*ctrl: create_q, shmdt failed");
+
+
+  if(ogle_shmdt(shmaddr) == -1) {
+    ERROR("create_q, ogle_shmdt: %s\n", strerror(errno));
   }
+
   return shmid;
 }
 
@@ -1261,27 +1506,23 @@
   ctrl_time_t *ctrl_time;
   int n;
   int nr_of_offsets = 32;
-  
-  if((shmid = shmget(IPC_PRIVATE,
-		     sizeof(ctrl_data_t)+
-		     nr_of_offsets*sizeof(ctrl_time_t),
-		     IPC_CREAT | 0600)) == -1) {
-    perror("*ctrl: create_ctrl_data, shmget failed");
+  int size = nr_of_offsets * sizeof(ctrl_time_t); 
+
+  if((shmid = ogle_shmget(sizeof(ctrl_data_t)+size, 0600)) == -1) {
+    ERROR("create_ctrl_data, ogle_shmget: %s\n", strerror(errno));
     return -1;
   }
   
-  if((shmaddr = shmat(shmid, NULL, SHM_SHARE_MMU)) == (void *)-1) {
-    perror("*ctrl: create_ctrl_data, shmat failed");
+  if((shmaddr = ogle_shmat(shmid)) == (void *)-1) {
+    ERROR("create_ctrl_data, ogle_shmat: %s\n", strerror(errno));
     
-    if(shmctl(shmid, IPC_RMID, NULL) == -1) {
-      perror("*ctrl: create_ctrl_data, shmctl ipc_rmid");
+    if(ogle_shmrm(shmid) == -1) {
+      ERROR("create_ctrl_data, ogle_shmrm: %s\n", strerror(errno));
     }
     
     return -1;
   }
   
-  add_q_shmid(shmid);
-  
   ctrl_data = (ctrl_data_t *)shmaddr;
   ctrl_data->mode = MODE_STOP;
   ctrl_data->sync_master = SYNC_NONE;
@@ -1296,62 +1537,13 @@
 }
 
 
-int *shm_ids = NULL;
-int nr_shmids = 0;
-
-void add_q_shmid(int shmid)
+void cleanup_and_exit(MsgEventQ_t *q)
 {
-  nr_shmids++;
-  
-  if((shm_ids = (int *)realloc(shm_ids, sizeof(int)*nr_shmids)) == NULL) {
-    perror("*ctrl: add_q_shmid, realloc failed");
-    nr_shmids--;
-    return;
-  }
 
-  shm_ids[nr_shmids-1] = shmid;
-  
-}
+  destroy_msgq(q);
 
+  ogle_shmrm_all();
 
-void remove_q_shmid(int shmid)
-{
-  int n;
-  
-  for(n = 0; n < nr_shmids; n++) {
-    if(shm_ids[n] == shmid) {
-      DNOTE("removing shmid: %d\n", shm_ids[n]);
-      if(shmctl(shm_ids[n], IPC_RMID, NULL) == -1) {
-	perror("ipc_rmid");
-      }
-      shm_ids[n] = -1;
-    }
-  }
-}
-
-
-void remove_q_shm(void)
-{
-  int n;
-
-  for(n = 0; n < nr_shmids; n++) {
-    if(shm_ids[n] != -1) {
-      DNOTE("removing shmid: %d\n", shm_ids[n]);
-      if(shmctl(shm_ids[n], IPC_RMID, NULL) == -1) {
-	perror("ctrl: ipc_rmid");
-      }
-    }
-  }
-  nr_shmids = 0;
-  free(shm_ids);
-  shm_ids = NULL;
-  
-}
-
-void cleanup_and_exit(void)
-{
-  remove_q_shm();
-  destroy_msgq();
   NOTE("%s", "exiting\n");
   exit(0);
 }
@@ -1399,6 +1591,10 @@
 #endif
 #ifndef WCONTINUED 
 #define WCONTINUED 0
+#endif
+/* WCONTINUED was defined in /usr/include/sys/wait.h during a period
+ * but not WIFCONTINUED, reported and fixed in glibc as bug libc/409 */
+#ifndef WIFCONTINUED
 #define WIFCONTINUED(x) 0
 #endif
 
@@ -1469,12 +1665,27 @@
 #endif
   
   while(1) {
-    if((pid = waitpid(wpid, &stat_loc, WCONTINUED | WUNTRACED)) == -1) {
-      perror("ctrl: waitpid failed");
+    static int use_wcont = 1;
+    int options;
+    
+    //linux waitpid doesn't handle WCONTINUED
+    options = WUNTRACED;
+    if(use_wcont) {
+      options |= WCONTINUED;
+    }
+    if((pid = waitpid(wpid, &stat_loc, options)) == -1) {
       switch(errno) {
       case EINTR:
 	continue;
+      case EINVAL:
+	if(use_wcont) {
+	  use_wcont = 0;
+	  options &= ~WCONTINUED; //remove WCONTINUED from options
+	  DNOTE("%s\n", "Disabling use of WCONTINUED in waitpid");
+	  continue;
+	}
       default:
+	ERROR("waitpid for %d failed: %s\n", wpid, strerror(errno));
 	return;
       }
     }
diff -urN -x CVS -x .cvsignore ogle-0.9.2/doc/man/oglerc.5.in ogle/doc/man/oglerc.5.in
--- ogle-0.9.2/doc/man/oglerc.5.in	2003-08-06 20:06:34.000000000 +0200
+++ ogle/doc/man/oglerc.5.in	2004-07-30 11:12:16.000000000 +0200
@@ -4,8 +4,7 @@
 oglerc \- ogle configuration file
 .SH DESCRIPTION
 The oglerc file is a configuration file for ogle.
-There is one system-wide file in ${prefix}/share/oglerc and an
-optional user file $HOME/.oglerc which overrides system settings.
+There is one system-wide file in @CONFIG_FILE@ (${prefix}/share/ogle/oglerc) and an optional user file $HOME/.oglerc which overrides system settings.
 .br
 The file is written in XML, with a DTD in an external file.
 .br
@@ -326,6 +325,10 @@
 	KP_Right
 SkipBackward	Prior(PageUp)	Skip x seconds backward (nr)
 	KP_Left
+SaveScreenshot	i	Saves a screenshot (.jpg)
+SaveScreenshotWithSPU	I	Saves a screenshot including the subtitle/overlay graphics.
+AudioStreamChange	z	Changes to the next audio stream (nr)
+SubtitleStreamChange	x	Changes to the next subtitle stream (nr)
 .TE
 
 </ogle_conf>
@@ -345,12 +348,9 @@
 The SkipForward and SkipBackward actions use the number argument as the number
 of seconds to skip. The default value is 10 seconds. Entering '30' and then pressing Next(PageDown) will skip 30 seconds forwards. The Skip actions will use the last value entered for any following skips even if no number is entered.
 To get back to the default value, enter 0 and the skip.
-
-
-Non configurable keys:
-  'i', saves a screen shoot (as screenshoot.jpg in pwd)
-  'I', saves a screen shoot with the subpicture overlay intact
-
+.br
+The Audio- and SubtitleStreamChange actions use the number argument to switch directly to that stream, instead of cycling through the available streams.
+.br
 
 In addition to the above the arrow buttons and mouse can be used to move around in the DVD menues. Return, the keypad enter and left mouse button may be used to activate a DVD button.
 
diff -urN -x CVS -x .cvsignore ogle-0.9.2/doc/yuv2rgb.txt ogle/doc/yuv2rgb.txt
--- ogle-0.9.2/doc/yuv2rgb.txt	1970-01-01 01:00:00.000000000 +0100
+++ ogle/doc/yuv2rgb.txt	2001-03-19 21:38:24.000000000 +0100
@@ -0,0 +1,101 @@
+
+#1
+Ey is analogue  [0,1]
+Epb, Epr are analogue [-0.5,0.5]
+Y,Cr,Cb are quantized [0,255]
+
+#2
+Y  = (219*Ey) + 16;	// [16,235]  
+Cb = (224*Epb) + 128;	// [16,240]
+Cr = (224*Epr) + 128;	// [16,240]
+
+=>
+
+Ey  = (Y-16)/219;	// [-0.073, 1.091]
+Epb = (Cb-128)/224;	// [-0.571, 0.567]
+Epr = (Cr-128)/224;	// [-0.571, 0.567]
+
+
+#3
+Er,Eg,Eb is the analogue values in rgb format
+
+ITU-R 709
+=========
+Ey  = 0.7154*Eg + 0.0721*Eb + 0.2125*Er
+Epb = -0.386*Eg + 0.500*Eb  - 0.115*Er
+Epr = -0.454*Eg - 0.046*Eb  + 0.500*Er
+
+=>
+
+Eg  = 0.9998*Ey - 0.1872*Epb - 0.4680*Epr
+Eb  = 1.0019*Ey + 1.8556*Epb + 0.0010*Epr
+Er  = 1.0000*Ey + 0.0007*Epb + 1.5751*Epr
+
+~=
+
+Eg = Ey - 0.187*Epb - 0.468*Epr
+Eb = Ey + 1.856*Epb 
+Er = Ey + 1.575*Epr
+----------------------------------------
+
+
+FCC
+===
+
+
+Ey = 0.59*Eg + 0.11*Eb + 0.30*Er
+Epb = -0.331*Eg + 0.500*Eb -0.169*Er
+Epr = -0.421*Eg - 0.079*Eb + 0.500*Er
+
+=>
+
+Eg  = Ey - 0.3326*Epb - 0.7124*Epr
+Eb  = Ey + 1.7803*Epb + 0.0017*Epr
+Er  = Ey + 0.0012*Epb + 1.4004*Epr
+----------------------------------------
+
+
+ITU-R 624-4 System B, G
+=======================
+
+Ey = 0.587*Eg + 0.114*Eb + 0.299*Er
+Epb = -0.331*Eg + 0.500*Eb -0.169*Er
+Epr = -0.419*Eg - 0.081*Eb + 0.500*Er
+
+=>
+
+Eg  = Ey - 0.3437*Epb - 0.7142*Epr
+Eb  = Ey + 1.7722*Epb + 0.0009*Epr
+Er  = Ey - 0.0009*Epb + 1.4017*Epr
+----------------------------------------
+
+
+SMPTE 170M
+=======================
+
+Ey = 0.587*Eg + 0.114*Eb + 0.299*Er
+Epb = -0.331*Eg + 0.500*Eb -0.169*Er
+Epr = -0.419*Eg - 0.081*Eb + 0.500*Er
+
+=>
+
+Eg  = Ey - 0.3437*Epb - 0.7142*Epr
+Eb  = Ey + 1.7722*Epb + 0.0009*Epr
+Er  = Ey - 0.0009*Epb + 1.4017*Epr
+----------------------------------------
+
+
+SMPTE 240M(1987)
+=======================
+
+Ey = 0.701*Eg + 0.087*Eb + 0.212*Er
+Epb = -0.384*Eg + 0.500*Eb -0.116*Er
+Epr = -0.445*Eg - 0.055*Eb + 0.500*Er
+
+=>
+
+Eg  = Ey - 0.2264*Epb - 0.4765*Epr
+Eb  = Ey + 1.8260*Epb + 0.0003*Epr
+Er  = Ey - 0.0007*Epb + 1.5758*Epr
+
+
diff -urN -x CVS -x .cvsignore ogle-0.9.2/dvd_cli/Makefile.am ogle/dvd_cli/Makefile.am
--- ogle-0.9.2/dvd_cli/Makefile.am	2003-10-14 03:05:15.000000000 +0200
+++ ogle/dvd_cli/Makefile.am	2004-07-29 11:37:18.000000000 +0200
@@ -17,7 +17,7 @@
 
 pkglib_PROGRAMS = ogle_cli
 
-AM_CPPFLAGS = @TOP_INCLUDES@ @X_CFLAGS@ @XML_CFLAGS@
+AM_CPPFLAGS = @TOP_INCLUDES@ @X_CFLAGS@ @XML_CPPFLAGS@
 AM_CFLAGS = @O_CFLAGS@
 
 ogle_cli_SOURCES = main.c \
@@ -25,6 +25,6 @@
 	bindings.c bindings.h \
 	interpret_config.c interpret_config.h
 
-ogle_cli_LDADD = @X_PRE_LIBS@ @X_LIBS@ -lX11 @X_EXTRA_LIBS@ \
-	@XML_LIBS@ \
-	$(top_builddir)/ogle/libdvdcontrol.la
+ogle_cli_LDADD = $(top_builddir)/ogle/libdvdcontrol.la \
+	@X_PRE_LIBS@ @X_LIBS@ -lX11 @X_EXTRA_LIBS@ \
+	@XML_LIBS@
diff -urN -x CVS -x .cvsignore ogle-0.9.2/dvd_cli/bindings.c ogle/dvd_cli/bindings.c
--- ogle-0.9.2/dvd_cli/bindings.c	2003-09-19 09:47:38.000000000 +0200
+++ ogle/dvd_cli/bindings.c	2005-08-23 01:17:42.000000000 +0200
@@ -62,14 +62,11 @@
 void actionButtonActivate(void *data)
 {
   struct action_number *user = (struct action_number *)data;
-  if(user != NULL && user->valid && (user->nr >= 0)) {
+  if(user != NULL && (user->nr >= 0)) {
     DVDButtonSelectAndActivate(nav, user->nr);
   } else { 
     DVDButtonActivate(nav);
   }
-  if(user != NULL) {
-    user->valid = 0;
-  }
 }
 
 void actionMenuCallTitle(void *data)
@@ -137,21 +134,67 @@
   DVDResult_t res;
   int spu_nr;
   DVDStream_t spu_this;
-  DVDBool_t spu_shown;
+  DVDSubpictureState_t spu_state;
+  static DVDSubpictureState_t off_state = DVD_SUBPICTURE_STATE_OFF;
+
+  struct action_number *user = (struct action_number *)data;
 
-  res = DVDGetCurrentSubpicture(nav, &spu_nr, &spu_this, &spu_shown);
+  if(user && user->nr >= 0 && user->nr < 4) {
 
-  if(res != DVD_E_Ok) {
-    return;
+    switch(user->nr) {
+    case 0:
+      spu_state = DVD_SUBPICTURE_STATE_OFF;
+      off_state = spu_state;
+      break;
+    case 1:
+      spu_state = DVD_SUBPICTURE_STATE_ON;
+      break;
+    case 2:
+      spu_state = DVD_SUBPICTURE_STATE_FORCEDOFF;
+      off_state = spu_state;
+      break;
+    case 3:
+      spu_state = DVD_SUBPICTURE_STATE_DISABLED;
+      off_state = spu_state;
+      break;
+    default:
+      break;
+    }
+
+    DVDSetSubpictureState(nav, spu_state);
+
+  } else {
+    res = DVDGetCurrentSubpicture(nav, &spu_nr, &spu_this, &spu_state);
+    
+    if(res != DVD_E_Ok) {
+      return;
+    }
+    
+    if(spu_state != DVD_SUBPICTURE_STATE_ON) {
+      DVDSetSubpictureState(nav, DVD_SUBPICTURE_STATE_ON);
+    } else {
+      DVDSetSubpictureState(nav, off_state);
+    }
   }
+}
+
 
-  if(spu_shown == DVDTrue) {
-    DVDSetSubpictureState(nav, DVDFalse);
+void actionVideoToggle(void *data)
+{
+  DVDResult_t res;
+  static DVDVideoState_t video_state = DVD_VIDEO_STATE_ON;
+
+  if(video_state == DVD_VIDEO_STATE_ON) {
+    video_state = DVD_VIDEO_STATE_OFF;
   } else {
-    DVDSetSubpictureState(nav, DVDTrue);
+    video_state = DVD_VIDEO_STATE_ON;
   }
+
+  DVDSetVideoState(nav, video_state);
 }
 
+
+
 struct timeval pg_timestamp = {0, 0};
 
 void actionNextPG(void *data)
@@ -305,6 +348,11 @@
   DVDForwardScan(nav, speed);
 }
 
+void actionStop(void *data)
+{
+  DVDStop(nav);
+}
+
 
 void actionFastForward(void *data)
 {
@@ -313,7 +361,7 @@
     DVDPauseOff(nav);
   }
 
-  if((speed >= 1.0) && (speed < 8.0)) {
+  if((speed >= 1.0) && (speed < 32.0)) {
     speed +=0.5;
   } else if(speed < 1.0) {
     speed = 1.5;
@@ -344,7 +392,7 @@
     DVDPauseOff(nav);
   }
   
-  if((speed >= 1.0) && (speed < 8.0)) {
+  if((speed >= 1.0) && (speed < 32.0)) {
     speed += 0.5;
   } else if(speed < 1.0) {
     speed *= 2.0;
@@ -449,10 +497,9 @@
     NOTE("%s", "DVDBookmarkGetNr failed\n");
   } else if(n > 0) {
     if(user != NULL) {
-      if(user->valid && (user->nr < n) && (user->nr > 0)) {
+      if((user->nr < n) && (user->nr > 0)) {
 	n = user->nr;
       }
-      user->valid = 0;
     }
 
     if(DVDBookmarkRemove(bm, n-1) != -1) {
@@ -495,10 +542,9 @@
     NOTE("%s", "DVDBookmarkGetNr failed\n");
   } else if(n > 0) {
     if(user != NULL) {
-      if(user->valid && (user->nr < n) && (user->nr > 0)) {
+      if((user->nr < n) && (user->nr > 0)) {
 	n = user->nr;
       }
-      user->valid = 0;
     }
     if(DVDBookmarkGet(bm, n-1, &state, NULL, NULL, NULL) != -1) {
       if(state) {
@@ -575,6 +621,300 @@
 }
 
 
+static void printAudioAttributes(DVDAudioAttributes_t *attr)
+{
+  char *t_str;
+  switch(attr->AudioFormat) {
+  case DVD_AUDIO_FORMAT_AC3:
+    t_str = "AC-3";
+    break;
+  case DVD_AUDIO_FORMAT_MPEG1:    
+    t_str = "MPEG-1"; //MPEG-1 (or MPEG-2 without extension stream)
+    break;
+  case DVD_AUDIO_FORMAT_MPEG1_DRC:
+    t_str = "MPEG-1 DRC";
+    break;
+  case DVD_AUDIO_FORMAT_MPEG2:
+    t_str = "MPEG-2"; // MPEG-2 with extension stream
+    break;
+  case DVD_AUDIO_FORMAT_MPEG2_DRC:
+    t_str = "MPEG-2 DRC";
+    break;
+  case DVD_AUDIO_FORMAT_LPCM:
+    t_str = "LPCM";
+    break;
+  case DVD_AUDIO_FORMAT_DTS:
+    t_str = "DTS";
+    break;
+  case DVD_AUDIO_FORMAT_SDDS:
+    t_str = "SDDS";
+    break;
+  case DVD_AUDIO_FORMAT_Other:
+  default:
+    t_str = "Other";
+    break;
+  }
+  DNOTE("%s", t_str);
+  
+  if(attr->AudioFormat == DVD_AUDIO_FORMAT_LPCM) {
+    DNOTEC(" %d bits %d Hz", 
+	   attr->SampleQuantization,
+	   attr->SampleFrequency);
+  }
+  DNOTEC(" %dch", attr->NumberOfChannels);
+  
+  if(attr->AudioType == DVD_AUDIO_TYPE_Language) {
+    DNOTEC(" %c%c", attr->Language >> 8, attr->Language & 0xff);
+  }
+  
+  switch(attr->LanguageExtension) {
+  case DVD_AUDIO_LANG_EXT_NotSpecified:
+    t_str = "";
+    break;
+  case DVD_AUDIO_LANG_EXT_NormalCaptions:
+    t_str = "Normal Captions";
+    break;
+  case DVD_AUDIO_LANG_EXT_VisuallyImpaired:
+    t_str = "Captions for visually impaired";
+    break;
+  case DVD_AUDIO_LANG_EXT_DirectorsComments1:
+    t_str = "Director's comments 1";
+    break;
+  case DVD_AUDIO_LANG_EXT_DirectorsComments2:
+    t_str = "Director's comments 2";
+    break;
+  }
+  DNOTEC(" %s", t_str);
+  
+  switch(attr->AppMode) {
+  case DVD_AUDIO_APP_MODE_None:
+    t_str = "";
+    break;
+  case DVD_AUDIO_APP_MODE_Karaoke:
+    t_str = "Karaoke Mode";
+    break;
+  case DVD_AUDIO_APP_MODE_Surround:
+    t_str = "Surround Mode";
+    break;
+  case DVD_AUDIO_APP_MODE_Other:
+    t_str = "Other Mode";
+    break;
+  }
+  DNOTEC(" %s\n", t_str);
+}
+
+
+void actionAudioStreamChange(void *data)
+{
+  int res;
+  int streams_avail;
+  DVDAudioStream_t cur_stream;
+  DVDAudioStream_t new_stream;
+  DVDAudioAttributes_t au_attr;
+  DVDBool_t enabled;
+  int next_track = 0;
+  
+  struct action_number *user = (struct action_number *)data;
+  
+  res = DVDGetCurrentAudio(nav, &streams_avail, &cur_stream);
+  if(res == DVD_E_Ok) {
+    if(streams_avail > 0) {
+      if(user != NULL && user->nr >= 0 && user->nr < streams_avail) {
+	new_stream = user->nr;
+      } else {
+	new_stream = cur_stream+1;
+	next_track = 8;
+      }
+
+      do {
+	if(new_stream >= streams_avail) {
+	  new_stream = 0;
+	}
+	res = DVDIsAudioStreamEnabled(nav, new_stream, &enabled);
+	if(res == DVD_E_Ok) {
+	  if(enabled) {
+	    break;
+	  }
+	  new_stream++;
+	}
+	next_track--;
+      } while(next_track > 0);
+      
+      if(enabled) {
+	res = DVDAudioStreamChange(nav, new_stream);
+	if(res != DVD_E_Ok) {
+	  DVDPerror("DVDAudioStreamChange: ", res);
+	}
+	DNOTE("get audioattr snr %d\n", new_stream);
+	res = DVDGetAudioAttributes(nav, new_stream, &au_attr);
+	if(res != DVD_E_Ok) {
+	  ERROR("DVDGetAudioAttributes: %s\n", DVDStrerror(res));
+	} else {
+	  printAudioAttributes(&au_attr);
+	}
+      } else {
+	if(next_track == -1) {
+	  DNOTE("Audio stream %d not enabled\n", new_stream-1);
+	} else {
+	  DNOTE("%s", "No enabled audio streams\n");
+	}
+      }
+    }
+  } else {
+    DVDPerror("DVDGetCurrentAudio: ", res);
+  }
+}
+
+
+static void printSubpictureAttributes(DVDSubpictureAttributes_t *attr)
+{
+  char *t_str;
+  switch(attr->Type) {
+  case   DVD_SUBPICTURE_TYPE_NotSpecified:
+    t_str = "Not Specified";
+    break;
+  case   DVD_SUBPICTURE_TYPE_Language:
+    t_str = "Language";
+    break;
+  case   DVD_SUBPICTURE_TYPE_Other:
+    t_str = "Other";
+    break;
+  }
+  DNOTE("sp_attr: type: %s", t_str);
+  
+  switch(attr->CodingMode) {
+  case DVD_SUBPICTURE_CODING_RunLength:
+    t_str = "RLE";
+    break;
+  case DVD_SUBPICTURE_CODING_Extended:
+    t_str = "Extended";
+    break;
+  case DVD_SUBPICTURE_CODING_Other:
+    t_str = "Other";
+    break;
+  }	
+  DNOTEC(" codemode: %s", t_str);
+  
+  if(attr->Type == DVD_SUBPICTURE_TYPE_Language) {
+    DNOTEC(" lang: %c%c", 
+	   attr->Language >> 8,
+	   attr->Language & 0xff);
+    
+    switch(attr->LanguageExtension) {
+    case DVD_SUBPICTURE_LANG_EXT_NotSpecified:
+      t_str = "Not Specified";
+      break;
+    case DVD_SUBPICTURE_LANG_EXT_NormalCaptions:
+      t_str = "Normal Captions";
+      break;
+    case DVD_SUBPICTURE_LANG_EXT_BigCaptions:
+      t_str = "Big Captions";
+      break;
+    case DVD_SUBPICTURE_LANG_EXT_ChildrensCaptions:
+      t_str = "Childrend Captions";
+      break;
+    case DVD_SUBPICTURE_LANG_EXT_NormalCC:
+      t_str = "Normal CC";
+      break;
+    case DVD_SUBPICTURE_LANG_EXT_BigCC:
+      t_str = "Big CC";
+      break;
+    case DVD_SUBPICTURE_LANG_EXT_ChildrensCC:
+      t_str = "Childrens CC";
+      break;
+    case DVD_SUBPICTURE_LANG_EXT_Forced:
+      t_str = "Forced";
+      break;
+    case DVD_SUBPICTURE_LANG_EXT_NormalDirectorsComments:
+      t_str = "Normal Directors Comments";
+      break;
+    case DVD_SUBPICTURE_LANG_EXT_BigDirectorsComments:
+      t_str = "Big Directors Comments";
+      break;
+    case DVD_SUBPICTURE_LANG_EXT_ChildrensDirectorsComments:
+      t_str = "Childrens Directors Comments";
+      break;
+    }	    
+    DNOTEC(" lang_ext: %s", t_str);
+  }
+  DNOTEC("%s", "\n");
+}
+
+
+void actionSubtitleStreamChange(void *data)
+{
+  int res;
+  int streams_avail;
+  DVDSubpictureStream_t cur_stream;
+  DVDSubpictureStream_t new_stream;
+  DVDSubpictureState_t spu_state;
+  DVDSubpictureAttributes_t sp_attr;
+
+  struct action_number *user = (struct action_number *)data;
+  
+  
+  
+  res = DVDGetCurrentSubpicture(nav, &streams_avail,
+				&cur_stream, &spu_state);
+  if(res == DVD_E_Ok) {
+    if(streams_avail > 0) {
+      if(spu_state == DVD_SUBPICTURE_STATE_ON) {
+	if(user != NULL && user->nr >=0 && user->nr < streams_avail) {
+	  new_stream = user->nr;
+	} else {
+	  new_stream = cur_stream+1;
+	}
+	
+	if(new_stream >= streams_avail) {
+	  new_stream = 0;
+	  // if we are at the last stream, turn off subtitles
+	  res = DVDSetSubpictureState(nav, DVD_SUBPICTURE_STATE_OFF);
+	  if(res != DVD_E_Ok) {
+	    DVDPerror("DVDSetSubpictureState: ", res);
+	  }
+	}
+	res = DVDSubpictureStreamChange(nav, new_stream);
+	if(res != DVD_E_Ok) {
+	  DVDPerror("DVDSubpictureStreamChange: ", res);
+	}
+
+      } else {
+	// if subtitles are off, turn them on and
+	// change stream if requested
+	if(user != NULL && user->nr >=0 && user->nr < streams_avail) {
+	  new_stream = user->nr;
+	  res = DVDSubpictureStreamChange(nav, new_stream);
+	  if(res != DVD_E_Ok) {
+	    DVDPerror("DVDSubpictureStreamChange: ", res);
+	  }
+	} else {
+	  new_stream = cur_stream;
+	}
+
+	res = DVDSetSubpictureState(nav, DVD_SUBPICTURE_STATE_ON);
+	if(res != DVD_E_Ok) {
+	  DVDPerror("DVDSetSubpictureState: ", res);
+	}
+      }
+      DNOTE("get subpattr snr %d\n", new_stream);
+      res = DVDGetSubpictureAttributes(nav, new_stream, &sp_attr);
+      if(res != DVD_E_Ok) {
+	ERROR("DVDGetSubpictureAttributes: %s\n", DVDStrerror(res));
+	//DVDPerror("DVDGetSubpictureAttributes: ", res);
+      } else {
+	printSubpictureAttributes(&sp_attr);
+      }
+    }   
+  } else {
+    DVDPerror("DVDGetCurrentSubpicture: ", res);
+  }
+
+  
+}
+
+/* Calls vfun() with the data parameter set to a pointer
+ *  to the user number if valid, otherwise the data parameter is NULL
+ */
 void do_number_action(void *vfun)
 {
   void (*number_action)(void *) = vfun;
@@ -619,6 +959,7 @@
   KeySym keysym;
   void (*fun)(void *);
   void *arg;
+  unsigned int modifiers;
 } ks_map_t;
 
 static unsigned int ks_maps_index = 0;
@@ -637,7 +978,7 @@
 static action_mapping_t actions[] = {
   { "Play", do_action, actionPlay },
   { "PauseToggle", do_action, actionPauseToggle },
-  { "Stop", NULL, NULL },
+  { "Stop", do_action, actionStop },
   { "FastForward", do_action, actionFastForward },
   { "SlowForward", do_action, actionSlowForward },
   { "Faster", do_action, actionFaster },
@@ -657,7 +998,8 @@
   { "SubtitleMenu", do_action, actionMenuCallSubpicture },
   { "Resume", do_action, actionResume },
   { "FullScreenToggle", do_action, actionFullScreenToggle },
-  { "SubtitleToggle", do_action, actionSubpictureToggle },
+  { "SubtitleToggle", do_number_action, actionSubpictureToggle },
+  { "VideoToggle", do_number_action, actionVideoToggle },
   { "Quit", do_action, actionQuit },
   { "BookmarkAdd", do_action, actionBookmarkAdd },
   { "BookmarkRemove", do_number_action, actionBookmarkRemove },
@@ -676,6 +1018,8 @@
   { "SkipBackward", do_number_action, actionSkipBackward },
   { "SaveScreenshot", do_action, actionSaveScreenshot },
   { "SaveScreenshotWithSPU", do_action, actionSaveScreenshotWithSPU },
+  { "AudioStreamChange", do_number_action, actionAudioStreamChange },
+  { "SubtitleStreamChange", do_number_action, actionSubtitleStreamChange },
   { NULL, NULL }
 };
 
@@ -698,12 +1042,30 @@
 }
 
 
-void do_keysym_action(KeySym keysym)
+void do_keysym_action(KeySym keysym, KeySym keysym_base,
+		      unsigned int keycode, unsigned int modifiers)
 {
   int n;
+  unsigned int dont_care_mods = LockMask | Mod2Mask; //get_dont_care_mods();
+
+  modifiers &= (ShiftMask | LockMask | ControlMask |
+    Mod1Mask | Mod2Mask | Mod3Mask | Mod4Mask | Mod5Mask);
 
+  //check bindings with modifiers first
   for(n = 0; n < ks_maps_index; n++) {
-    if(ks_maps[n].keysym == keysym) {
+    if(ks_maps[n].modifiers && (ks_maps[n].keysym == keysym_base)) {
+      if((ks_maps[n].modifiers == modifiers) || 
+	 (ks_maps[n].modifiers == (modifiers & ~dont_care_mods))) {
+	if(ks_maps[n].fun != NULL) {
+	  ks_maps[n].fun(ks_maps[n].arg);
+	}
+	return;
+      }
+    }
+  }
+  //then without modifiers
+  for(n = 0; n < ks_maps_index; n++) {
+    if((!ks_maps[n].modifiers) && (ks_maps[n].keysym == keysym)) {
       if(ks_maps[n].fun != NULL) {
 	ks_maps[n].fun(ks_maps[n].arg);
       }
@@ -714,13 +1076,15 @@
 }
 
 
-void remove_keysym_binding(KeySym keysym)
+void remove_keysym_binding(KeySym keysym, unsigned int modifiers)
 {
   int n;
   
   for(n = 0; n < ks_maps_index; n++) {
-    if(ks_maps[n].keysym == keysym) {
+    if((ks_maps[n].keysym == keysym) &&
+       (ks_maps[n].modifiers == modifiers)) {
       ks_maps[n].keysym = NoSymbol;
+      ks_maps[n].modifiers = 0;
       ks_maps[n].fun = NULL;
       ks_maps[n].arg = NULL;
       return;
@@ -728,12 +1092,14 @@
   }
 }
 
-void add_keysym_binding(KeySym keysym, void(*fun)(void *), void *arg)
+void add_keysym_binding(KeySym keysym, unsigned int modifiers, 
+			void(*fun)(void *), void *arg)
 {
   int n;
   
   for(n = 0; n < ks_maps_index; n++) {
-    if(ks_maps[n].keysym == keysym) {
+    if((ks_maps[n].keysym == keysym) &&
+       (ks_maps[n].modifiers == modifiers)) {
       ks_maps[n].fun = fun;
       ks_maps[n].arg = arg;
       return;
@@ -746,6 +1112,7 @@
   }
   
   ks_maps[ks_maps_index].keysym = keysym;
+  ks_maps[ks_maps_index].modifiers = modifiers;
   ks_maps[ks_maps_index].fun = fun;
   ks_maps[ks_maps_index].arg = arg;
   
@@ -755,10 +1122,11 @@
   return;
 }
   
-void add_keybinding(char *key, char *action)
+void add_keybinding(char *key, char **modifier_array, char *action)
 {
   KeySym keysym;
   int n = 0;
+  unsigned int modifiers = 0;
   
   keysym = XStringToKeysym(key);
   
@@ -767,15 +1135,41 @@
     return;
   }
   
+  if(modifier_array) {
+    char **m;
+    for(m = modifier_array; *m != NULL; m++) {
+      if(!strcasecmp(*m, "Shift")) {
+	modifiers |= ShiftMask;
+      } else if(!strcasecmp(*m, "Lock")) {
+	modifiers |= LockMask;
+      } else if(!strcasecmp(*m, "Control")) {
+	modifiers |= ControlMask;
+      } else if(!strcasecmp(*m, "Mod1")) {
+	modifiers |= Mod1Mask;
+      } else if(!strcasecmp(*m, "Mod2")) {
+	modifiers |= Mod2Mask;
+      } else if(!strcasecmp(*m, "Mod3")) {
+	modifiers |= Mod3Mask;
+      } else if(!strcasecmp(*m, "Mod4")) {
+	modifiers |= Mod4Mask;
+      } else if(!strcasecmp(*m, "Mod5")) {
+	modifiers |= Mod5Mask;
+      } else {
+	WARNING("add_keybinding(): No such modifier: '%s'\n", *m);
+      }
+      
+    }
+  }
+
   if(!strcmp("NoAction", action)) {
-    remove_keysym_binding(keysym);
+    remove_keysym_binding(keysym, modifiers);
     return;
   }
     
   for(n = 0; actions[n].str != NULL; n++) {
     if(!strcmp(actions[n].str, action)) {
       if(actions[n].fun != NULL) {
-	add_keysym_binding(keysym, actions[n].fun, actions[n].ptr);
+	add_keysym_binding(keysym, modifiers, actions[n].fun, actions[n].ptr);
       }
       return;
     }
diff -urN -x CVS -x .cvsignore ogle-0.9.2/dvd_cli/bindings.h ogle/dvd_cli/bindings.h
--- ogle-0.9.2/dvd_cli/bindings.h	2001-11-24 01:15:57.000000000 +0100
+++ ogle/dvd_cli/bindings.h	2005-08-20 16:36:39.000000000 +0200
@@ -16,7 +16,8 @@
   unsigned int modifier_mask; 
 } pointer_event_t;
 
-void do_keysym_action(KeySym keysym);
-void add_keybinding(char *key, char *action);
+void do_keysym_action(KeySym keysym, KeySym keysym_base,
+		      unsigned int keycode, unsigned int modifiers);
+void add_keybinding(char *key, char **modifier_array, char *action);
 
 #endif /* BINDINGS_H */
diff -urN -x CVS -x .cvsignore ogle-0.9.2/dvd_cli/interpret_config.c ogle/dvd_cli/interpret_config.c
--- ogle-0.9.2/dvd_cli/interpret_config.c	2003-08-06 20:06:34.000000000 +0200
+++ ogle/dvd_cli/interpret_config.c	2005-08-20 16:36:39.000000000 +0200
@@ -24,6 +24,69 @@
 extern int skip_seconds;
 extern int prevpg_timeout;
 
+
+static void interpret_key(xmlDocPtr doc, xmlNodePtr cur, char *action)
+{
+  char *keysym = NULL;
+  char **modifiers = NULL;
+  int nr_modifiers = 0;
+
+  cur = cur->xmlChildrenNode;
+  
+  while(cur != NULL) {
+
+    if(!xmlIsBlankNode(cur)) {
+
+      if(!strcmp("keysym", cur->name)) {
+	if(keysym != NULL) {
+	  ERROR("%s", "interpret_key(): more than one <keysym>\n");
+	  break;
+	}
+	keysym = xmlNodeListGetString(doc, cur->xmlChildrenNode, 1);
+	if(keysym == NULL) {
+	  ERROR("%s", "interpret_key(): <keysym> empty\n");
+	} else {
+	  //fprintf(stderr, "action: %s\n", action);
+	}
+      } else if(!strcmp("modifier", cur->name)) {
+	char *m;
+	
+	if(keysym == NULL) {
+	  ERROR("%s", "interpret_key(): no <keysym>\n");
+	  break;
+	}
+	m = xmlNodeListGetString(doc, cur->xmlChildrenNode, 1);
+	if(m == NULL) {
+	  WARNING("%s", "interpret_key(): <modifier> empty\n");
+	} else {
+	  char **ma;
+	  nr_modifiers++;
+	  ma = realloc(modifiers, sizeof(char *) * (nr_modifiers+1));
+	  if(ma == NULL) {
+	    ERROR("%s", "interpret_key(): realloc failed\n");
+	    nr_modifiers--;
+	  } else {
+	    modifiers = ma;
+	    modifiers[nr_modifiers-1] = m;
+	    modifiers[nr_modifiers] = NULL;
+	  }
+	}
+      }
+    }
+    cur = cur->next;
+  }
+  
+  if(keysym) {
+    add_keybinding(keysym, modifiers, action);
+    //fprintf(stderr, "keysym: %s\n", keysym);	
+    if(modifiers) {
+      free(modifiers);
+    }
+    free(keysym);
+  }
+  
+}
+
 static void interpret_b(xmlDocPtr doc, xmlNodePtr cur)
 {
   char *action = NULL;
@@ -50,13 +113,20 @@
 	  ERROR("%s", "interpret_b(): no <action>\n");
 	  break;
 	}
-	key = xmlNodeListGetString(doc, cur->xmlChildrenNode, 1);
-	if(key == NULL) {
-	  WARNING("%s", "interpret_b(): <key> empty\n");
+	
+	if(!strcmp("text", cur->xmlChildrenNode->name) &&
+	   !xmlIsBlankNode(cur->xmlChildrenNode)) {
+	  key = xmlNodeListGetString(doc, cur->xmlChildrenNode, 1);
+	  
+	  if(key == NULL) {
+	    WARNING("%s", "interpret_b(): <key> empty\n");
+	  } else {
+	    add_keybinding(key, NULL, action);
+	    //fprintf(stderr, "key: %s\n", key);	
+	    free(key);
+	  }
 	} else {
-	  add_keybinding(key, action);
-	  //fprintf(stderr, "key: %s\n", key);	
-	  free(key);
+	  interpret_key(doc, cur, action);
 	}
       }
     }
@@ -264,6 +334,7 @@
   int config_read = 0;
   char *home;
 
+  LIBXML_TEST_VERSION
 
   if(interpret_oglerc(CONFIG_FILE) != -1) {
     config_read |= 1;
diff -urN -x CVS -x .cvsignore ogle-0.9.2/dvd_cli/main.c ogle/dvd_cli/main.c
--- ogle-0.9.2/dvd_cli/main.c	2003-02-15 22:58:14.000000000 +0100
+++ ogle/dvd_cli/main.c	2004-08-05 15:35:29.000000000 +0200
@@ -42,7 +42,6 @@
 int bookmarks_autosave = 0;
 int bookmarks_autoload = 0;
 
-int msgqid;
 extern int win;
 
 char *program_name;
@@ -107,9 +106,10 @@
 int main (int argc, char *argv[])
 {
   DVDResult_t res;
-
   int c;
-  
+  char *msgq_str;
+  int msgq_set = 0;
+
   program_name = argv[0];
   GET_DLEVEL();
 
@@ -117,7 +117,8 @@
   while ((c = getopt(argc, argv, "m:h?")) != EOF) {
     switch (c) {
     case 'm':
-      msgqid = atoi(optarg);
+      msgq_str = optarg;
+      msgq_set = 1;
       break;
     case 'h':
     case '?':
@@ -131,15 +132,19 @@
     exit(1);
   }
   
-  
-  if(msgqid !=-1) { // ignore sending data.
-    sleep(1);
-    res = DVDOpenNav(&nav, msgqid);
-    if(res != DVD_E_Ok ) {
-      DVDPerror("DVDOpen:", res);
-      exit(1);
-    }
+  if(!msgq_set) {
+    usage();
+    exit(1);
+
+  }
+
+  sleep(1);
+  res = DVDOpenNav(&nav, msgq_str);
+  if(res != DVD_E_Ok ) {
+    DVDPerror("DVDOpen:", res);
+    exit(1);
   }
+  
 
   interpret_config();
 
diff -urN -x CVS -x .cvsignore ogle-0.9.2/dvd_cli/xsniffer.c ogle/dvd_cli/xsniffer.c
--- ogle-0.9.2/dvd_cli/xsniffer.c	2002-06-09 20:51:01.000000000 +0200
+++ ogle/dvd_cli/xsniffer.c	2005-08-20 16:36:39.000000000 +0200
@@ -1,5 +1,5 @@
 /* Ogle - A video player
- * Copyright (C) 2000, 2001 Vilhelm Bergman
+ * Copyright (C) 2000, 2001, 2005 Vilhelm Bergman, BjÃ¶rn Englund
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -25,7 +25,6 @@
 #include <X11/keysym.h>
 
 #include <ogle/dvdcontrol.h>
-#include <ogle/msgevents.h>
 
 #include "xsniffer.h"
 #include "bindings.h"
@@ -35,25 +34,25 @@
 
 
 void* xsniff_mouse(void* args) {
-  MsgEvent_t mev;
+  DVDEvent_t ev;
 
   while(1) {
     
-    if(DVDNextEvent(nav, &mev) != DVD_E_Ok)
-      exit(1);
-    
-    switch(mev.type) {
+    if(DVDNextEvent(nav, &ev) != DVD_E_Ok)
+      continue;
     
+    switch(ev.type) {
+      
       
       //case MotionNotify:
-    case MsgEventQInputPointerMotion:
+    case DVDEventInputPointerMotion:
       
       {
 	DVDResult_t res;
 	int x, y;
 	
-	x = mev.input.x;
-	y = mev.input.y;
+	x = ev.input.x;
+	y = ev.input.y;
 	
 	res = DVDMouseSelect(nav, x, y);
 	
@@ -74,15 +73,15 @@
       }
       */
       break;
-    case MsgEventQInputButtonPress:
-      switch(mev.input.input) {
+    case DVDEventInputButtonPress:
+      switch(ev.input.input) {
       case 0x1:
 	{ 
 	  DVDResult_t res;
 	  int x, y;
 
-	  x = mev.input.x;
-	  y = mev.input.y;
+	  x = ev.input.x;
+	  y = ev.input.y;
 	  
 	  res = DVDMouseActivate(nav, x, y);
 	  if(res != DVD_E_Ok) {
@@ -96,16 +95,17 @@
 	break;
       }
       break;
-    case MsgEventQInputKeyPress:
+    case DVDEventInputKeyPress:
       {
 	KeySym keysym;
-	keysym = mev.input.input;
+	keysym = ev.input.input;
 	/*
 	fprintf(stderr, "keysym: %ld, modifier: %ld\n",
 		mev.input.input,
 		mev.input.mod_mask);
 	*/
-	do_keysym_action(keysym);
+	do_keysym_action(keysym, ev.input.input_base,
+			 ev.input.input_keycode, ev.input.mod_mask);
       }
       break;
     default:
diff -urN -x CVS -x .cvsignore ogle-0.9.2/extras/msgqdump.c ogle/extras/msgqdump.c
--- ogle-0.9.2/extras/msgqdump.c	1970-01-01 01:00:00.000000000 +0100
+++ ogle/extras/msgqdump.c	2001-08-05 21:34:30.000000000 +0200
@@ -0,0 +1,72 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/msg.h>
+
+#include "../ogle/msgevents.h"
+
+
+
+
+void process_msgid(int msqid)
+{
+  size_t bufsize;
+  struct msgsnap_head *buf;
+  struct msgsnap_mhead *mhead;
+  int i;
+
+  /* allocate a minimum-size buffer */
+  buf = malloc(bufsize = sizeof(struct msgsnap_head));
+
+  /* read all of the messages from the queue */
+  for (;;) {
+    if (msgsnap(msqid, buf, bufsize, 0) != 0) {
+
+	perror("msgsnap");
+      free(buf);
+      return;
+    }
+    if (bufsize >= buf->msgsnap_size)  /* we got them all */
+      break;
+    /* we need a bigger buffer */
+    buf = realloc(buf, bufsize = buf->msgsnap_size);
+  }
+
+  fprintf(stderr, "bufsize: %d\n", buf->msgsnap_size);
+
+  /* process each message in the queue (there may be none) */
+  mhead = (struct msgsnap_mhead *)(buf + 1);  /* first message */
+  for (i = 0; i < buf->msgsnap_nmsg; i++) {
+    MsgEvent_t ev;
+    msg_t *msg;
+    size_t mlen = mhead->msgsnap_mlen;
+
+    /* process the message contents */
+    //process_message(mhead->msgsnap_mtype, (char *)(mhead+1), mlen);
+    fprintf(stderr, "type: %d, size: %d\n",
+	    mhead->msgsnap_mtype, mlen);
+    
+    memcpy(&ev, mhead+1, mhead->msgsnap_mlen);
+    
+    fprintf(stderr, "type: %d, from: %d, to: %d\n",
+	    ev.type, ev.any.client, mhead->msgsnap_mtype);
+    
+    /* advance to the next message header */
+    mhead = (struct msgsnap_mhead *)
+      ((char *)mhead + sizeof(struct msgsnap_mhead) +
+       ((mlen + sizeof(size_t) - 1) & ~(sizeof(size_t) - 1)));
+  }
+
+  free(buf);
+}
+
+
+
+
+int main(int argc, char **argv)
+{
+  
+
+  process_msgid(atoi(argv[1]));
+
+  return 0;
+}
diff -urN -x CVS -x .cvsignore ogle-0.9.2/extras/timing.c ogle/extras/timing.c
--- ogle-0.9.2/extras/timing.c	1970-01-01 01:00:00.000000000 +0100
+++ ogle/extras/timing.c	2001-08-05 21:34:30.000000000 +0200
@@ -0,0 +1,144 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#include <time.h>
+
+
+int main()
+{
+  struct timespec t1, t2, t3, t4, t5, res, res_1_2, res2, zero;
+
+  zero.tv_sec = 0;
+  zero.tv_nsec = 0;
+
+  clock_getres(CLOCK_REALTIME, &res);
+  fprintf(stderr, "res: %ld.%09ld\n",
+	  t1.tv_sec, t1.tv_nsec);
+  res_1_2.tv_sec = 0;
+  res_1_2.tv_nsec = res.tv_nsec/2;
+
+  res2.tv_sec = 0;
+  res2.tv_nsec = res.tv_nsec*2-res.tv_nsec/2;
+
+  
+  
+  clock_gettime(CLOCK_REALTIME, &t1);
+  clock_gettime(CLOCK_REALTIME, &t2);
+  clock_gettime(CLOCK_REALTIME, &t3);
+  clock_gettime(CLOCK_REALTIME, &t4);
+  clock_gettime(CLOCK_REALTIME, &t5);
+  
+  
+  fprintf(stderr, "t1: %ld.%09ld\n",
+	  t1.tv_sec, t1.tv_nsec);	  
+  fprintf(stderr, "t2: %ld.%09ld\n",
+	  t2.tv_sec, t2.tv_nsec);	  
+  fprintf(stderr, "t3: %ld.%09ld\n",
+	  t3.tv_sec, t3.tv_nsec);	  
+  fprintf(stderr, "t4: %ld.%09ld\n",
+	  t4.tv_sec, t4.tv_nsec);	  
+  fprintf(stderr, "t5: %ld.%09ld\n",
+	  t5.tv_sec, t5.tv_nsec);	  
+
+
+  clock_gettime(CLOCK_REALTIME, &t1);
+  nanosleep(&zero, NULL);
+  clock_gettime(CLOCK_REALTIME, &t3);
+  
+  
+  fprintf(stderr, "t1: %ld.%09ld\n",
+	  t1.tv_sec, t1.tv_nsec);	  
+  fprintf(stderr, "zero: %ld.%09ld\n",
+	  zero.tv_sec, zero.tv_nsec);	  
+  fprintf(stderr, "t3: %ld.%09ld\n",
+	  t3.tv_sec, t3.tv_nsec);	  
+
+
+  clock_gettime(CLOCK_REALTIME, &t1);
+  nanosleep(&res_1_2, NULL);
+  clock_gettime(CLOCK_REALTIME, &t3);
+  
+  
+  fprintf(stderr, "t1: %ld.%09ld\n",
+	  t1.tv_sec, t1.tv_nsec);	  
+  fprintf(stderr, "res_1_2: %ld.%09ld\n",
+	  res_1_2.tv_sec, res_1_2.tv_nsec);	  
+  fprintf(stderr, "t3: %ld.%09ld\n",
+	  t3.tv_sec, t3.tv_nsec);	  
+
+
+  clock_gettime(CLOCK_REALTIME, &t1);
+  nanosleep(&res, NULL);
+  clock_gettime(CLOCK_REALTIME, &t3);
+  
+  
+  fprintf(stderr, "t1: %ld.%09ld\n",
+	  t1.tv_sec, t1.tv_nsec);	  
+  fprintf(stderr, "res: %ld.%09ld\n",
+	  res.tv_sec, res.tv_nsec);	  
+  fprintf(stderr, "t3: %ld.%09ld\n",
+	  t3.tv_sec, t3.tv_nsec);	  
+
+  clock_gettime(CLOCK_REALTIME, &t1);
+  nanosleep(&res2, NULL);
+  clock_gettime(CLOCK_REALTIME, &t3);
+  
+  
+  fprintf(stderr, "t1: %ld.%09ld\n",
+	  t1.tv_sec, t1.tv_nsec);	  
+  fprintf(stderr, "res2: %ld.%09ld\n",
+	  res2.tv_sec, res2.tv_nsec);	  
+  fprintf(stderr, "t3: %ld.%09ld\n",
+	  t3.tv_sec, t3.tv_nsec);	  
+
+
+  res2.tv_nsec = 3000000;
+  clock_gettime(CLOCK_REALTIME, &t1);
+  nanosleep(&res2, NULL);
+  clock_gettime(CLOCK_REALTIME, &t3);
+  
+  
+  fprintf(stderr, "t1: %ld.%09ld\n",
+	  t1.tv_sec, t1.tv_nsec);	  
+  fprintf(stderr, "3ms: %ld.%09ld\n",
+	  res2.tv_sec, res2.tv_nsec);	  
+  fprintf(stderr, "t3: %ld.%09ld\n",
+	  t3.tv_sec, t3.tv_nsec);	  
+
+
+
+
+  res2.tv_nsec = 7000000;
+  clock_gettime(CLOCK_REALTIME, &t1);
+  nanosleep(&res2, NULL);
+  clock_gettime(CLOCK_REALTIME, &t3);
+  
+  
+  fprintf(stderr, "t1: %ld.%09ld\n",
+	  t1.tv_sec, t1.tv_nsec);	  
+  fprintf(stderr, "7ms: %ld.%09ld\n",
+	  res2.tv_sec, res2.tv_nsec);	  
+  fprintf(stderr, "t3: %ld.%09ld\n",
+	  t3.tv_sec, t3.tv_nsec);	  
+
+
+  
+  
+}
+
+
+/*
+  timing on ultrasparc60 solaris
+  
+
+  res = 0.01
+  clock_gettime ~ 0.000000250, < 0.000001
+  
+  nanosleep(0)      .000019941
+  nanosleep(res/2)  .013630529
+  nanosleep(res)    .019684518
+  nanosleep(res*2)  .029692460
+
+
+ */
diff -urN -x CVS -x .cvsignore ogle-0.9.2/include/Makefile.am ogle/include/Makefile.am
--- ogle-0.9.2/include/Makefile.am	2001-09-16 22:52:30.000000000 +0200
+++ ogle/include/Makefile.am	2004-07-29 11:39:52.000000000 +0200
@@ -1,6 +1,6 @@
 EXTRA_DIST = \
 	common.h mpeg.h ogle_endian.h \
 	queue.h sync.h timemath.h \
-	debug_print.h
-
+	debug_print.h \
+	shm.h
 	    	
diff -urN -x CVS -x .cvsignore ogle-0.9.2/include/queue.h ogle/include/queue.h
--- ogle-0.9.2/include/queue.h	2003-02-23 19:01:47.000000000 +0100
+++ ogle/include/queue.h	2006-01-25 17:54:11.000000000 +0100
@@ -44,6 +44,7 @@
   int flowcmd;
   PacketType_t packet_type;
   uint32_t packet_offset;
+  int32_t serial;
 } data_elem_t;
 
 
@@ -80,6 +81,7 @@
   int picture_len;
   long int frame_interval;
   char *q_addr;
+  int32_t serial;
 } picture_data_elem_t;
 
 
diff -urN -x CVS -x .cvsignore ogle-0.9.2/include/shm.h ogle/include/shm.h
--- ogle-0.9.2/include/shm.h	1970-01-01 01:00:00.000000000 +0100
+++ ogle/include/shm.h	2004-07-30 17:08:34.000000000 +0200
@@ -0,0 +1,29 @@
+#ifndef OGLE_SHM_H
+#define OGLE_SHM_H
+
+#ifdef HAVE_POSIX_SHM
+
+int ogle_shmget(int size, int mode);
+int ogle_shmrm(int shmid);
+void *ogle_shmat(int shmid);
+int ogle_shmdt(void *shmaddr);
+
+#else
+
+#define ogle_shmget(size, mode) ogle_sysv_shmget((size), (mode))
+#define ogle_shmat(shmid) ogle_sysv_shmat((shmid))
+#define ogle_shmdt(shmaddr) ogle_sysv_shmdt((shmaddr))
+#define ogle_shmrm(shmid) ogle_sysv_shmrm((shmid))
+
+#endif //HAVE_POSIX_SHM
+
+int ogle_shm_init(void);
+
+int ogle_sysv_shmget(size_t size, int mode);
+void *ogle_sysv_shmat(int shmid);
+int ogle_sysv_shmdt(void *shmaddr);
+int ogle_sysv_shmrm(int shmid);
+
+int ogle_shmrm_all(void);
+
+#endif //OGLE_SHM_H
diff -urN -x CVS -x .cvsignore ogle-0.9.2/libogleao/alsa_audio.c ogle/libogleao/alsa_audio.c
--- ogle-0.9.2/libogleao/alsa_audio.c	2003-10-19 02:38:30.000000000 +0200
+++ ogle/libogleao/alsa_audio.c	2005-06-07 17:15:01.000000000 +0200
@@ -250,8 +250,8 @@
     
     snd_ctl_close(ctl_handle);
   
-  __diga_end:
   }
+  __diga_end:
   
   return 0;
 }
@@ -269,16 +269,51 @@
 	
   
   if(i->initialized) {
+    snd_pcm_state_t state;
+    char *name;
+
     DNOTE("%s", "alsa reinit\n");
    
     if((err = snd_pcm_drain(i->alsa_pcm)) < 0) {
       ERROR("drain failed: %s\n", snd_strerror(err));
+      state = snd_pcm_state(i->alsa_pcm);
+      ERROR("alsa state: %d\n", state);
     }
-    
+
     if((err = snd_pcm_prepare(i->alsa_pcm)) < 0) {
       ERROR("prepare failed: %s\n",
 	    snd_strerror(err));
-    }    
+      state = snd_pcm_state(i->alsa_pcm);
+      ERROR("alsa state: %d\n", state);
+      
+      name = strdup(snd_pcm_name(i->alsa_pcm));
+      ERROR("Trying to close/reopen alsa device: %s\n", name);
+      
+      
+      DNOTE("Closing alsa pcm device: %s\n", name ? name : "");
+      
+      snd_pcm_close(i->alsa_pcm);
+      
+      i->initialized = 0;
+      i->sample_rate = 0;
+      i->samples_written = 0;
+      i->sample_frame_size = 0;
+      
+      DNOTE("Reopening alsa pcm device: %s\n", name);
+      
+      if((err = snd_pcm_open(&(i->alsa_pcm), name, 
+			     SND_PCM_STREAM_PLAYBACK, SND_PCM_NONBLOCK)) < 0) {
+	ERROR("Reopening alsa pcm device '%s': %s\n", name, snd_strerror(err));
+      }    
+      
+      free(name);
+      
+      if(err < 0) {
+	return -1;
+      }
+    }
+
+
   }
 
   // these are allocated with alloca and automatically freed when
@@ -299,8 +334,19 @@
       }
       /* ok */
       break;
+    case 24:
+      if(audio_info->byteorder == OGLE_AO_BYTEORDER_BE) {
+	i->format = SND_PCM_FORMAT_S32_BE;
+      } else {
+	i->format = SND_PCM_FORMAT_S32_LE;
+      }
+      audio_info->sample_resolution = 32;
+      /* ok */
+      break;
     default:
       /* not supported */
+      ERROR("sample resolution %d not implmented\n",
+	    audio_info->sample_resolution);
       return -1;
       break;
     }
@@ -372,6 +418,7 @@
 	i->sample_rate, snd_pcm_format_name(i->format), 
 	i->channels, i->sample_frame_size);
 
+  audio_info->sample_resolution = i->sample_frame_size / i->channels * 8;
   return 0;
 }
 
@@ -380,7 +427,7 @@
   NOTE("xrun_recovery: %s\n", snd_strerror(err));
   if(err == -EPIPE) {	/* underrun */
     if((err = snd_pcm_prepare(handle)) < 0) {
-      ERROR("Can't recovery from underrun, prepare failed: %s\n",
+      ERROR("Can't recover from underrun, prepare failed: %s\n",
 	    snd_strerror(err));
     }
     return 0;
@@ -389,7 +436,7 @@
       sleep(1);	/* wait until suspend flag is released */
     if(err < 0) {
       if((err = snd_pcm_prepare(handle)) < 0) {
-	ERROR("Can't recovery from suspend, prepare failed: %s\n",
+	ERROR("Can't recover from suspend, prepare failed: %s\n",
 	      snd_strerror(err));
       }
     }
diff -urN -x CVS -x .cvsignore ogle-0.9.2/libogleao/obsd_audio.c ogle/libogleao/obsd_audio.c
--- ogle-0.9.2/libogleao/obsd_audio.c	2003-02-22 16:06:51.000000000 +0100
+++ ogle/libogleao/obsd_audio.c	2005-06-05 11:44:37.000000000 +0200
@@ -196,7 +196,6 @@
     
     instance->fd = open(dev, O_WRONLY);
     if(instance->fd < 0) {
-      fprintf(stderr, "Can not open %s\n", dev);
       free(instance);
       return NULL;
     }
diff -urN -x CVS -x .cvsignore ogle-0.9.2/libogleao/solaris_audio.c ogle/libogleao/solaris_audio.c
--- ogle-0.9.2/libogleao/solaris_audio.c	2003-01-11 21:38:03.000000000 +0100
+++ ogle/libogleao/solaris_audio.c	2005-06-05 11:44:37.000000000 +0200
@@ -268,7 +268,6 @@
     
     instance->fd = open(dev, O_WRONLY);
     if(instance->fd < 0) {
-      fprintf(stderr, "Can not open %s\n", dev);
       free(instance);
       return NULL;
     }
diff -urN -x CVS -x .cvsignore ogle-0.9.2/mpeg2_program/programstream.c ogle/mpeg2_program/programstream.c
--- ogle-0.9.2/mpeg2_program/programstream.c	2003-03-02 16:52:14.000000000 +0100
+++ ogle/mpeg2_program/programstream.c	2006-11-25 17:02:38.000000000 +0100
@@ -21,13 +21,13 @@
 #include <stdlib.h>
 #include <string.h>
 #include <signal.h>
-#include <sys/mman.h>
+
 #include <sys/types.h>
 #include <sys/stat.h>
-#include <sys/shm.h>
+#include <sys/mman.h>
+
 #include <fcntl.h>
 #include <unistd.h>
-#include <sys/msg.h>
 #include <errno.h>
 
 #include <ogle/msgevents.h>
@@ -40,12 +40,9 @@
 #include "common.h"
 #include "queue.h"
 #include "mpeg.h"
+#include "shm.h"
 
 
-#ifndef SHM_SHARE_MMU
-#define SHM_SHARE_MMU 0
-#endif
-
 typedef enum {
   STREAM_NOT_REGISTERED = 0,
   STREAM_DISCARD = 1,
@@ -64,7 +61,7 @@
 buf_data_t id_reg[256];
 buf_data_t id_reg_ps1[256];
 
-int register_id(uint8_t id, int subtype);
+int register_id(uint8_t id, uint8_t subtype);
 int id_registered(uint8_t id, uint8_t subtype);
 int init_id_reg(stream_state_t default_state);
 //int wait_for_msg(mq_cmdtype_t cmdtype);
@@ -90,7 +87,8 @@
 int switch_from_to_stream(uint8_t oldid, uint8_t oldsubtype,
 			  uint8_t newid, uint8_t newsubtype);
 int id_has_output(uint8_t stream_id, uint8_t subtype);
-int id_get_output(uint8_t id, int subtype);
+int id_get_output(uint8_t id, uint8_t subtype);
+static int enable_stream(uint8_t id, uint8_t subtype, int state);
 
 typedef struct {
   uint8_t *buf_start;
@@ -98,8 +96,7 @@
   int in_use;
 } q_elem;
 
-static int msgqid = -1;
-
+static int standalone = 1;
 static MsgEventQ_t *msgq;
 
 int scr_discontinuity = 0;
@@ -130,6 +127,7 @@
 int off_from;
 int off_to;
 int demux_cmd;
+static int32_t demux_nav_serial;
 
 extern char *optarg;
 extern int   optind, opterr, optopt;
@@ -161,6 +159,9 @@
 char cur_filename[PATH_MAX+1];
 int new_file;
 
+static int searching_for_nav;
+static int nav_found = 0;
+
 // #define DEBUG
 
 
@@ -251,7 +252,8 @@
 {
   
   if((dvdroot = DVDOpen(path)) == NULL) {
-    FATAL("%s", "Couldn't open dvd\n");
+    FATAL("Couldn't open dvd at %s: (%d) %s\n",
+	  path, errno, strerror(errno));
     exit(1);
   }
   
@@ -279,7 +281,8 @@
     DVDCloseFile(dvdfile);
   }
   if((dvdfile = DVDOpenFile(dvdroot, titlenum, domain)) == NULL) {
-    FATAL("%s", "Couldn't open dvdfile\n");
+    FATAL("Couldn't open dvdfile (%d,%d): %s\n",
+	  titlenum, domain, strerror(errno));
     exit(1);
   }
   dvd_file_num = titlenum;
@@ -306,7 +309,7 @@
     
     switch(blocks_read) {
     case -1:
-      FATAL("%s", "dvdreadblocks failed\n");
+      FATAL("dvdreadblocks failed at block offset %d\n", boffset);
       exit(1);
     case 0:
       WARNING("%s", "dvdreadblocks returned 0\n");
@@ -331,8 +334,8 @@
       break;
     }
     if(blocks_read != nblocks) {
-      WARNING("dvdreadblocks only got %d, wanted %d\n",
-	      blocks_read, nblocks);
+      WARNING("dvdreadblocks only got %d, wanted %d (block offset: %d)\n",
+	      blocks_read, nblocks, boffset);
     }
     buf += blocks_read * 2048;
     nblocks -= blocks_read;
@@ -353,6 +356,7 @@
   int off;
   int blocks_in_buf;
   int size;
+  volatile int *in_use;
 
   //fprintf(stderr, "demux: fill_buffer: title: %d, domain: %d, off: %d, blocks: %d\n", title, domain, boffset, nblocks);
   
@@ -372,8 +376,10 @@
   first_data_elem_nr = data_elem_nr;
   //fprintf(stderr, "first_data_elem_nr: %d\n", first_data_elem_nr);
 
+
   while(1) {
-    if(data_elems[data_elem_nr].in_use || buf_empty) {
+    in_use = &(data_elems[data_elem_nr].in_use);
+    if(*in_use || buf_empty) {
       /* this block is in use, check if we have enough free space */
       
       /* offset in buffer of the used block we found */
@@ -418,6 +424,8 @@
 	/* the nr of contigously available blocks is too small, 
 	 * wait for more free blocks */
 	fprintf(stderr, "*demux: SEND A BUG REPORT: need more free space, not implemented\n");
+	fprintf(stderr, "title: %d, domain: %d, boffset: %u, nblocks: %u\n",
+		title, domain, boffset, nblocks);
       } else {
 	/* we have enough free blocks */
 	break;
@@ -554,7 +562,8 @@
   } cmd;
 } demux_q_t;
 
-static MsgEvent_t demux_q[5];
+#define DEMUX_Q_NUM_ELEM 10
+static MsgEvent_t demux_q[DEMUX_Q_NUM_ELEM];
 static int demux_q_start = 0;
 static int demux_q_len = 0;
 
@@ -564,7 +573,7 @@
   MsgEvent_t *q_ev;
   
   int new_demux_range = 0;
-  if(id_stat(0xe0, 0) == STREAM_DECODE) {
+  if(id_stat(0xe0, 0) == STREAM_DECODE || id_stat(0xe0, 0) == STREAM_MUTED) {
     if(demux_cmd & FlowCtrlCompleteVideoUnit) {
       put_in_q(id_qaddr(0xe0, 0), 0, 0, 0, 0, 0, 0, demux_cmd, 0, 0);
     }
@@ -580,7 +589,9 @@
 	}
       }
     }
-    
+#ifdef NAV_SEARCH_DEBUG
+    fprintf(stderr, "+++++++++++++++ q len: %d +++++++++++\n", demux_q_len);
+#endif
     q_ev = &demux_q[demux_q_start];
     
     switch(q_ev->type) {
@@ -601,10 +612,78 @@
       //free(q_ev->cmd.file);
       break;
     case MsgEventQDemuxDVD:
-      fill_buffer(q_ev->demuxdvd.titlenum, q_ev->demuxdvd.domain,
-		  q_ev->demuxdvd.block_offset, q_ev->demuxdvd.block_count);
-      new_demux_range = 1;
-      demux_cmd = q_ev->demuxdvd.flowcmd;
+      searching_for_nav = q_ev->demuxdvd.nav_search;
+      if(searching_for_nav) {
+#ifdef NAV_SEARCH_DEBUG
+	fprintf(stderr, "\n++++++++++++ demux dvd search+++++++++++++++++\n");
+#endif
+	if(nav_found) {
+	  //done, skip to next cmd
+#ifdef NAV_SEARCH_DEBUG
+	  WARNING("nav found at block %x\n", q_ev->demuxdvd.block_offset-1);
+#endif
+	  nav_found = 0;
+	} else {
+	  
+	  if(demux_q_start == 0) {
+	    demux_q_start = DEMUX_Q_NUM_ELEM-1;
+	  } else {
+	    demux_q_start--;
+	  }
+	  demux_q_len++;
+#ifdef NAV_SEARCH_DEBUG	  
+	  WARNING("searching for nav at block %x(%x)\n",
+		  q_ev->demuxdvd.block_offset,
+		  demux_nav_serial = q_ev->demuxdvd.serial);
+#endif
+	  //check next block
+	  if(q_ev->demuxdvd.block_count) {
+	    fill_buffer(q_ev->demuxdvd.titlenum, q_ev->demuxdvd.domain,
+			q_ev->demuxdvd.block_offset++, 1); 
+	    q_ev->demuxdvd.block_count--;
+	    new_demux_range = 1;
+	    demux_cmd = q_ev->demuxdvd.flowcmd;
+	    demux_nav_serial = q_ev->demuxdvd.serial;
+	  } else {
+	    WARNING("%s", "Found no NAV-blocks\n");
+	  }
+	}
+      } else {
+#ifdef NAV_SEARCH_DEBUG
+	fprintf(stderr, "\n++++++++++++ demux dvd +++++++++++++++++\n");
+#endif
+	if(q_ev->demuxdvd.titlenum == 0 &&
+	   q_ev->demuxdvd.domain == 0 &&
+	   q_ev->demuxdvd.block_offset == 0 &&
+	   q_ev->demuxdvd.block_count == 0) {
+#ifdef NAV_SEARCH_DEBUG
+	  fprintf(stderr, "\n++++++++++++ demux flush +++++++++++++++++\n");
+#endif	  
+	  demux_cmd = q_ev->demuxdvd.flowcmd;
+	  demux_nav_serial = q_ev->demuxdvd.serial;
+
+	  if(id_stat(0xe0, 0) == STREAM_DECODE ||
+	     id_stat(0xe0, 0) == STREAM_MUTED) {
+#ifdef NAV_SEARCH_DEBUG
+	    fprintf(stderr, "\n++++++++++++ stream in use +++++++++++++++\n");
+#endif
+	    if(demux_cmd & FlowCtrlFlush) {
+#ifdef NAV_SEARCH_DEBUG
+	      fprintf(stderr, "\n++++++ flowcmd ++++++++++++++\n");
+#endif
+	      put_in_q(id_qaddr(0xe0, 0), 0, 0, 0, 0, 0, 0, demux_cmd, 0, 0);
+	    }
+	  }
+	} else {
+	  
+	  
+	  fill_buffer(q_ev->demuxdvd.titlenum, q_ev->demuxdvd.domain,
+		      q_ev->demuxdvd.block_offset, q_ev->demuxdvd.block_count);
+	  new_demux_range = 1;
+	  demux_cmd = q_ev->demuxdvd.flowcmd;
+	  demux_nav_serial = q_ev->demuxdvd.serial;
+	}
+      }
       break;
     case MsgEventQDemuxDVDRoot:
       dvd_open_root(q_ev->demuxdvdroot.path);
@@ -613,7 +692,7 @@
       fprintf(stderr, "demux: that's not possible\n");
       break;
     }
-    demux_q_start = (demux_q_start+1)%5;
+    demux_q_start = (demux_q_start+1)%DEMUX_Q_NUM_ELEM;
     demux_q_len--;
   }
 }
@@ -622,8 +701,8 @@
 {
   int pos;
   
-  if(demux_q_len < 5) {
-    pos = (demux_q_start + demux_q_len)%5;
+  if(demux_q_len < DEMUX_Q_NUM_ELEM) {
+    pos = (demux_q_start + demux_q_len)%DEMUX_Q_NUM_ELEM;
     memcpy(&demux_q[pos], ev, sizeof(MsgEvent_t));
     demux_q_len++;
     
@@ -697,7 +776,7 @@
 
   if(!system_header_set) {
     system_header_set = 1;
-    if(msgqid != -1) {
+    if(!standalone) {
       // this is now allocated before we start reading
       //get_buffer(min_bufsize);
     }
@@ -900,8 +979,10 @@
     register_id(stream_id, subtype);
   }
 
-  //fprintf(stderr, "Packet id: %02x, %02x\n", stream_id, subtype);
-
+#if 0
+  fprintf(stderr, "Packet id: %02x, %02x, state %d\n",
+	  stream_id, subtype, id_stat(stream_id, subtype));
+#endif
   if(id_stat(stream_id, subtype) == STREAM_DECODE) {
     if(!id_has_output(stream_id, subtype)) {
       id_get_output(stream_id, subtype);
@@ -917,7 +998,7 @@
     //fprintf(stderr, "demux: put_in_q stream_id: %x %x\n",
     //      stream_id, subtype);
 
-    if(msgqid != -1) {
+    if(!standalone) {
       int infile;
       int is_newfile;
       infile = id_infile(stream_id, subtype);
@@ -928,6 +1009,17 @@
 	is_newfile = 0;
       }
 
+      if(searching_for_nav) {
+	//if not a nav pack, drop it
+	if(stream_id != MPEG2_PRIVATE_STREAM_2) {
+	  drop_bytes(len);
+	  return;
+	} else {
+	  //if a nav pack, we found it
+	  nav_found = 1;
+	}
+      }
+      
       if(stream_id == MPEG2_PRIVATE_STREAM_1) {
 	
 	if((subtype >= 0x80) && (subtype < 0x88)) {
@@ -1021,7 +1113,7 @@
     }
     
   }
-  
+  //DNOTE("drop %d, %02x\n", len, stream_id);
   drop_bytes(len);
   
 }
@@ -1395,7 +1487,7 @@
   SCR_flags = 0;
 
   /* TODOD clean up */
-  if(msgqid != -1) {
+  if(!standalone) {
     if(off_to != -1) {
       if(off_to <= offs-(bits_left/8)) {
 	//fprintf(stderr, "demux: off_to %d offs %d pack\n", off_to, offs);
@@ -1422,7 +1514,7 @@
   case MPEG1:
 
     /* TODO clean up */
-    if(msgqid != -1) {
+    if(!standalone) {
       if(off_to != -1) {
 	if(off_to <= offs-(bits_left/8)) {
 	  //fprintf(stderr, "demux: off_to %d offs %d mpeg1\n", off_to, offs);
@@ -1450,7 +1542,7 @@
       packet();
 
       /* TODO clean up */
-      if(msgqid != -1) {
+      if(!standalone) {
 	if(off_to != -1) {
 	  if(off_to <= offs-(bits_left/8)) {
 	    //fprintf(stderr, "demux: off_to %d offs %d packet\n", off_to, offs);
@@ -1520,7 +1612,7 @@
       SCR_flags = 0;
 
       /* TODO clean up */
-      if(msgqid != -1) {
+      if(!standalone) {
 	if(off_to != -1) {
 	  if(off_to <= offs-(bits_left/8)) {
 	    //fprintf(stderr, "demux: off_to %d offs %d mpeg2\n", off_to, offs);
@@ -1647,9 +1739,8 @@
 {
   char *shmaddr;
   
-  if(shmid >= 0) {
-    if((shmaddr = shmat(shmid, NULL, SHM_SHARE_MMU)) == (void *)-1) {
-      perror("demux: attach_ctrl_data(), shmat()");
+  if(shmid != -1) {
+    if((shmaddr = ogle_shmat(shmid)) == (void *)-1) {
       return -1;
     }
     
@@ -1659,6 +1750,7 @@
   }    
   
   return 0;
+  
 }
 
 int main(int argc, char **argv)
@@ -1672,7 +1764,12 @@
   char *file;
   uint8_t stream_id;
   int lost_sync = 1;
-  
+#ifdef SOCKIPC
+  MsgEventQType_t msgq_type;
+  char *msgqid;
+#else
+  int msgqid = -1;
+#endif
   program_name = argv[0];
   GET_DLEVEL();
   init_id_reg(STREAM_DISCARD);
@@ -1928,7 +2025,15 @@
       debug = atoi(optarg);
       break;
     case 'm':
+#ifdef SOCKIPC
+      if(get_msgqtype(optarg, &msgq_type, &msgqid) == -1) {
+	fprintf(stderr, "unknown msgq type: %s\n", optarg);
+	return 1;
+      }
+#else
       msgqid = atoi(optarg);
+#endif
+      standalone = 0;
       break;
     case 'o':
       offs = atoi(optarg);
@@ -1940,7 +2045,7 @@
     }
   }
 
-  if(msgqid == -1) {
+  if(standalone) {
     if(argc - optind != 1){
       usage();
       return 1;
@@ -1948,12 +2053,16 @@
   }
 
 
-  if(msgqid != -1) {
+  if(!standalone) {
     MsgEvent_t regev;
     int fileopen = 0;
     init_id_reg(STREAM_DISCARD);
     // get a handle
+#ifdef SOCKIPC
+    if((msgq = MsgOpen(msgq_type, msgqid, strlen(msgqid))) == NULL) {
+#else
     if((msgq = MsgOpen(msgqid)) == NULL) {
+#endif
       FATAL("%s", "Couldn't get message q\n");
       exit(1);
     }
@@ -2028,7 +2137,7 @@
 #if DEBUG
   fprintf(stderr, "demux: get next demux q\n");
 #endif
-  if(msgqid != -1) {
+  if(!standalone) {
     get_next_demux_q();
   }
 
@@ -2103,6 +2212,11 @@
   case MsgEventQDemuxStreamChange:
     switch_to_stream(ev->demuxstream.stream_id, ev->demuxstream.subtype);
     break;
+  case MsgEventQDemuxStreamEnable:
+    enable_stream(ev->demuxstreamenable.stream_id,
+		  ev->demuxstreamenable.subtype,
+		  ev->demuxstreamenable.state);
+    break;
   case MsgEventQDemuxStreamChange2:
     switch_from_to_stream(ev->demuxstreamchange2.old_stream_id,
 			  ev->demuxstreamchange2.old_subtype,
@@ -2126,14 +2240,14 @@
   }
 }
 
-int register_id(uint8_t id, int subtype)
+int register_id(uint8_t id, uint8_t subtype)
 {
   MsgEvent_t ev;
   
   data_buf_head_t *data_buf_head;
   int qsize;
   
-  if(msgqid != -1) {
+  if(!standalone) {
     
     data_buf_head = (data_buf_head_t *)data_buf_addr;
     
@@ -2196,14 +2310,14 @@
   return 0;
 }
 
-int id_get_output(uint8_t id, int subtype)
+int id_get_output(uint8_t id, uint8_t subtype)
 {
   MsgEvent_t ev;
   
   data_buf_head_t *data_buf_head;
   int qsize;
   
-  if(msgqid != -1) {
+  if(!standalone) {
     
     data_buf_head = (data_buf_head_t *)data_buf_addr;
     
@@ -2351,7 +2465,8 @@
     }
     
     for(n = idtype; n < (idtype+idrange); n++) {
-      if(id_stat(n, 0) == STREAM_DECODE) {
+      if((id_stat(n, 0) != STREAM_DISCARD) &&
+	 (id_stat(n, 0) != STREAM_NOT_REGISTERED)) {
 	return n;
       }
     }
@@ -2378,7 +2493,8 @@
     }
     
     for(n = idtype; n < (idtype+idrange); n++) {
-      if(id_stat(id, n) == STREAM_DECODE) {
+      if((id_stat(id, n) != STREAM_DISCARD) &&
+	 (id_stat(id, n) != STREAM_NOT_REGISTERED)) {
 	return n;
       }
     }
@@ -2396,7 +2512,7 @@
     if(id != MPEG2_PRIVATE_STREAM_1) {
       id_reg[id].state = STREAM_DECODE;
     } else {
-      id_reg_ps1[subtype].state = STREAM_DISCARD;
+      id_reg_ps1[subtype].state = STREAM_DECODE;
     }
     return 1;
   }
@@ -2429,6 +2545,25 @@
 }
 
 
+static int enable_stream(uint8_t id, uint8_t subtype, int state)
+{
+  stream_state_t sstate;
+
+  if(state) {
+    sstate = STREAM_DECODE;
+  } else {
+    sstate = STREAM_MUTED;
+  }
+  
+  if(id != MPEG2_PRIVATE_STREAM_1) {
+    id_reg[id].state = sstate;
+  } else {
+    id_reg_ps1[subtype].state = sstate;
+  }
+  return 1;
+}
+
+
 int switch_from_to_stream(uint8_t oldid, uint8_t oldsubtype,
 			  uint8_t newid, uint8_t newsubtype)
 {
@@ -2563,12 +2698,8 @@
 {
   char *shmaddr;
 
-#if DEBUG
-  fprintf(stderr, "demux: shmid: %d\n", shmid);
-#endif
-  if(shmid >= 0) {
-    if((shmaddr = shmat(shmid, NULL, SHM_SHARE_MMU)) == (void *)-1) {
-      perror("demux: attach_decoder_buffer(), shmat()");
+  if(shmid != -1) {
+    if((shmaddr = ogle_shmat(shmid)) == (void *)-1) {
       return -1;
     }
     id_add(stream_id, subtype, STREAM_DECODE, shmid, shmaddr, NULL);
@@ -2576,8 +2707,9 @@
   } else {
     id_add(stream_id, subtype, STREAM_DISCARD, -1, NULL, NULL);
   }
-    
+  
   return 0;  
+  
 }
 
 
@@ -2588,16 +2720,11 @@
   data_elem_t *data_elems;
   int n;
   
-#if DEBUG
-  fprintf(stderr, "demux: attach_buffer() shmid: %d\n", shmid);
-#endif
-  
-  if(shmid >= 0) {
-    if((shmaddr = shmat(shmid, NULL, SHM_SHARE_MMU)) == (void *)-1) {
-      perror("demux: attach_buffer(), shmat()");
+  if(shmid != -1) {
+    if((shmaddr = ogle_shmat(shmid)) == (void *)-1) {
       exit(1);
     }
-
+    
     data_buf_addr = shmaddr;
     data_buf_head = (data_buf_head_t *)data_buf_addr;
     data_buf_head->shmid = shmid;
@@ -2612,9 +2739,6 @@
     
     disk_buf = data_buf_addr + data_buf_head->buffer_start_offset;
     
-#if DEBUG
-    fprintf(stderr, "demux: setup disk_buf: %lu\n", (unsigned long)disk_buf);
-#endif
     data_elems = (data_elem_t *)(data_buf_addr+sizeof(data_buf_head_t));
     for(n = 0; n < data_buf_head->nr_of_dataelems; n++) {
       data_elems[n].in_use = 0;
@@ -2623,8 +2747,9 @@
   } else {
     return -1;
   }
-    
+  
   return 0;
+  
 }
 
 
@@ -2660,27 +2785,48 @@
 }
 
 
-void flush_all_streams(int scr_id)
+void flush_stream(int streamid, int scr_id, int32_t nav_serial)
 {
   MsgEvent_t ev;
-  int n;
   q_head_t *q_head = NULL;
   
   // send flush msg
   ev.type = MsgEventQFlushData;
   ev.flushdata.to_scrid = scr_id;
+  ev.flushdata.to_navserial = nav_serial;
   
-  for(n = 0; n < 256; n++) {
-    if((n != MPEG2_PRIVATE_STREAM_1) && (id_reg[n].state == STREAM_DECODE)) {
-      q_head = (q_head_t *)id_reg[n].shmaddr;
-      if(q_head != NULL) {
-	//fprintf(stderr, "demux: flushing stream %02x\n", n);
-	if(MsgSendEvent(msgq, q_head->reader, &ev, 0) == -1) {
-	  fprintf(stderr, "demux: couldn't send flush\n");
-	}
+  if((streamid != MPEG2_PRIVATE_STREAM_1) &&
+     ((id_reg[streamid].state == STREAM_DECODE) ||
+     (id_reg[streamid].state == STREAM_MUTED))) {
+    q_head = (q_head_t *)id_reg[streamid].shmaddr;
+    if(q_head != NULL) {
+      //fprintf(stderr, "demux: flushing stream %02x\n", streamid);
+      if(MsgSendEvent(msgq, q_head->reader, &ev, 0) == -1) {
+	fprintf(stderr, "demux: couldn't send flush\n");
       }
     }
   }
+}
+
+
+void flush_all_streams(int scr_id, int32_t nav_serial)
+{
+  MsgEvent_t ev;
+  int n;
+  q_head_t *q_head = NULL;
+  
+#ifdef NAV_SEARCH_DEBUG
+  fprintf(stderr, "\n+++ flush all streams +++\n");
+#endif
+
+  // send flush msg
+  ev.type = MsgEventQFlushData;
+  ev.flushdata.to_scrid = scr_id;
+  ev.flushdata.to_navserial = nav_serial;
+  
+  for(n = 0; n < 256; n++) {
+    flush_stream(n, scr_id, nav_serial);
+  }
 
   for(n = 0; n < 256; n++) {
     if(id_reg_ps1[n].state == STREAM_DECODE) {
@@ -2709,6 +2855,8 @@
   MsgEvent_t ev;
   int nr_waits = 0;
   
+  volatile int *in_use;
+  
   static int scr_id = 0;
   static int scr_nr = 0;
   
@@ -2723,9 +2871,10 @@
    * We might also do something smarter here but provided that we have a
    * large enough buffer this will not be common.
    */
-
+  
+  in_use = &(data_elems[data_elem_nr].in_use);
   // TODO clean and simplify
-  while(data_elems[data_elem_nr].in_use) {
+  while(*in_use) {
     nr_waits++;
     /* If this element is in use we have to wait untill it is released.
      * We know which consumer q we need to wait on. 
@@ -2748,7 +2897,7 @@
     
     q_head->writer_requests_notification = 1;
 
-    while(data_elems[data_elem_nr].in_use) {
+    while(*in_use) {
       DPRINTF(1, "demux: waiting for notification\n");
       if(MsgNextEvent(msgq, &ev) != -1) {
 	handle_events(&ev);
@@ -2759,7 +2908,7 @@
 
   }
   /* Now the element should be free. 'paranoia check' */
-  if(data_elems[data_elem_nr].in_use) {
+  if(*in_use) {
     fprintf(stderr, "demux: somethings wrong, elem %d still in use\n",
 	    data_elem_nr);
   }
@@ -2807,12 +2956,13 @@
   }
   
   if(demux_cmd & FlowCtrlFlush) {
-    flush_all_streams(scr_id);
+    flush_all_streams(scr_id, demux_nav_serial);
     demux_cmd &= ~FlowCtrlFlush;
   }
 
+  data_elems[data_elem_nr].serial = demux_nav_serial;
   data_elems[data_elem_nr].scr_nr = scr_nr;
-  data_elems[data_elem_nr].in_use = 1;
+  *in_use = 1;
 
   data_buf_head->write_nr = 
     (data_buf_head->write_nr+1) % data_buf_head->nr_of_dataelems;
@@ -2827,10 +2977,11 @@
   q_elem = (q_elem_t *)(q_addr+sizeof(q_head_t));
   elem = q_head->write_nr;
   
-  if(q_elem[elem].in_use) {
+  in_use = &(q_elem[elem].in_use);
+  if(*in_use) {
     q_head->writer_requests_notification = 1;
     
-    while(q_elem[elem].in_use) {
+    while(*in_use) {
       DPRINTF(1, "demux: waiting for notification2\n");
       if(MsgNextEvent(msgq, &ev) != -1) {
 	handle_events(&ev);
@@ -2840,7 +2991,7 @@
   }
   
   q_elem[elem].data_elem_index = data_elem_nr;
-  q_elem[elem].in_use = 1;
+  *in_use = 1;
   
   q_head->write_nr = (q_head->write_nr+1)%q_head->nr_of_qelems;
   
diff -urN -x CVS -x .cvsignore ogle-0.9.2/mpeg2_video/Makefile.am ogle/mpeg2_video/Makefile.am
--- ogle-0.9.2/mpeg2_video/Makefile.am	2003-10-14 03:05:15.000000000 +0200
+++ ogle/mpeg2_video/Makefile.am	2004-07-29 11:46:10.000000000 +0200
@@ -19,7 +19,11 @@
 MLIBSOURCES=yuv2rgb_mlib.c yuv2rgb_mlib.h
 else
 if USE_ALTIVEC
+if USE_ALTIVEC_DARWIN
+ALTIVECSOURCES=darwin_altivec_mlib.c
+else
 ALTIVECSOURCES=altivec_mlib.c
+endif
 else
 if USE_MMX
 MMXSOURCES=yuv2rgb_mmx.c idct_mmx.c mmx_mlib.c mmx_mlib.h mmx.h
@@ -37,13 +41,13 @@
 EXTRA_DIST = \
 	yuv2rgb_mlib.c yuv2rgb_mlib.h \
 	yuv2rgb_mmx.c yuv2rgb_mmx.h mmx.h mmx_mlib.h mmx_mlib.c idct_mmx.c \
-	altivec_mlib.c \
+	altivec_mlib.c darwin_altivec_mlib.c\
 	c_mlib.c c_mlib.h \
 	ffb_asm.s ffb_asm.h
 
 pkglib_PROGRAMS = ogle_mpeg_vs ogle_vout
 
-AM_CPPFLAGS = @TOP_INCLUDES@ @X_CFLAGS@ @MLIB_CPPFLAGS@ @JPEG_CPPFLAGS@ @XML_CFLAGS@
+AM_CPPFLAGS = @TOP_INCLUDES@ @X_CFLAGS@ @MLIB_CPPFLAGS@ @JPEG_CPPFLAGS@ @XML_CPPFLAGS@
 AM_CFLAGS = @O_CFLAGS@
 
 ogle_mpeg_vs_SOURCES = \
@@ -54,9 +58,9 @@
 	video_types.h \
 	$(MLIBSOURCES) $(ALTIVECSOURCES) $(MMXSOURCES) $(CSOURCES)
 ogle_mpeg_vs_LDADD = \
-	@MLIB_LIBS@ \
 	$(top_builddir)/common/libcommon.a \
-	$(top_builddir)/ogle/libmsgevents.la
+	$(top_builddir)/ogle/libmsgevents.la \
+	@MLIB_LIBS@
 
 ogle_vout_SOURCES = \
 	video_output_x11.c video_output.c \
@@ -70,10 +74,10 @@
 	video_output_parse_config.c video_output_parse_config.h \
 	$(MLIBSOURCES) $(ALTIVECSOURCES) $(SPARCASM) $(MMXSOURCES) $(CSOURCES)
 ogle_vout_LDADD = \
+	$(top_builddir)/common/libcommon.a \
+	$(top_builddir)/ogle/libmsgevents.la \
 	@MLIB_LIBS@ @JPEG_LIBS@ \
 	@X_PRE_LIBS@ @X_LIBS@ -lX11 @X_EXTRA_LIBS@ @XEXT_LIB@ \
 	@XF86VIDMODE_LIBS@ @XML_LIBS@ \
-	@XINERAMA_LIBS@ \
-	$(top_builddir)/common/libcommon.a \
-	$(top_builddir)/ogle/libmsgevents.la
+	@XINERAMA_LIBS@
 
diff -urN -x CVS -x .cvsignore ogle-0.9.2/mpeg2_video/c_getbits.c ogle/mpeg2_video/c_getbits.c
--- ogle-0.9.2/mpeg2_video/c_getbits.c	2003-03-02 16:54:18.000000000 +0100
+++ ogle/mpeg2_video/c_getbits.c	2006-01-25 17:54:11.000000000 +0100
@@ -19,13 +19,11 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <sys/types.h>
-#include <sys/mman.h>
 #include <sys/stat.h>
 #include <fcntl.h>
 #include <unistd.h>
+#include <sys/mman.h>
 
-#include <sys/shm.h>
-#include <sys/msg.h>
 #include <errno.h>
 #include <string.h>
 
@@ -36,9 +34,7 @@
 #include "queue.h"
 #include "timemath.h"
 #include "sync.h"
-#ifndef SHM_SHARE_MMU
-#define SHM_SHARE_MMU 0
-#endif
+#include "shm.h"
 
 
 
@@ -52,10 +48,12 @@
 extern uint64_t DTS;
 extern int scr_nr;
 
-extern int msgqid;
+extern int standalone;
 extern int output_client;
 extern int input_stream;
 
+extern int set_video_state(int state);
+
 int stream_shmid = -1;
 char *stream_shmaddr;
 
@@ -170,7 +168,7 @@
 
 void get_next_packet()
 {
-  if(msgqid == -1) {
+  if(standalone) {
     if(mmap_base == NULL) {
       clocktime_t real_time;
       clocktime_t scr_time;
@@ -374,6 +372,9 @@
   case MsgEventQQDetached:
     detach_data_q(ev->detachq.q_shmid, &data_q_head);
     break;
+  case MsgEventQSetDecodeVideoState:
+    set_video_state(ev->decodevideostate.state);
+    break;
   default:
     fprintf(stderr, "*video_decoder: unrecognized event type\n");
     break;
@@ -388,8 +389,8 @@
   
   //DNOTE("video_dec: shmid: %d\n", shmid);
   
-  if(shmid >= 0) {
-    if((shmaddr = shmat(shmid, NULL, SHM_SHARE_MMU)) == (void *)-1) {
+  if(shmid != -1) {
+    if((shmaddr = ogle_shmat(shmid)) == (void *)-1) {
       perror("video_stream: attach_decoder_buffer(), shmat()");
       return -1;
     }
@@ -403,8 +404,8 @@
   shmid = q_head->data_buf_shmid;
   //DNOTE("video_dec: data_buf shmid: %d\n", shmid);
 
-  if(shmid >= 0) {
-    if((shmaddr = shmat(shmid, NULL, SHM_SHARE_MMU)) == (void *)-1) {
+  if(shmid != -1) {
+    if((shmaddr = ogle_shmat(shmid)) == (void *)-1) {
       perror("video_stream: attach_buffer(), shmat()");
       return -1;
     }
@@ -438,6 +439,8 @@
   static int have_buf = 0;
   static uint8_t *tmp_base;
   static uint8_t dummy_buf[8] = {0, 0, 0, 0, 0, 0, 0, 0};
+  
+  volatile int *in_use;
 
   //fprintf(stderr, "video_dec: get_q()\n");
   
@@ -486,11 +489,13 @@
     q_head->read_nr = (q_head->read_nr+1)%q_head->nr_of_qelems;
     elem = q_head->read_nr;  
   }
+
+  in_use = &(q_elems[elem].in_use);
   // wait for buffer
-  if(!q_elems[elem].in_use) {
+  if(!*in_use) {
     q_head->reader_requests_notification = 1;
     
-    while(!q_elems[elem].in_use) {
+    while(!*in_use) {
       //fprintf(stderr, "video_decode: waiting for notification1\n");
       if(MsgNextEvent(msgq, &ev) != -1) {
 	handle_events(msgq, &ev);
@@ -583,18 +588,19 @@
 {
   char *shmaddr;
   
-  if(shmid >= 0) {
-    if((shmaddr = shmat(shmid, NULL, SHM_SHARE_MMU)) == (void *)-1) {
+  if(shmid != -1) {
+    if((shmaddr = ogle_shmat(shmid)) == (void *)-1) {
       perror("attach_ctrl_data(), shmat()");
       return -1;
     }
-    
+
     ctrl_data_shmid = shmid;
     ctrl_data = (ctrl_data_t*)shmaddr;
     ctrl_time = (ctrl_time_t *)(shmaddr+sizeof(ctrl_data_t));
   }
   
   return 0;  
+
 }
 
 
diff -urN -x CVS -x .cvsignore ogle-0.9.2/mpeg2_video/darwin_altivec_mlib.c ogle/mpeg2_video/darwin_altivec_mlib.c
--- ogle-0.9.2/mpeg2_video/darwin_altivec_mlib.c	1970-01-01 01:00:00.000000000 +0100
+++ ogle/mpeg2_video/darwin_altivec_mlib.c	2004-07-29 12:18:13.000000000 +0200
@@ -0,0 +1,3045 @@
+/* Ogle - A video player
+ * Copyright (C) 2001, Charles M. Hannum <root@ihack.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/*
+ * AltiVec support written by Charles M. Hannum <root@ihack.net>, except
+ * for the core IDCT routine published by Motorola.
+ *
+ * Notes:
+ * 1) All AltiVec loads and stores are aligned.  Conveniently, the output
+ *    area for the IDCT and motion comp functions is always aligned.
+ *    However, the reference area is not; therefore, we check its
+ *    alignment and use lvsl/vperm as necessary to align the reference
+ *    data as it's loaded.
+ * 2) Unfortunately, AltiVec doesn't do 8-byte loads and stores.  This
+ *    means that the fastest paths are only applicable to the Y channel.
+ *    For 8-byte operations on the U and V channels, there are two cases.
+ *    When the alignment of the input and output are the same, we can do
+ *    16-byte loads and just do two 4-byte stores.  For the unmatched
+ *    alignment case, we have to do a rotation of the loaded data first.
+ * 3) The `i[0-7]' variables look silly, but they prevent GCC from
+ *    generating gratuitous multiplies, and allow the loaded constants
+ *    to be recycled several times in the IDCT routine.
+ * 4) The use of "b" constraints is *very* important.  Using r0 in any
+ *    of the AltiVec load/store instructions is equivalent to a constant
+ *    0.
+ */
+
+#include <inttypes.h>
+
+#if 0
+#define	ASSERT(x)	if (!(x)) abort()
+#else
+#define	ASSERT(x)
+#endif
+
+void
+mlib_Init(void)
+{
+	asm("mtspr	0x100,%0" : : "b" (-1));
+}
+
+static inline void
+mlib_VideoInterpAveXY_U8_U8(uint8_t *curr_block, 
+                            const uint8_t *ref_block, 
+                            const int width, const int height,
+                            int32_t frame_stride,   
+                            int32_t field_stride) 
+{
+	int x, y;
+	const uint8_t *ref_block_next = ref_block + field_stride;
+
+	for (y = 0; y < height; y++) {
+		for (x = 0; x < width; x++)
+			curr_block[x] =
+			    (curr_block[x] + 
+			     ((ref_block[x] + ref_block_next[x] +
+			       ref_block[x+1] + ref_block_next[x+1] + 2) >> 2) + 1) >> 1;
+		curr_block     += frame_stride;
+		ref_block      += frame_stride;
+		ref_block_next += frame_stride;
+	}
+}
+
+static inline void
+mlib_VideoInterpXY_U8_U8(uint8_t *curr_block, 
+			 const uint8_t *ref_block, 
+			 const int width, const int height,
+			 int32_t frame_stride,   
+			 int32_t field_stride) 
+{
+	int x, y;
+	const uint8_t *ref_block_next = ref_block + field_stride;
+
+	for (y = 0; y < height; y++) {
+		for (x = 0; x < width; x++)
+			curr_block[x] =
+			    (ref_block[x] + ref_block_next[x] +
+			     ref_block[x+1] + ref_block_next[x+1] + 2) >> 2;
+		curr_block     += frame_stride;
+		ref_block      += frame_stride;
+		ref_block_next += frame_stride;
+	}
+}
+
+void
+mlib_VideoCopyRefAve_U8_U8_16x16(uint8_t *curr_block,
+                                 const uint8_t *ref_block,
+                                 int32_t stride)
+{
+	ASSERT(((int)curr_block & 15) == 0);
+
+	if (((int)ref_block & 15) != 0) {
+		int i0 = 0, i1 = 16;
+		asm(""
+			"lvsl v3,%0,%1\n"
+                    "" : : "b" (ref_block), "b" (i0));
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"lvx v2,%0,%2\n"
+			"vperm v0,v0,v1,v3\n"
+			"vavgub v0,v0,v2\n"
+			"stvx v0,%0,%2\n"
+                    "" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+                    "lvx v0,%1,%2\n"
+                    "lvx v1,%1,%3\n"
+                    "lvx v2,%0,%2\n"
+                    "vperm v0,v0,v1,v3\n"
+                    "vavgub v0,v0,v2\n"
+                    "stvx v0,%0,%2\n"
+                    "" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n" 
+			"lvx v2,%0,%2\n"
+			"vperm v0,v0,v1,v3\n"
+			"vavgub v0,v0,v2\n"
+			"stvx v0,%0,%2\n"
+                    "" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"lvx v2,%0,%2\n"
+			"vperm v0,v0,v1,v3\n"
+			"vavgub v0,v0,v2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"lvx v2,%0,%2\n"
+			"vperm v0,v0,v1,v3\n"
+			"vavgub v0,v0,v2\n"
+			"stvx v0,%0,%2 \n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"lvx v2,%0,%2\n"
+			"vperm v0,v0,v1,v3\n"
+			"vavgub v0,v0,v2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"lvx v2,%0,%2\n"
+			"vperm v0,v0,v1,v3\n"
+			"vavgub v0,v0,v2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"lvx v2,%0,%2\n"
+			"vperm v0,v0,v1,v3\n"
+			"vavgub v0,v0,v2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"lvx v2,%0,%2\n"
+			"vperm v0,v0,v1,v3\n"
+			"vavgub v0,v0,v2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"lvx v2,%0,%2\n"
+			"vperm v0,v0,v1,v3\n"
+			"vavgub v0,v0,v2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"lvx v2,%0,%2\n"
+			"vperm v0,v0,v1,v3\n"
+			"vavgub v0,v0,v2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"lvx v2,%0,%2\n"
+			"vperm v0,v0,v1,v3\n"
+			"vavgub v0,v0,v2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"lvx v2,%0,%2\n"
+			"vperm v0,v0,v1,v3\n"
+			"vavgub v0,v0,v2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"lvx v2,%0,%2\n"
+			"vperm v0,v0,v1,v3\n"
+			"vavgub v0,v0,v2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"lvx v2,%0,%2\n"
+			"vperm v0,v0,v1,v3\n"
+			"vavgub v0,v0,v2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"lvx v2,%0,%2\n"
+			"vperm v0,v0,v1,v3\n"
+			"vavgub v0,v0,v2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+	} else {
+		int i0 = 0;
+		asm(""
+			"lvx v0,%0,%2\n"
+			"lvx v1,%1,%2\n"
+			"vavgub v0,v0,v1\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%0,%2\n"
+			"lvx v1,%1,%2\n"
+			"vavgub v0,v0,v1\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%0,%2\n"
+			"lvx v1,%1,%2\n"
+			"vavgub v0,v0,v1\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%0,%2\n"
+			"lvx v1,%1,%2\n"
+			"vavgub v0,v0,v1\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%0,%2\n"
+			"lvx v1,%1,%2\n"
+			"vavgub v0,v0,v1\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%0,%2\n"
+			"lvx v1,%1,%2\n"
+			"vavgub v0,v0,v1\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%0,%2\n"
+			"lvx v1,%1,%2\n"
+			"vavgub v0,v0,v1\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%0,%2\n"
+			"lvx v1,%1,%2\n"
+			"vavgub v0,v0,v1\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%0,%2\n"
+			"lvx v1,%1,%2\n"
+			"vavgub v0,v0,v1\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%0,%2\n"
+			"lvx v1,%1,%2\n"
+			"vavgub v0,v0,v1\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%0,%2\n"
+			"lvx v1,%1,%2\n"
+			"vavgub v0,v0,v1\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%0,%2\n"
+			"lvx v1,%1,%2\n"
+			"vavgub v0,v0,v1\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%0,%2\n"
+			"lvx v1,%1,%2\n"
+			"vavgub v0,v0,v1\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%0,%2\n"
+			"lvx v1,%1,%2\n"
+			"vavgub v0,v0,v1\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%0,%2\n"
+			"lvx v1,%1,%2\n"
+			"vavgub v0,v0,v1\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%0,%2\n"
+			"lvx v1,%1,%2\n"
+			"vavgub v0,v0,v1\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+	}
+}
+
+void 
+mlib_VideoCopyRefAve_U8_U8_16x8(uint8_t *curr_block,
+				const uint8_t *ref_block,
+				int32_t stride)
+{
+	ASSERT(((int)curr_block & 15) == 0);
+
+	if (((int)ref_block & 15) != 0) {
+		int i0 = 0, i1 = 16;
+		asm(""
+			"lvsl v3,%0,%1\n"
+		"" : : "b" (ref_block), "b" (i0));
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"lvx v2,%0,%2\n"
+			"vperm v0,v0,v1,v3\n"
+			"vavgub v0,v0,v2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"lvx v2,%0,%2\n"
+			"vperm v0,v0,v1,v3\n"
+			"vavgub v0,v0,v2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"lvx v2,%0,%2\n"
+			"vperm v0,v0,v1,v3\n"
+			"vavgub v0,v0,v2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"lvx v2,%0,%2\n"
+			"vperm v0,v0,v1,v3\n"
+			"vavgub v0,v0,v2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"lvx v2,%0,%2\n"
+			"vperm v0,v0,v1,v3\n"
+			"vavgub v0,v0,v2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"lvx v2,%0,%2\n"
+			"vperm v0,v0,v1,v3\n"
+			"vavgub v0,v0,v2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"lvx v2,%0,%2\n"
+			"vperm v0,v0,v1,v3\n"
+			"vavgub v0,v0,v2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"lvx v2,%0,%2\n"
+			"vperm v0,v0,v1,v3\n"
+			"vavgub v0,v0,v2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+	} else {
+		int i0 = 0;
+		asm(""
+			"lvx v0,%0,%2\n"
+			"lvx v1,%1,%2\n"
+			"vavgub v0,v0,v1\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%0,%2\n"
+			"lvx v1,%1,%2\n"
+			"vavgub v0,v0,v1\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%0,%2\n"
+			"lvx v1,%1,%2\n"
+			"vavgub v0,v0,v1\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%0,%2\n"
+			"lvx v1,%1,%2\n"
+			"vavgub v0,v0,v1\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%0,%2\n"
+			"lvx v1,%1,%2\n"
+			"vavgub v0,v0,v1\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%0,%2\n"
+			"lvx v1,%1,%2\n"
+			"vavgub v0,v0,v1\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%0,%2\n"
+			"lvx v1,%1,%2\n"
+			"vavgub v0,v0,v1\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%0,%2\n"
+			"lvx v1,%1,%2\n"
+			"vavgub v0,v0,v1\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+	}
+}
+
+void 
+mlib_VideoCopyRefAve_U8_U8_8x8(uint8_t *curr_block,
+			       const uint8_t *ref_block,
+			       int32_t stride)
+{
+	ASSERT(((int)curr_block & 7) == 0);
+
+	if ((((int)ref_block ^ (int)curr_block) & 15) != 0) {
+		const int i0 = 0, i1 = 16, i2 = 4;
+		asm(""
+			"lvsl v3,%1,%2\n"
+			"lvsl v4,%1,%3\n"
+			"lvsr v5,%0,%2\n"
+			"lvsr v6,%0,%3\n"
+			"vperm v3,v3,v3,v5\n"
+			"vperm v4,v4,v4,v6\n"
+		"" : : "b" (curr_block), "b" (ref_block),
+		      "b" (i0), "b" (i0 + stride));
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"lvx v2,%0,%2\n"
+			"vperm v0,v0,v1,v3\n"
+			"vavgub v0,v0,v2\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%4\n"
+		"" : : "b" (curr_block), "b" (ref_block),
+		      "b" (i0), "b" (i1), "b" (i2));
+		curr_block += stride, ref_block += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"lvx v2,%0,%2\n"
+			"vperm v0,v0,v1,v4\n"
+			"vavgub v0,v0,v2\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%4\n"
+		"" : : "b" (curr_block), "b" (ref_block),
+		      "b" (i0), "b" (i1), "b" (i2));
+		curr_block += stride, ref_block += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"lvx v2,%0,%2\n"
+			"vperm v0,v0,v1,v3\n"
+			"vavgub v0,v0,v2\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%4\n"
+		"" : : "b" (curr_block), "b" (ref_block),
+		      "b" (i0), "b" (i1), "b" (i2));
+		curr_block += stride, ref_block += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"lvx v2,%0,%2\n"
+			"vperm v0,v0,v1,v4\n"
+			"vavgub v0,v0,v2\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%4\n"
+		"" : : "b" (curr_block), "b" (ref_block),
+		      "b" (i0), "b" (i1), "b" (i2));
+		curr_block += stride, ref_block += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"lvx v2,%0,%2\n"
+			"vperm v0,v0,v1,v3\n"
+			"vavgub v0,v0,v2\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%4\n"
+		"" : : "b" (curr_block), "b" (ref_block),
+		      "b" (i0), "b" (i1), "b" (i2));
+		curr_block += stride, ref_block += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"lvx v2,%0,%2\n"
+			"vperm v0,v0,v1,v4\n"
+			"vavgub v0,v0,v2\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%4\n"
+		"" : : "b" (curr_block), "b" (ref_block),
+		      "b" (i0), "b" (i1), "b" (i2));
+		curr_block += stride, ref_block += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"lvx v2,%0,%2\n"
+			"vperm v0,v0,v1,v3\n"
+			"vavgub v0,v0,v2\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%4\n"
+		"" : : "b" (curr_block), "b" (ref_block),
+		      "b" (i0), "b" (i1), "b" (i2));
+		curr_block += stride, ref_block += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"lvx v2,%0,%2\n"
+			"vperm v0,v0,v1,v4\n"
+			"vavgub v0,v0,v2\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%4\n"
+		"" : : "b" (curr_block), "b" (ref_block),
+		      "b" (i0), "b" (i1), "b" (i2));
+	} else {
+		int i0 = 0, i1 = 4;
+		asm(""
+			"lvx v0,%0,%2\n"
+			"lvx v1,%1,%2\n"
+			"vavgub v0,v0,v1\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%3\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%0,%2\n"
+			"lvx v1,%1,%2\n"
+			"vavgub v0,v0,v1\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%3\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%0,%2\n"
+			"lvx v1,%1,%2\n"
+			"vavgub v0,v0,v1\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%3\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%0,%2\n"
+			"lvx v1,%1,%2\n"
+			"vavgub v0,v0,v1\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%3\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%0,%2\n"
+			"lvx v1,%1,%2\n"
+			"vavgub v0,v0,v1\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%3\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%0,%2\n"
+			"lvx v1,%1,%2\n"
+			"vavgub v0,v0,v1\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%3\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%0,%2\n"
+			"lvx v1,%1,%2\n"
+			"vavgub v0,v0,v1\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%3\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%0,%2\n"
+			"lvx v1,%1,%2\n"
+			"vavgub v0,v0,v1\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%3\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+	}
+}
+
+void 
+mlib_VideoCopyRefAve_U8_U8_8x4(uint8_t *curr_block,
+			       const uint8_t *ref_block,
+			       int32_t stride)
+{
+	ASSERT(((int)curr_block & 7) == 0);
+
+	if ((((int)ref_block ^ (int)curr_block) & 15) != 0) {
+		const int i0 = 0, i1 = 16, i2 = 4;
+		asm(""
+			"lvsl v3,%1,%2\n"
+			"lvsl v4,%1,%3\n"
+			"lvsr v5,%0,%2\n"
+			"lvsr v6,%0,%3\n"
+			"vperm v3,v3,v3,v5\n"
+			"vperm v4,v4,v4,v6\n"
+		"" : : "b" (curr_block), "b" (ref_block),
+		      "b" (i0), "b" (i0 + stride));
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"lvx v2,%0,%2\n"
+			"vperm v0,v0,v1,v3\n"
+			"vavgub v0,v0,v2\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%4\n"
+		"" : : "b" (curr_block), "b" (ref_block),
+		      "b" (i0), "b" (i1), "b" (i2));
+		curr_block += stride, ref_block += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"lvx v2,%0,%2\n"
+			"vperm v0,v0,v1,v4\n"
+			"vavgub v0,v0,v2\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%4\n"
+		"" : : "b" (curr_block), "b" (ref_block),
+		      "b" (i0), "b" (i1), "b" (i2));
+		curr_block += stride, ref_block += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"lvx v2,%0,%2\n"
+			"vperm v0,v0,v1,v3\n"
+			"vavgub v0,v0,v2\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%4\n"
+		"" : : "b" (curr_block), "b" (ref_block),
+		      "b" (i0), "b" (i1), "b" (i2));
+		curr_block += stride, ref_block += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"lvx v2,%0,%2\n"
+			"vperm v0,v0,v1,v4\n"
+			"vavgub v0,v0,v2\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%4\n"
+		"" : : "b" (curr_block), "b" (ref_block),
+		      "b" (i0), "b" (i1), "b" (i2));
+	} else {
+		int i0 = 0, i1 = 4;
+		asm(""
+			"lvx v0,%0,%2\n"
+			"lvx v1,%1,%2\n"
+			"vavgub v0,v0,v1\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%3\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%0,%2\n"
+			"lvx v1,%1,%2\n"
+			"vavgub v0,v0,v1\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%3\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%0,%2\n"
+			"lvx v1,%1,%2\n"
+			"vavgub v0,v0,v1\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%3\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%0,%2\n"
+			"lvx v1,%1,%2\n"
+			"vavgub v0,v0,v1\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%3\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+	}
+}
+
+void
+mlib_VideoCopyRef_U8_U8_16x16_multiple(uint8_t *curr_block,
+				       const uint8_t *ref_block,
+				       int32_t stride,
+				       int32_t count)
+{
+	ASSERT(((int)curr_block & 15) == 0);
+	ASSERT(((int)ref_block & 15) == 0);
+	
+	while (count--) {
+		int i0 = 0;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+
+		curr_block += 16, ref_block += 16;
+	}
+}
+
+void
+mlib_VideoCopyRef_U8_U8_16x16(uint8_t *curr_block,
+			      const uint8_t *ref_block,
+			      int32_t stride)
+{
+	ASSERT(((int)curr_block & 15) == 0);
+	
+	if (((int)ref_block & 15) != 0) {
+		int i0 = 0, i1 = 16;
+		asm(""
+			"lvsl v2,%0,%1\n"
+		"" : : "b" (ref_block), "b" (i0));
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"vperm v0,v0,v1,v2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"vperm v0,v0,v1,v2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"vperm v0,v0,v1,v2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"vperm v0,v0,v1,v2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"vperm v0,v0,v1,v2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"vperm v0,v0,v1,v2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"vperm v0,v0,v1,v2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"vperm v0,v0,v1,v2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"vperm v0,v0,v1,v2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"vperm v0,v0,v1,v2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"vperm v0,v0,v1,v2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"vperm v0,v0,v1,v2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"vperm v0,v0,v1,v2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"vperm v0,v0,v1,v2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"vperm v0,v0,v1,v2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"vperm v0,v0,v1,v2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+	} else {
+		int i0 = 0;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+	}
+}
+
+void 
+mlib_VideoCopyRef_U8_U8_16x8(uint8_t *curr_block,
+			     const uint8_t *ref_block,
+			     int32_t stride)
+{
+	ASSERT(((int)curr_block & 15) == 0);
+
+	if (((int)ref_block & 15) != 0) {
+		int i0 = 0, i1 = 16;
+		asm(""
+			"lvsl v2,%0,%1\n"
+		"" : : "b" (ref_block), "b" (i0));
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"vperm v0,v0,v1,v2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"vperm v0,v0,v1,v2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"vperm v0,v0,v1,v2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"vperm v0,v0,v1,v2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"vperm v0,v0,v1,v2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"vperm v0,v0,v1,v2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"vperm v0,v0,v1,v2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"vperm v0,v0,v1,v2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+	} else {
+		int i0 = 0;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+		i0 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvx v0,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0));
+	}
+}
+
+void 
+mlib_VideoCopyRef_U8_U8_8x8_multiple(uint8_t *curr_block,
+				     uint8_t *ref_block,
+				     int32_t stride,
+				     int32_t count)
+{
+	ASSERT(((int)curr_block & 7) == 0);
+
+	while (count--) {
+		int i0 = 0, i1 = 4;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%3\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%3\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%3\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%3\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%3\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%3\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%3\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%3\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+
+		curr_block += 8, ref_block += 8;
+	}
+}
+
+void 
+mlib_VideoCopyRef_U8_U8_8x8(uint8_t *curr_block,
+			    const uint8_t *ref_block,
+			    int32_t stride)
+{
+	ASSERT(((int)curr_block & 7) == 0);
+
+	if ((((int)ref_block ^ (int)curr_block) & 15) != 0) {
+		const int i0 = 0, i1 = 16, i2 = 4;
+		asm(""
+			"lvsl v2,%1,%2\n"
+			"lvsl v3,%1,%3\n"
+			"lvsr v4,%0,%2\n"
+			"lvsr v5,%0,%3\n"
+			"vperm v2,v2,v2,v4\n"
+			"vperm v3,v3,v3,v5\n"
+		"" : : "b" (curr_block), "b" (ref_block),
+		      "b" (i0), "b" (i0 + stride));
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"vperm v0,v0,v1,v2\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%4\n"
+		"" : : "b" (curr_block), "b" (ref_block),
+		      "b" (i0), "b" (i1), "b" (i2));
+		curr_block += stride, ref_block += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"vperm v0,v0,v1,v3\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%4\n"
+		"" : : "b" (curr_block), "b" (ref_block),
+		      "b" (i0), "b" (i1), "b" (i2));
+		curr_block += stride, ref_block += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"vperm v0,v0,v1,v2\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%4\n"
+		"" : : "b" (curr_block), "b" (ref_block),
+		      "b" (i0), "b" (i1), "b" (i2));
+		curr_block += stride, ref_block += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"vperm v0,v0,v1,v3\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%4\n"
+		"" : : "b" (curr_block), "b" (ref_block),
+		      "b" (i0), "b" (i1), "b" (i2));
+		curr_block += stride, ref_block += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"vperm v0,v0,v1,v2\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%4\n"
+		"" : : "b" (curr_block), "b" (ref_block),
+		      "b" (i0), "b" (i1), "b" (i2));
+		curr_block += stride, ref_block += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"vperm v0,v0,v1,v3\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%4\n"
+		"" : : "b" (curr_block), "b" (ref_block),
+		      "b" (i0), "b" (i1), "b" (i2));
+		curr_block += stride, ref_block += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"vperm v0,v0,v1,v2\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%4\n"
+		"" : : "b" (curr_block), "b" (ref_block),
+		      "b" (i0), "b" (i1), "b" (i2));
+		curr_block += stride, ref_block += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"vperm v0,v0,v1,v3\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%4\n"
+		"" : : "b" (curr_block), "b" (ref_block),
+		      "b" (i0), "b" (i1), "b" (i2));
+	} else {
+		int i0 = 0, i1 = 4;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%3\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%3\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%3\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%3\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%3\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%3\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%3\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%3\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+	}
+}
+
+void 
+mlib_VideoCopyRef_U8_U8_8x4(uint8_t *curr_block,
+			    const uint8_t *ref_block,
+			    int32_t stride)
+{
+	ASSERT(((int)curr_block & 7) == 0);
+
+	if ((((int)ref_block ^ (int)curr_block) & 15) != 0) {
+		const int i0 = 0, i1 = 16, i2 = 4;
+		asm(""
+			"lvsl v2,%1,%2\n"
+			"lvsl v3,%1,%3\n"
+			"lvsr v4,%0,%2\n"
+			"lvsr v5,%0,%3\n"
+			"vperm v2,v2,v2,v4\n"
+			"vperm v3,v3,v3,v5\n"
+		"" : : "b" (curr_block), "b" (ref_block),
+		      "b" (i0), "b" (i0 + stride));
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"vperm v0,v0,v1,v2\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%4\n"
+		"" : : "b" (curr_block), "b" (ref_block),
+		      "b" (i0), "b" (i1), "b" (i2));
+		curr_block += stride, ref_block += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"vperm v0,v0,v1,v3\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%4\n"
+		"" : : "b" (curr_block), "b" (ref_block),
+		      "b" (i0), "b" (i1), "b" (i2));
+		curr_block += stride, ref_block += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"vperm v0,v0,v1,v2\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%4\n"
+		"" : : "b" (curr_block), "b" (ref_block),
+		      "b" (i0), "b" (i1), "b" (i2));
+		curr_block += stride, ref_block += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"vperm v0,v0,v1,v3\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%4\n"
+		"" : : "b" (curr_block), "b" (ref_block),
+		      "b" (i0), "b" (i1), "b" (i2));
+	} else {
+		int i0 = 0, i1 = 4;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%3\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%3\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%3\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+		i0 += stride, i1 += stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"stvewx v0,%0,%2\n"
+			"stvewx v0,%0,%3\n"
+		"" : : "b" (curr_block), "b" (ref_block), "b" (i0), "b" (i1));
+	}
+}
+
+void
+mlib_VideoInterpAveX_U8_U8_16x16(uint8_t *curr_block,
+                                 const uint8_t *ref_block,
+                                 int32_t frame_stride,
+                                 int32_t field_stride)
+{
+	int i;
+	int i0 = 0, i1 = 16;
+
+	ASSERT(((int)curr_block & 15) == 0);
+
+	asm(""
+		"vspltisb v0,1\n"
+		"lvsl v2,%0,%1\n"
+		"vaddubs v3,v2,v0\n"
+	"" : : "b" (ref_block), "b" (i0));
+	for (i = 0; i < 16; i++) {
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"vperm v4,v0,v1,v2\n"
+			"vperm v5,v0,v1,v3\n"
+			"lvx v6,%0,%2\n"
+			"vavgub v4,v4,v5\n"
+			"vavgub v4,v4,v6\n"
+			"stvx v4,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block),
+		      "b" (i0), "b" (i1));
+		i0 += frame_stride, i1 += frame_stride;
+	}
+}
+
+void 
+mlib_VideoInterpAveX_U8_U8_16x8(uint8_t *curr_block,
+				const uint8_t *ref_block,
+				int32_t frame_stride,
+				int32_t field_stride)
+{
+	int i;
+	int i0 = 0, i1 = 16;
+
+	ASSERT(((int)curr_block & 15) == 0);
+
+	asm(""
+		"vspltisb v0,1\n"
+		"lvsl v2,%0,%1\n"
+		"vaddubs v3,v2,v0\n"
+	"" : : "b" (ref_block), "b" (i0), "b" (i1));
+	for (i = 0; i < 8; i++) {
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"vperm v4,v0,v1,v2\n"
+			"vperm v5,v0,v1,v3\n"
+			"lvx v6,%0,%2\n"
+			"vavgub v4,v4,v5\n"
+			"vavgub v4,v4,v6\n"
+			"stvx v4,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block),
+		      "b" (i0), "b" (i1));
+		i0 += frame_stride, i1 += frame_stride;
+	}
+}
+
+void 
+mlib_VideoInterpAveX_U8_U8_8x8(uint8_t *curr_block,
+			       const uint8_t *ref_block,
+			       int32_t frame_stride,
+			       int32_t field_stride)
+{
+	int i;
+	const int i0 = 0, i1 = 16, i2 = 4;
+
+	ASSERT(((int)curr_block & 7) == 0);
+
+	asm(""
+		"vspltisb v0,1\n"
+		"lvsl v2,%1,%2\n"
+		"lvsr v3,%0,%2\n"
+		"lvsl v4,%1,%3\n"
+		"lvsr v5,%0,%3\n"
+		"vperm v2,v2,v2,v3\n"
+		"vperm v4,v4,v4,v5\n"
+		"vaddubs v3,v2,v0\n"
+		"vaddubs v5,v4,v0\n"
+	"" : : "b" (curr_block), "b" (ref_block),
+	      "b" (i0), "b" (i0 + frame_stride));
+	for (i = 0; i < 4; i++) {
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"vperm v6,v0,v1,v2\n"
+			"vperm v7,v0,v1,v3\n"
+			"lvx v8,%0,%2\n"
+			"vavgub v6,v6,v7\n"
+			"vavgub v6,v6,v8\n"
+			"stvewx v6,%0,%2\n"
+			"stvewx v6,%0,%4\n"
+		"" : : "b" (curr_block), "b" (ref_block),
+		      "b" (i0), "b" (i1), "b" (i2));
+		curr_block += frame_stride, ref_block += frame_stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"vperm v6,v0,v1,v4\n"
+			"vperm v7,v0,v1,v5\n"
+			"lvx v8,%0,%2\n"
+			"vavgub v6,v6,v7\n"
+			"vavgub v6,v6,v8\n"
+			"stvewx v6,%0,%2\n"
+			"stvewx v6,%0,%4\n"
+		"" : : "b" (curr_block), "b" (ref_block),
+		      "b" (i0), "b" (i1), "b" (i2));
+		curr_block += frame_stride, ref_block += frame_stride;
+	}
+}
+
+void 
+mlib_VideoInterpAveX_U8_U8_8x4(uint8_t *curr_block,
+			       const uint8_t *ref_block,
+			       int32_t frame_stride,
+			       int32_t field_stride)
+{
+	int i;
+	const int i0 = 0, i1 = 16, i2 = 4;
+
+	ASSERT(((int)curr_block & 7) == 0);
+
+	asm(""
+		"vspltisb v0,1\n"
+		"lvsl v2,%1,%2\n"
+		"lvsr v3,%0,%2\n"
+		"lvsl v4,%1,%3\n"
+		"lvsr v5,%0,%3\n"
+		"vperm v2,v2,v2,v3\n"
+		"vperm v4,v4,v4,v5\n"
+		"vaddubs v3,v2,v0\n"
+		"vaddubs v5,v4,v0\n"
+	"" : : "b" (curr_block), "b" (ref_block),
+	      "b" (i0), "b" (i0 + frame_stride));
+	for (i = 0; i < 2; i++) {
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"vperm v6,v0,v1,v2\n"
+			"vperm v7,v0,v1,v3\n"
+			"lvx v8,%0,%2\n"
+			"vavgub v6,v6,v7\n"
+			"vavgub v6,v6,v8\n"
+			"stvewx v6,%0,%2\n"
+			"stvewx v6,%0,%4\n"
+		"" : : "b" (curr_block), "b" (ref_block),
+		      "b" (i0), "b" (i1), "b" (i2));
+		curr_block += frame_stride, ref_block += frame_stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"vperm v6,v0,v1,v4\n"
+			"vperm v7,v0,v1,v5\n"
+			"lvx v8,%0,%2\n"
+			"vavgub v6,v6,v7\n"
+			"vavgub v6,v6,v8\n"
+			"stvewx v6,%0,%2\n"
+			"stvewx v6,%0,%4\n"
+		"" : : "b" (curr_block), "b" (ref_block),
+		      "b" (i0), "b" (i1), "b" (i2));
+		curr_block += frame_stride, ref_block += frame_stride;
+	}
+}
+
+void
+mlib_VideoInterpAveY_U8_U8_16x16(uint8_t *curr_block,
+                                 const uint8_t *ref_block,
+                                 int32_t frame_stride,
+                                 int32_t field_stride)
+{
+	int i;
+
+	ASSERT(((int)curr_block & 15) == 0);
+
+	if (((int)ref_block & 15) != 0) {
+		int i0 = 0, i1 = 16;
+		asm(""
+			"lvsl v4,%0,%1\n"
+		"" : : "b" (ref_block), "b" (i0));
+		for (i = 0; i < 16; i++) {
+			asm(""
+				"lvx v0,%1,%3\n"
+				"lvx v1,%2,%3\n"
+				"lvx v2,%1,%4\n"
+				"lvx v3,%2,%4\n"
+				"vperm v0,v0,v2,v4\n"
+				"vperm v1,v1,v3,v4\n"
+				"lvx v2,%0,%3\n"
+				"vavgub v0,v0,v1\n"
+				"vavgub v0,v0,v2\n"
+				"stvx v0,%0,%3\n"
+			"" : : "b" (curr_block), "b" (ref_block),
+			      "b" (ref_block + field_stride),
+			      "b" (i0), "b" (i1));
+			i0 += frame_stride, i1 += frame_stride;
+		}
+	} else {
+		int i0 = 0;
+		for (i = 0; i < 16; i++) {
+			asm(""
+				"lvx v0,%1,%3\n"
+				"lvx v1,%2,%3\n"
+				"lvx v2,%0,%3\n"
+				"vavgub v0,v0,v1\n"
+				"vavgub v0,v0,v2\n"
+				"stvx v0,%0,%3\n"
+			"" : : "b" (curr_block), "b" (ref_block),
+			      "b" (ref_block + field_stride),
+			      "b" (i0));
+			i0 += frame_stride;
+		}
+	}
+}
+
+void 
+mlib_VideoInterpAveY_U8_U8_16x8(uint8_t *curr_block,
+				const uint8_t *ref_block,
+				int32_t frame_stride,
+				int32_t field_stride)
+{
+	int i;
+
+	ASSERT(((int)curr_block & 15) == 0);
+
+	if (((int)ref_block & 15) != 0) {
+		int i0 = 0, i1 = 16;
+		asm(""
+			"lvsl v4,%0,%1\n"
+		"" : : "b" (ref_block), "b" (i0));
+		for (i = 0; i < 8; i++) {
+			asm(""
+				"lvx v0,%1,%3\n"
+				"lvx v1,%2,%3\n"
+				"lvx v2,%1,%4\n"
+				"lvx v3,%2,%4\n"
+				"vperm v0,v0,v2,v4\n"
+				"vperm v1,v1,v3,v4\n"
+				"lvx v2,%0,%3\n"
+				"vavgub v0,v0,v1\n"
+				"vavgub v0,v0,v2\n"
+				"stvx v0,%0,%3\n"
+			"" : : "b" (curr_block), "b" (ref_block),
+			      "b" (ref_block + field_stride),
+			      "b" (i0), "b" (i1));
+			i0 += frame_stride, i1 += frame_stride;
+		}
+	} else {
+		int i0 = 0;
+		for (i = 0; i < 8; i++) {
+			asm(""
+				"lvx v0,%1,%3\n"
+				"lvx v1,%2,%3\n"
+				"lvx v2,%0,%3\n"
+				"vavgub v0,v0,v1\n"
+				"vavgub v0,v0,v2\n"
+				"stvx v0,%0,%3\n"
+			"" : : "b" (curr_block), "b" (ref_block),
+			      "b" (ref_block + field_stride),
+			      "b" (i0));
+			i0 += frame_stride;
+		}
+	}
+}
+
+void 
+mlib_VideoInterpAveY_U8_U8_8x8(uint8_t *curr_block,
+			       const uint8_t *ref_block,
+			       int32_t frame_stride,
+			       int32_t field_stride)
+{
+	int i;
+
+	ASSERT(((int)curr_block & 7) == 0);
+
+	if (((((int)ref_block ^ (int)curr_block) | field_stride) & 15) != 0) {
+		const int i0 = 0, i1 = 16, i2 = 4;
+		asm(""
+			"lvsl v4,%1,%3\n"
+			"lvsl v5,%1,%4\n"
+			"lvsl v6,%2,%3\n"
+			"lvsl v7,%2,%4\n"
+			"lvsr v8,%0,%3\n"
+			"lvsr v9,%0,%4\n"
+			"vperm v4,v4,v4,v8\n"
+			"vperm v5,v5,v5,v9\n"
+			"vperm v6,v6,v6,v8\n"
+			"vperm v7,v7,v7,v9\n"
+		"" : : "b" (curr_block), "b" (ref_block),
+		      "b" (ref_block + field_stride),
+		      "b" (i0), "b" (i0 + frame_stride));
+		for (i = 0; i < 4; i++) {
+			asm(""
+				"lvx v0,%1,%3\n"
+				"lvx v1,%1,%4\n"
+				"lvx v2,%2,%3\n"
+				"lvx v3,%2,%4\n"
+				"vperm v8,v0,v1,v4\n"
+				"vperm v9,v2,v3,v6\n"
+				"lvx v10,%0,%3\n"
+				"vavgub v8,v8,v9\n"
+				"vavgub v8,v8,v10\n"
+				"stvewx v8,%0,%3\n"
+				"stvewx v8,%0,%5\n"
+			"" : : "b" (curr_block), "b" (ref_block),
+			      "b" (ref_block + field_stride),
+			      "b" (i0), "b" (i1), "b" (i2));
+			curr_block += frame_stride, ref_block += frame_stride;
+			asm(""
+				"lvx v0,%1,%3\n"
+				"lvx v1,%1,%4\n"
+				"lvx v2,%2,%3\n"
+				"lvx v3,%2,%4\n"
+				"vperm v8,v0,v1,v5\n"
+				"vperm v9,v2,v3,v7\n"
+				"lvx v10,%0,%3\n"
+				"vavgub v8,v8,v9\n"
+				"vavgub v8,v8,v10\n"
+				"stvewx v8,%0,%3\n"
+				"stvewx v8,%0,%5\n"
+			"" : : "b" (curr_block), "b" (ref_block),
+			      "b" (ref_block + field_stride),
+			      "b" (i0), "b" (i1), "b" (i2));
+			curr_block += frame_stride, ref_block += frame_stride;
+		}
+	} else {
+		int i0 = 0, i1 = 4;
+		for (i = 0; i < 8; i++) {
+			asm(""
+				"lvx v0,%1,%3\n"
+				"lvx v1,%2,%3\n"
+				"lvx v2,%0,%3\n"
+				"vavgub v0,v0,v1\n"
+				"vavgub v0,v0,v2\n"
+				"stvewx v0,%0,%3\n"
+				"stvewx v0,%0,%4\n"
+			"" : : "b" (curr_block), "b" (ref_block),
+			      "b" (ref_block + field_stride),
+			      "b" (i0), "b" (i1));
+			i0 += frame_stride, i1 += frame_stride;
+		}
+	}
+}
+
+void 
+mlib_VideoInterpAveY_U8_U8_8x4(uint8_t *curr_block,
+			       const uint8_t *ref_block,
+			       int32_t frame_stride,
+			       int32_t field_stride)
+{
+	int i;
+
+	ASSERT(((int)curr_block & 7) == 0);
+
+	if (((((int)ref_block ^ (int)curr_block) | field_stride) & 15) != 0) {
+		const int i0 = 0, i1 = 16, i2 = 4;
+		asm(""
+			"lvsl v4,%1,%3\n"
+			"lvsl v5,%1,%4\n"
+			"lvsl v6,%2,%3\n"
+			"lvsl v7,%2,%4\n"
+			"lvsr v8,%0,%3\n"
+			"lvsr v9,%0,%4\n"
+			"vperm v4,v4,v4,v8\n"
+			"vperm v5,v5,v5,v9\n"
+			"vperm v6,v6,v6,v8\n"
+			"vperm v7,v7,v7,v9\n"
+		"" : : "b" (curr_block), "b" (ref_block),
+		      "b" (ref_block + field_stride),
+		      "b" (i0), "b" (i0 + frame_stride));
+		for (i = 0; i < 2; i++) {
+			asm(""
+				"lvx v0,%1,%3\n"
+				"lvx v1,%1,%4\n"
+				"lvx v2,%2,%3\n"
+				"lvx v3,%2,%4\n"
+				"vperm v8,v0,v1,v4\n"
+				"vperm v9,v2,v3,v6\n"
+				"lvx v10,%0,%3\n"
+				"vavgub v8,v8,v9\n"
+				"vavgub v8,v8,v10\n"
+				"stvewx v8,%0,%3\n"
+				"stvewx v8,%0,%5\n"
+			"" : : "b" (curr_block), "b" (ref_block),
+			      "b" (ref_block + field_stride),
+			      "b" (i0), "b" (i1), "b" (i2));
+			curr_block += frame_stride, ref_block += frame_stride;
+			asm(""
+				"lvx v0,%1,%3\n"
+				"lvx v1,%1,%4\n"
+				"lvx v2,%2,%3\n"
+				"lvx v3,%2,%4\n"
+				"vperm v8,v0,v1,v5\n"
+				"vperm v9,v2,v3,v7\n"
+				"lvx v10,%0,%3\n"
+				"vavgub v8,v8,v9\n"
+				"vavgub v8,v8,v10\n"
+				"stvewx v8,%0,%3\n"
+				"stvewx v8,%0,%5\n"
+			"" : : "b" (curr_block), "b" (ref_block),
+			      "b" (ref_block + field_stride),
+			      "b" (i0), "b" (i1), "b" (i2));
+			curr_block += frame_stride, ref_block += frame_stride;
+		}
+	} else {
+		int i0 = 0, i1 = 4;
+		for (i = 0; i < 4; i++) {
+			asm(""
+				"lvx v0,%1,%3\n"
+				"lvx v1,%2,%3\n"
+				"lvx v2,%0,%3\n"
+				"vavgub v0,v0,v1\n"
+				"vavgub v0,v0,v2\n"
+				"stvewx v0,%0,%3\n"
+				"stvewx v0,%0,%4\n"
+			"" : : "b" (curr_block), "b" (ref_block),
+			      "b" (ref_block + field_stride),
+			      "b" (i0), "b" (i1));
+			i0 += frame_stride, i1 += frame_stride;
+		}
+	}
+}
+
+void
+mlib_VideoInterpAveXY_U8_U8_16x16(uint8_t *curr_block,
+				  const uint8_t *ref_block,
+				  int32_t frame_stride,
+				  int32_t field_stride)
+{
+	int i;
+	int i0 = 0, i1 = 16;
+
+	ASSERT(((int)curr_block & 15) == 0);
+
+	asm(""
+		"vspltisb v0,1\n"
+		"lvsl v4,%0,%1\n"
+		"vaddubs v5,v4,v0\n"
+	"" : : "b" (ref_block), "b" (i0));
+	for (i = 0; i < 16; i++) {
+		asm(""
+			"lvx v0,%1,%3\n"
+			"lvx v1,%2,%3\n"
+			"lvx v2,%1,%4\n"
+			"lvx v3,%2,%4\n"
+			"vperm v6,v0,v2,v4\n"
+			"vperm v7,v0,v2,v5\n"
+			"vperm v8,v1,v3,v4\n"
+			"vperm v9,v1,v3,v5\n"
+			"vavgub v6,v6,v7\n"
+			"vavgub v8,v8,v9\n"
+			"lvx v10,%0,%3\n"
+			"vavgub v6,v6,v8\n"
+			"vavgub v6,v6,v10\n"
+			"stvx v6,%0,%3\n"
+		"" : : "b" (curr_block), "b" (ref_block),
+		      "b" (ref_block + field_stride),
+		      "b" (i0), "b" (i1));
+		i0 += frame_stride, i1 += frame_stride;
+	}
+}
+
+void 
+mlib_VideoInterpAveXY_U8_U8_16x8(uint8_t *curr_block,
+                                 const uint8_t *ref_block,
+                                 int32_t frame_stride,
+                                 int32_t field_stride)
+{
+	int i;
+	int i0 = 0, i1 = 16;
+
+	ASSERT(((int)curr_block & 15) == 0);
+
+	asm(""
+		"vspltisb v0,1\n"
+		"lvsl v4,%0,%1\n"
+		"vaddubs v5,v4,v0\n"
+	"" : : "b" (ref_block), "b" (i0));
+	for (i = 0; i < 8; i++) {
+		asm(""
+			"lvx v0,%1,%3\n"
+			"lvx v1,%2,%3\n"
+			"lvx v2,%1,%4\n"
+			"lvx v3,%2,%4\n"
+			"vperm v6,v0,v2,v4\n"
+			"vperm v7,v0,v2,v5\n"
+			"vperm v8,v1,v3,v4\n"
+			"vperm v9,v1,v3,v5\n"
+			"vavgub v6,v6,v7\n"
+			"vavgub v8,v8,v9\n"
+			"lvx v10,%0,%3\n"
+			"vavgub v6,v6,v8\n"
+			"vavgub v6,v6,v10\n"
+			"stvx v6,%0,%3\n"
+		"" : : "b" (curr_block), "b" (ref_block),
+		      "b" (ref_block + field_stride),
+		      "b" (i0), "b" (i1));
+		i0 += frame_stride, i1 += frame_stride;
+	}
+}
+
+void 
+mlib_VideoInterpAveXY_U8_U8_8x8(uint8_t *curr_block,
+				const uint8_t *ref_block,
+				int32_t frame_stride,
+				int32_t field_stride)
+{
+	mlib_VideoInterpAveXY_U8_U8 (curr_block, ref_block, 8, 8, frame_stride, field_stride);
+}
+
+void 
+mlib_VideoInterpAveXY_U8_U8_8x4(uint8_t *curr_block,
+				const uint8_t *ref_block,
+				int32_t frame_stride,
+				int32_t field_stride)
+{
+	mlib_VideoInterpAveXY_U8_U8 (curr_block, ref_block, 8, 4, frame_stride, field_stride);
+}
+
+void
+mlib_VideoInterpX_U8_U8_16x16(uint8_t *curr_block,
+			      const uint8_t *ref_block,
+			      int32_t frame_stride,
+			      int32_t field_stride)
+{
+	int i;
+	int i0 = 0, i1 = 16;
+
+	ASSERT(((int)curr_block & 15) == 0);
+
+	asm(""
+		"vspltisb v0,1\n"
+		"lvsl v2,%0,%1\n"
+		"vaddubs v3,v2,v0\n"
+	"" : : "b" (ref_block), "b" (i0), "b" (i1));
+	for (i = 0; i < 16; i++) {
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"vperm v4,v0,v1,v2\n"
+			"vperm v5,v0,v1,v3\n"
+			"vavgub v4,v4,v5\n"
+			"stvx v4,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block),
+		      "b" (i0), "b" (i1));
+		i0 += frame_stride, i1 += frame_stride;
+	}
+}
+
+void 
+mlib_VideoInterpX_U8_U8_16x8(uint8_t *curr_block,
+			     const uint8_t *ref_block,
+			     int32_t frame_stride,
+			     int32_t field_stride)
+{
+	int i;
+	int i0 = 0, i1 = 16;
+
+	ASSERT(((int)curr_block & 15) == 0);
+
+	asm(""
+		"vspltisb v0,1\n"
+		"lvsl v2,%0,%1\n"
+		"vaddubs v3,v2,v0\n"
+	"" : : "b" (ref_block), "b" (i0), "b" (i1));
+	for (i = 0; i < 8; i++) {
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"vperm v4,v0,v1,v2\n"
+			"vperm v5,v0,v1,v3\n"
+			"vavgub v4,v4,v5\n"
+			"stvx v4,%0,%2\n"
+		"" : : "b" (curr_block), "b" (ref_block),
+		      "b" (i0), "b" (i1));
+		i0 += frame_stride, i1 += frame_stride;
+	}
+}
+
+void 
+mlib_VideoInterpX_U8_U8_8x8(uint8_t *curr_block,
+			    const uint8_t *ref_block,
+			    int32_t frame_stride,
+			    int32_t field_stride)
+{
+	int i;
+	const int i0 = 0, i1 = 16, i2 = 4;
+
+	ASSERT(((int)curr_block & 7) == 0);
+
+	asm(""
+		"vspltisb v0,1\n"
+		"lvsl v2,%1,%2\n"
+		"lvsr v3,%0,%2\n"
+		"lvsl v4,%1,%3\n"
+		"lvsr v5,%0,%3\n"
+		"vperm v2,v2,v2,v3\n"
+		"vperm v4,v4,v4,v5\n"
+		"vaddubs v3,v2,v0\n"
+		"vaddubs v5,v4,v0\n"
+	"" : : "b" (curr_block), "b" (ref_block),
+	      "b" (i0), "b" (i0 + frame_stride));
+	for (i = 0; i < 4; i++) {
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"vperm v6,v0,v1,v2\n"
+			"vperm v7,v0,v1,v3\n"
+			"vavgub v6,v6,v7\n"
+			"stvewx v6,%0,%2\n"
+			"stvewx v6,%0,%4\n"
+		"" : : "b" (curr_block), "b" (ref_block),
+		      "b" (i0), "b" (i1), "b" (i2));
+		curr_block += frame_stride, ref_block += frame_stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"vperm v6,v0,v1,v4\n"
+			"vperm v7,v0,v1,v5\n"
+			"vavgub v6,v6,v7\n"
+			"stvewx v6,%0,%2\n"
+			"stvewx v6,%0,%4\n"
+		"" : : "b" (curr_block), "b" (ref_block),
+		      "b" (i0), "b" (i1), "b" (i2));
+		curr_block += frame_stride, ref_block += frame_stride;
+	}
+}
+
+void 
+mlib_VideoInterpX_U8_U8_8x4(uint8_t *curr_block,
+			    const uint8_t *ref_block,
+			    int32_t frame_stride,
+			    int32_t field_stride)
+{
+	int i;
+	const int i0 = 0, i1 = 16, i2 = 4;
+
+	ASSERT(((int)curr_block & 7) == 0);
+
+	asm(""
+		"vspltisb v0,1\n"
+		"lvsl v2,%1,%2\n"
+		"lvsr v3,%0,%2\n"
+		"lvsl v4,%1,%3\n"
+		"lvsr v5,%0,%3\n"
+		"vperm v2,v2,v2,v3\n"
+		"vperm v4,v4,v4,v5\n"
+		"vaddubs v3,v2,v0\n"
+		"vaddubs v5,v4,v0\n"
+	"" : : "b" (curr_block), "b" (ref_block),
+	      "b" (i0), "b" (i0 + frame_stride));
+	for (i = 0; i < 2; i++) {
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"vperm v6,v0,v1,v2\n"
+			"vperm v7,v0,v1,v3\n"
+			"vavgub v6,v6,v7\n"
+			"stvewx v6,%0,%2\n"
+			"stvewx v6,%0,%4\n"
+		"" : : "b" (curr_block), "b" (ref_block),
+		      "b" (i0), "b" (i1), "b" (i2));
+		curr_block += frame_stride, ref_block += frame_stride;
+		asm(""
+			"lvx v0,%1,%2\n"
+			"lvx v1,%1,%3\n"
+			"vperm v6,v0,v1,v4\n"
+			"vperm v7,v0,v1,v5\n"
+			"vavgub v6,v6,v7\n"
+			"stvewx v6,%0,%2\n"
+			"stvewx v6,%0,%4\n"
+		"" : : "b" (curr_block), "b" (ref_block),
+		      "b" (i0), "b" (i1), "b" (i2));
+		curr_block += frame_stride, ref_block += frame_stride;
+	}
+}
+
+void
+mlib_VideoInterpY_U8_U8_16x16(uint8_t *curr_block,
+			      const uint8_t *ref_block,
+			      int32_t frame_stride,
+			      int32_t field_stride)
+{
+	int i;
+
+	ASSERT(((int)curr_block & 15) == 0);
+
+	if (((int)ref_block & 15) != 0) {
+		int i0 = 0, i1 = 16;
+		asm(""
+			"lvsl v4,%0,%1\n"
+		"" : : "b" (ref_block), "b" (i0));
+		for (i = 0; i < 16; i++) {
+			asm(""
+				"lvx v0,%1,%3\n"
+				"lvx v1,%1,%4\n"
+				"lvx v2,%2,%3\n"
+				"lvx v3,%2,%4\n"
+				"vperm v5,v0,v1,v4\n"
+				"vperm v6,v2,v3,v4\n"
+				"vavgub v5,v5,v6\n"
+				"stvx v5,%0,%3\n"
+			"" : : "b" (curr_block), "b" (ref_block),
+			      "b" (ref_block + field_stride),
+			      "b" (i0), "b" (i1));
+			i0 += frame_stride, i1 += frame_stride;
+		}
+	} else {
+		int i0 = 0;
+		for (i = 0; i < 16; i++) {
+			asm(""
+				"lvx v0,%1,%3\n"
+				"lvx v1,%2,%3\n"
+				"vavgub v0,v0,v1\n"
+				"stvx v0,%0,%3\n"
+			"" : : "b" (curr_block), "b" (ref_block),
+			      "b" (ref_block + field_stride),
+			      "b" (i0));
+			i0 += frame_stride;
+		}
+	}
+}
+
+void 
+mlib_VideoInterpY_U8_U8_16x8(uint8_t *curr_block,
+			     const uint8_t *ref_block,
+			     int32_t frame_stride,
+			     int32_t field_stride)
+{
+	int i;
+
+	ASSERT(((int)curr_block & 15) == 0);
+
+	if (((int)ref_block & 15) != 0) {
+		int i0 = 0, i1 = 16;
+		asm(""
+			"lvsl v4,%0,%1\n"
+		"" : : "b" (ref_block), "b" (i0));
+		for (i = 0; i < 8; i++) {
+			asm(""
+				"lvx v0,%1,%3\n"
+				"lvx v1,%1,%4\n"
+				"lvx v2,%2,%3\n"
+				"lvx v3,%2,%4\n"
+				"vperm v5,v0,v1,v4\n"
+				"vperm v6,v2,v3,v4\n"
+				"vavgub v5,v5,v6\n"
+				"stvx v5,%0,%3\n"
+			"" : : "b" (curr_block), "b" (ref_block),
+			      "b" (ref_block + field_stride),
+			      "b" (i0), "b" (i1));
+			i0 += frame_stride, i1 += frame_stride;
+		}
+	} else {
+		int i0 = 0;
+		for (i = 0; i < 8; i++) {
+			asm(""
+				"lvx v0,%1,%3\n"
+				"lvx v1,%2,%3\n"
+				"vavgub v0,v0,v1\n"
+				"stvx v0,%0,%3\n"
+			"" : : "b" (curr_block), "b" (ref_block),
+			      "b" (ref_block + field_stride),
+			      "b" (i0));
+			i0 += frame_stride;
+		}
+	}
+}
+
+void 
+mlib_VideoInterpY_U8_U8_8x8(uint8_t *curr_block,
+			    const uint8_t *ref_block,
+			    int32_t frame_stride,
+			    int32_t field_stride)
+{
+	int i;
+
+	ASSERT(((int)curr_block & 7) == 0);
+
+	if (((((int)ref_block ^ (int)curr_block) | field_stride) & 15) != 0) {
+		const int i0 = 0, i1 = 16, i2 = 4;
+		asm(""
+			"lvsl v4,%1,%3\n"
+			"lvsl v5,%1,%4\n"
+			"lvsl v6,%2,%3\n"
+			"lvsl v7,%2,%4\n"
+			"lvsr v8,%0,%3\n"
+			"lvsr v9,%0,%4\n"
+			"vperm v4,v4,v4,v8\n"
+			"vperm v5,v5,v5,v9\n"
+			"vperm v6,v6,v6,v8\n"
+			"vperm v7,v7,v7,v9\n"
+		"" : : "b" (curr_block), "b" (ref_block),
+		      "b" (ref_block + field_stride),
+		      "b" (i0), "b" (i0 + frame_stride));
+		for (i = 0; i < 4; i++) {
+			asm(""
+				"lvx v0,%1,%3\n"
+				"lvx v1,%1,%4\n"
+				"lvx v2,%2,%3\n"
+				"lvx v3,%2,%4\n"
+				"vperm v8,v0,v1,v4\n"
+				"vperm v9,v2,v3,v6\n"
+				"vavgub v8,v8,v9\n"
+				"stvewx v8,%0,%3\n"
+				"stvewx v8,%0,%5\n"
+			"" : : "b" (curr_block), "b" (ref_block),
+			      "b" (ref_block + field_stride),
+			      "b" (i0), "b" (i1), "b" (i2));
+			curr_block += frame_stride, ref_block += frame_stride;
+			asm(""
+				"lvx v0,%1,%3\n"
+				"lvx v1,%1,%4\n"
+				"lvx v2,%2,%3\n"
+				"lvx v3,%2,%4\n"
+				"vperm v8,v0,v1,v5\n"
+				"vperm v9,v2,v3,v7\n"
+				"vavgub v8,v8,v9\n"
+				"stvewx v8,%0,%3\n"
+				"stvewx v8,%0,%5\n"
+			"" : : "b" (curr_block), "b" (ref_block),
+			      "b" (ref_block + field_stride),
+			      "b" (i0), "b" (i1), "b" (i2));
+			curr_block += frame_stride, ref_block += frame_stride;
+		}
+	} else {
+		int i0 = 0, i1 = 4;
+		for (i = 0; i < 8; i++) {
+			asm(""
+				"lvx v0,%1,%3\n"
+				"lvx v1,%2,%3\n"
+				"vavgub v0,v0,v1\n"
+				"stvewx v0,%0,%3\n"
+				"stvewx v0,%0,%4\n"
+			"" : : "b" (curr_block), "b" (ref_block),
+			      "b" (ref_block + field_stride),
+			      "b" (i0), "b" (i1));
+			i0 += frame_stride, i1 += frame_stride;
+		}
+	}
+}
+
+void 
+mlib_VideoInterpY_U8_U8_8x4(uint8_t *curr_block,
+			    const uint8_t *ref_block,
+			    int32_t frame_stride,
+			    int32_t field_stride)
+{
+	int i;
+
+	ASSERT(((int)curr_block & 7) == 0);
+
+	if (((((int)ref_block ^ (int)curr_block) | field_stride) & 15) != 0) {
+		const int i0 = 0, i1 = 16, i2 = 4;
+		asm(""
+			"lvsl v4,%1,%3\n"
+			"lvsl v5,%1,%4\n"
+			"lvsl v6,%2,%3\n"
+			"lvsl v7,%2,%4\n"
+			"lvsr v8,%0,%3\n"
+			"lvsr v9,%0,%4\n"
+			"vperm v4,v4,v4,v8\n"
+			"vperm v5,v5,v5,v9\n"
+			"vperm v6,v6,v6,v8\n"
+			"vperm v7,v7,v7,v9\n"
+		"" : : "b" (curr_block), "b" (ref_block),
+		      "b" (ref_block + field_stride),
+		      "b" (i0), "b" (i0 + frame_stride));
+		for (i = 0; i < 2; i++) {
+			asm(""
+				"lvx v0,%1,%3\n"
+				"lvx v1,%1,%4\n"
+				"lvx v2,%2,%3\n"
+				"lvx v3,%2,%4\n"
+				"vperm v8,v0,v1,v4\n"
+				"vperm v9,v2,v3,v6\n"
+				"vavgub v8,v8,v9\n"
+				"stvewx v8,%0,%3\n"
+				"stvewx v8,%0,%5\n"
+			"" : : "b" (curr_block), "b" (ref_block),
+			      "b" (ref_block + field_stride),
+			      "b" (i0), "b" (i1), "b" (i2));
+			curr_block += frame_stride, ref_block += frame_stride;
+			asm(""
+				"lvx v0,%1,%3\n"
+				"lvx v1,%1,%4\n"
+				"lvx v2,%2,%3\n"
+				"lvx v3,%2,%4\n"
+				"vperm v8,v0,v1,v5\n"
+				"vperm v9,v2,v3,v7\n"
+				"vavgub v8,v8,v9\n"
+				"stvewx v8,%0,%3\n"
+				"stvewx v8,%0,%5\n"
+			"" : : "b" (curr_block), "b" (ref_block),
+			      "b" (ref_block + field_stride),
+			      "b" (i0), "b" (i1), "b" (i2));
+			curr_block += frame_stride, ref_block += frame_stride;
+		}
+	} else {
+		int i0 = 0, i1 = 4;
+		for (i = 0; i < 4; i++) {
+			asm(""
+				"lvx v0,%1,%3\n"
+				"lvx v1,%2,%3\n"
+				"vavgub v0,v0,v1\n"
+				"stvewx v0,%0,%3\n"
+				"stvewx v0,%0,%4\n"
+			"" : : "b" (curr_block), "b" (ref_block),
+			      "b" (ref_block + field_stride),
+			      "b" (i0), "b" (i1));
+			i0 += frame_stride, i1 += frame_stride;
+		}
+	}
+}
+
+void
+mlib_VideoInterpXY_U8_U8_16x16(uint8_t *curr_block,
+			       const uint8_t *ref_block,
+			       int32_t frame_stride,
+			       int32_t field_stride)
+{
+	int i;
+	int i0 = 0, i1 = 16;
+
+	ASSERT(((int)curr_block & 15) == 0);
+
+	asm(""
+		"vspltisb v0,1\n"
+		"lvsl v4,%0,%1\n"
+		"vaddubs v5,v4,v0\n"
+	"" : : "b" (ref_block), "b" (i0));
+	for (i = 0; i < 16; i++) {
+		asm(""
+			"lvx v0,%1,%3\n"
+			"lvx v1,%2,%3\n"
+			"lvx v2,%1,%4\n"
+			"lvx v3,%2,%4\n"
+			"vperm v6,v0,v2,v4\n"
+			"vperm v7,v0,v2,v5\n"
+			"vperm v8,v1,v3,v4\n"
+			"vperm v9,v1,v3,v5\n"
+			"vavgub v6,v6,v7\n"
+			"vavgub v8,v8,v9\n"
+			"vavgub v6,v6,v8\n"
+			"stvx v6,%0,%3\n"
+		"" : : "b" (curr_block), "b" (ref_block),
+		      "b" (ref_block + field_stride),
+		      "b" (i0), "b" (i1));
+		i0 += frame_stride, i1 += frame_stride;
+	}
+}
+
+void 
+mlib_VideoInterpXY_U8_U8_16x8(uint8_t *curr_block,
+			      const uint8_t *ref_block,
+			      int32_t frame_stride,
+			      int32_t field_stride)
+{
+	int i;
+	int i0 = 0, i1 = 16;
+
+	ASSERT(((int)curr_block & 15) == 0);
+
+	asm(""
+		"vspltisb v0,1\n"
+		"lvsl v4,%0,%1\n"
+		"vaddubs v5,v4,v0\n"
+	"" : : "b" (ref_block), "b" (i0));
+	for (i = 0; i < 8; i++) {
+		asm(""
+			"lvx v0,%1,%3\n"
+			"lvx v1,%2,%3\n"
+			"lvx v2,%1,%4\n"
+			"lvx v3,%2,%4\n"
+			"vperm v6,v0,v2,v4\n"
+			"vperm v7,v0,v2,v5\n"
+			"vperm v8,v1,v3,v4\n"
+			"vperm v9,v1,v3,v5\n"
+			"vavgub v6,v6,v7\n"
+			"vavgub v8,v8,v9\n"
+			"vavgub v6,v6,v8\n"
+			"stvx v6,%0,%3\n"
+		"" : : "b" (curr_block), "b" (ref_block),
+		      "b" (ref_block + field_stride),
+		      "b" (i0), "b" (i1));
+		i0 += frame_stride, i1 += frame_stride;
+	}
+}
+
+void 
+mlib_VideoInterpXY_U8_U8_8x8(uint8_t *curr_block,
+			     const uint8_t *ref_block,
+			     int32_t frame_stride,
+			     int32_t field_stride)
+{
+	mlib_VideoInterpXY_U8_U8 (curr_block, ref_block, 8, 8, frame_stride, field_stride);
+}
+
+void 
+mlib_VideoInterpXY_U8_U8_8x4(uint8_t *curr_block,
+			     const uint8_t *ref_block,
+			     int32_t frame_stride,
+			     int32_t field_stride)
+{
+	mlib_VideoInterpXY_U8_U8 (curr_block, ref_block, 8, 4, frame_stride, field_stride);
+}
+
+void mlib_ClearCoeffs(int16_t *coeffs)
+{
+	asm(""
+		"vspltish v0,0\n"
+		"stvx v0,%0,%1\n"
+		"addi %1,%1,32\n"
+		"stvx v0,%0,%2\n"
+		"addi %2,%2,32\n"
+		"stvx v0,%0,%1\n"
+		"addi %1,%1,32\n"
+		"stvx v0,%0,%2\n"
+		"addi %2,%2,32\n"
+		"stvx v0,%0,%1\n"
+		"addi %1,%1,32\n"
+		"stvx v0,%0,%2\n"
+		"addi %2,%2,32\n"
+		"stvx v0,%0,%1\n"
+		"stvx v0,%0,%2\n"
+	"" : : "b" (coeffs), "b" (0), "b" (16));
+}
+
+
+/***************************************************************
+ *
+ * Copyright:   (c) Copyright Motorola Inc. 1998
+ *
+ * Date:        April 17, 1998
+ *
+ * Function:    IDCT
+ *
+ * Description: Scaled Chen (III) algorithm for IDCT
+ *              Arithmetic is 16-bit fixed point.
+ *
+ * Inputs:      input - Pointer to input data (short), which
+ *                      must be between -2048 to +2047.
+ *                      It is assumed that the allocated array
+ *                      has been 128-bit aligned and contains
+ *                      8x8 short elements.
+ *
+ * Outputs:     output - Pointer to output area for the transfored
+ *                       data. The output values are between -255
+ *                       and 255 . It is assumed that a 128-bit
+ *                       aligned 8x8 array of short has been
+ *                       pre-allocated.
+ *
+ * Return:      None
+ *
+ ***************************************************************/
+
+static const int16_t SpecialConstants[8] __attribute__ ((aligned (16))) = {
+	23170, 13573, 6518, 21895, -23170, -21895, 32, 0 };
+
+static const int16_t PreScale[64] __attribute__ ((aligned (16))) = {
+	16384, 22725, 21407, 19266, 16384, 19266, 21407, 22725, 
+	22725, 31521, 29692, 26722, 22725, 26722, 29692, 31521, 
+	21407, 29692, 27969, 25172, 21407, 25172, 27969, 29692, 
+	19266, 26722, 25172, 22654, 19266, 22654, 25172, 26722, 
+};
+
+void mlib_VideoIDCTAdd_U8_S16(uint8_t *output, const int16_t *input, int32_t stride) 
+{
+	ASSERT(((int)output & 7) == 0);
+
+	/* Load constants, input data, and prescale factors.  Do prescaling. */
+	asm(""
+		"vspltish        v31,0\n"
+		"lvx		v24,0,%1\n"
+		"vspltish	v23,4\n"
+\
+		"addi		r5,0,0\n"
+		"vsplth		v29,v24,4\n"
+		"lvx		v0,%0,r5\n"
+		"addi		r6,0,16\n"
+		"vsplth		v28,v24,3\n"
+		"lvx		v16,%2,r5\n"
+		"addi		r7,0,32\n"
+		"vsplth		v27,v24,2\n"
+		"lvx		v1,%0,r6\n"
+		"addi		r8,0,48\n"
+		"vsplth		v26,v24,1\n"
+		"lvx		v17,%2,r6\n"
+		"addi		r5,0,64\n"
+		"vsplth		v25,v24,0\n"
+		"lvx		v2,%0,r7\n"
+		"addi		r6,0,80\n"
+		"vslh		v0,v0,v23\n"
+		"lvx		v18,%2,r7\n"
+		"addi		r7,0,96\n"
+		"vslh		v1,v1,v23\n"
+		"lvx		v3,%0,r8\n"
+		"vslh		v2,v2,v23\n"
+		"lvx		v19,%2,r8\n"
+		"addi		r8,0,112\n"
+		"vslh		v3,v3,v23\n"
+		"lvx		v4,%0,r5\n"
+		"vsplth		v30,v24,5\n"
+		"lvx		v5,%0,r6\n"
+		"vsplth		v24,v24,6\n"
+		"lvx		v6,%0,r7\n"
+		"vslh		v4,v4,v23\n"
+		"lvx		v7,%0,r8\n"
+		"vslh		v5,v5,v23\n"
+		"vmhraddshs	v0,v0,v16,v31\n"
+		"vslh		v6,v6,v23\n"
+		"vmhraddshs	v4,v4,v16,v31\n"
+		"vslh		v7,v7,v23\n"
+	"" : : "b" (input), "b" (SpecialConstants), "b" (PreScale)
+	  : "cc", "r5", "r6", "r7", "r8", "memory");
+
+	asm(""
+		"vmhraddshs	v1,v1,v17,v31\n"
+		"vmhraddshs	v5,v5,v19,v31\n"
+		"vmhraddshs	v2,v2,v18,v31\n"
+		"vmhraddshs	v6,v6,v18,v31\n"
+		"vmhraddshs	v3,v3,v19,v31\n"
+		"vmhraddshs	v7,v7,v17,v31\n"
+\
+\
+		"vmhraddshs      v11,v27,v7,v1\n"
+		"vmhraddshs      v19,v27,v1,v31\n"
+		"vmhraddshs      v12,v26,v6,v2\n"
+		"vmhraddshs      v13,v30,v3,v5\n"
+		"vmhraddshs      v17,v28,v5,v3\n"
+		"vsubshs		v18,v19,v7\n"
+	"");
+
+	/* Second stage. */
+	asm(""
+		"vmhraddshs      v19,v26,v2,v31\n"
+		"vaddshs		v15,v0,v4\n"
+		"vsubshs		v10,v0,v4\n"
+		"vsubshs		v14,v19,v6\n"
+		"vaddshs		v16,v18,v13\n"
+		"vsubshs		v13,v18,v13\n"
+		"vsubshs		v18,v11,v17\n"
+		"vaddshs		v11,v11,v17\n"
+	"");
+
+	/* Third stage. */
+	asm(""
+		"vaddshs		v17,v15,v12\n"
+		"vsubshs		v12,v15,v12\n"
+		"vaddshs		v15,v10,v14\n"
+		"vsubshs		v10,v10,v14\n"
+		"vsubshs		v14,v18,v13\n"
+		"vaddshs		v13,v18,v13\n"
+	"");
+
+	/* Fourth stage. */
+	asm(""
+		"vmhraddshs      v2,v25,v14,v10\n"
+		"vsubshs		v4,v12,v16\n"
+		"vmhraddshs      v1,v25,v13,v15\n"
+		"vaddshs		v0,v17,v11\n"
+		"vmhraddshs      v5,v29,v14,v10\n"
+		"vmrghh  v8,v0,v4\n"
+		"vaddshs		v3,v12,v16\n"
+		"vmrglh  v9,v0,v4\n"
+		"vmhraddshs      v6,v29,v13,v15\n"
+		"vmrghh  v10,v1,v5\n"
+		"vsubshs		v7,v17,v11\n"
+	"");
+
+	/* Transpose the matrix again. */
+	asm(""
+		"vmrglh  v11,v1,v5\n"
+		"vmrghh  v12,v2,v6\n"
+		"vmrglh  v13,v2,v6\n"
+		"vmrghh  v14,v3,v7\n"
+		"vmrglh  v15,v3,v7\n"
+\
+		"vmrghh  v16,v8,v12\n"
+		"vmrglh  v17,v8,v12\n"
+		"vmrghh  v18,v9,v13\n"
+		"vmrglh  v19,v9,v13\n"
+		"vmrghh  v20,v10,v14\n"
+		"vmrglh  v21,v10,v14\n"
+		"vmrghh  v22,v11,v15\n"
+		"vmrglh  v23,v11,v15\n"
+\
+		"vmrglh  v1,v16,v20\n"
+		"vmrglh  v7,v19,v23\n"
+		"vmrglh  v3,v17,v21\n"
+		"vmrghh  v2,v17,v21\n"
+		"vmhraddshs      v11,v27,v7,v1\n"
+		"vmrghh  v6,v19,v23\n"
+		"vmhraddshs      v19,v27,v1,v31\n"
+		"vmrglh  v5,v18,v22\n"
+		"vmhraddshs      v12,v26,v6,v2\n"
+		"vmrghh  v0,v16,v20\n"
+		"vmhraddshs      v13,v30,v3,v5\n"
+		"vmrghh  v4,v18,v22\n"
+		"vmhraddshs      v17,v28,v5,v3\n"
+		"vsubshs		v18,v19,v7\n"
+	"");
+
+	/* Add a rounding bias for the final shift.  v0 is added into every
+	   vector, so the bias propagates from here. */
+	asm(""
+		"vaddshs	v0,v0,v24\n"
+	"");
+
+	/* Second stage. */
+	asm(""
+		"vmhraddshs      v19,v26,v2,v31\n"
+		"vaddshs		v15,v0,v4\n"
+		"vsubshs		v10,v0,v4\n"
+		"vsubshs		v14,v19,v6\n"
+		"vaddshs		v16,v18,v13\n"
+		"vsubshs		v13,v18,v13\n"
+		"vsubshs		v18,v11,v17\n"
+		"vaddshs		v11,v11,v17\n"
+	"");
+
+	/* Third stage. */
+	asm(""
+		"vaddshs		v17,v15,v12\n"
+		"vsubshs		v12,v15,v12\n"
+		"vaddshs		v15,v10,v14\n"
+		"vsubshs		v10,v10,v14\n"
+		"vsubshs		v14,v18,v13\n"
+		"vaddshs		v13,v18,v13\n"
+	"");
+
+	/* Fourth stage. */
+	asm(""
+		"vmhraddshs	v2,v25,v14,v10\n"
+		"vsubshs		v4,v12,v16\n"
+		"vmhraddshs	v1,v25,v13,v15\n"
+		"vaddshs		v0,v17,v11\n"
+		"vmhraddshs	v5,v29,v14,v10\n"
+		"vaddshs		v3,v12,v16\n"
+		"vspltish	v23,6\n"
+		"vmhraddshs	v6,v29,v13,v15\n"
+		"vsubshs		v7,v17,v11\n"
+	"");
+
+	/* Load and permutations for the reference data we're adding to. */
+	asm(""
+		"lvsl		v17,%0,%1\n"
+		"vspltisb	v19,-1\n"
+		"lvsl		v18,%0,%2\n"
+		"vmrghb		v17,v19,v17\n"
+		"vmrghb		v18,v19,v18\n"
+	"" : : "b" (output), "b" (0), "b" (0+stride));
+
+	/* Copy out each 8 values, adding to the existing frame. */
+	asm(""
+		"vsrah		v0,v0,v23\n"
+		"lvx		v8,%0,%1\n"
+		"vsrah		v1,v1,v23\n"
+		"lvx		v9,%0,%3\n"
+		"vperm		v8,v8,v31,v17\n"
+		"vperm		v9,v9,v31,v18\n"
+		"vaddshs		v0,v0,v8\n"
+		"vaddshs		v1,v1,v9\n"
+		"vmaxsh		v0,v0,v31\n"
+		"vmaxsh		v1,v1,v31\n"
+		"vpkuhus		v0,v0,v0\n"
+		"stvewx		v0,%0,%1\n"
+		"vpkuhus		v1,v1,v1\n"
+		"stvewx		v0,%0,%2\n"
+		"stvewx		v1,%0,%3\n"
+		"stvewx		v1,%0,%4\n"
+	"" : : "b" (output), "b" (0), "b" (4), "b" (0+stride), "b" (4+stride));
+	output += stride<<1;
+	asm(""
+		"vsrah		v2,v2,v23\n"
+		"lvx		v10,%0,%1\n"
+		"vsrah		v3,v3,v23\n"
+		"lvx		v11,%0,%3\n"
+		"vperm		v10,v10,v31,v17\n"
+		"vperm		v11,v11,v31,v18\n"
+		"vaddshs		v2,v2,v10\n"
+		"vaddshs		v3,v3,v11\n"
+		"vmaxsh		v2,v2,v31\n"
+		"vmaxsh		v3,v3,v31\n"
+		"vpkuhus		v2,v2,v2\n"
+		"stvewx		v2,%0,%1\n"
+		"vpkuhus		v3,v3,v3\n"
+		"stvewx		v2,%0,%2\n"
+		"stvewx		v3,%0,%3\n"
+		"stvewx		v3,%0,%4\n"
+	"" : : "b" (output), "b" (0), "b" (4), "b" (0+stride), "b" (4+stride));
+	output += stride<<1;
+	asm(""
+		"vsrah		v4,v4,v23\n"
+		"lvx		v12,%0,%1\n"
+		"vsrah		v5,v5,v23\n"
+		"lvx		v13,%0,%3\n"
+		"vperm		v12,v12,v31,v17\n"
+		"vperm		v13,v13,v31,v18\n"
+		"vaddshs		v4,v4,v12\n"
+		"vaddshs		v5,v5,v13\n"
+		"vmaxsh		v4,v4,v31\n"
+		"vmaxsh		v5,v5,v31\n"
+		"vpkuhus		v4,v4,v4\n"
+		"stvewx		v4,%0,%1\n"
+		"vpkuhus		v5,v5,v5\n"
+		"stvewx		v4,%0,%2\n"
+		"stvewx		v5,%0,%3\n"
+		"stvewx		v5,%0,%4\n"
+	"" : : "b" (output), "b" (0), "b" (4), "b" (0+stride), "b" (4+stride));
+	output += stride<<1;
+	asm(""
+		"vsrah		v6,v6,v23\n"
+		"lvx		v14,%0,%1\n"
+		"vsrah		v7,v7,v23\n"
+		"lvx		v15,%0,%3\n"
+		"vperm		v14,v14,v31,v17\n"
+		"vperm		v15,v15,v31,v18\n"
+		"vaddshs		v6,v6,v14\n"
+		"vaddshs		v7,v7,v15\n"
+		"vmaxsh		v6,v6,v31\n"
+		"vmaxsh		v7,v7,v31\n"
+		"vpkuhus		v6,v6,v6\n"
+		"stvewx		v6,%0,%1\n"
+		"vpkuhus		v7,v7,v7\n"
+		"stvewx		v6,%0,%2\n"
+		"stvewx		v7,%0,%3\n"
+		"stvewx		v7,%0,%4\n"
+	"" : : "b" (output), "b" (0), "b" (4), "b" (0+stride), "b" (4+stride));
+}  
+
+void mlib_VideoIDCT8x8_U8_S16(uint8_t *output, const int16_t *input, int32_t stride)
+{
+	ASSERT(((int)output & 7) == 0);
+
+	/* Load constants, input data, and prescale factors.  Do prescaling. */
+	asm(""
+		"vspltish        v31,0\n"
+		"lvx		v24,0,%1\n"
+		"vspltish	v23,4\n"
+\
+		"addi		r5,0,0\n"
+		"vsplth		v29,v24,4\n"
+		"lvx		v0,%0,r5\n"
+		"addi		r6,0,16\n"
+		"vsplth		v28,v24,3\n"
+		"lvx		v16,%2,r5\n"
+		"addi		r7,0,32\n"
+		"vsplth		v27,v24,2\n"
+		"lvx		v1,%0,r6\n"
+		"addi		r8,0,48\n"
+		"vsplth		v26,v24,1\n"
+		"lvx		v17,%2,r6\n"
+		"addi		r5,0,64\n"
+		"vsplth		v25,v24,0\n"
+		"lvx		v2,%0,r7\n"
+		"addi		r6,0,80\n"
+		"vslh		v0,v0,v23\n"
+		"lvx		v18,%2,r7\n"
+		"addi		r7,0,96\n"
+		"vslh		v1,v1,v23\n"
+		"lvx		v3,%0,r8\n"
+		"vslh		v2,v2,v23\n"
+		"lvx		v19,%2,r8\n"
+		"addi		r8,0,112\n"
+		"vslh		v3,v3,v23\n"
+		"lvx		v4,%0,r5\n"
+		"vsplth		v30,v24,5\n"
+		"lvx		v5,%0,r6\n"
+		"vsplth		v24,v24,6\n"
+		"lvx		v6,%0,r7\n"
+		"vslh		v4,v4,v23\n"
+		"lvx		v7,%0,r8\n"
+		"vslh		v5,v5,v23\n"
+		"vmhraddshs	v0,v0,v16,v31\n"
+		"vslh		v6,v6,v23\n"
+		"vmhraddshs	v4,v4,v16,v31\n"
+		"vslh		v7,v7,v23\n"
+	"" : : "b" (input), "b" (SpecialConstants), "b" (PreScale)
+	  : "cc", "r5", "r6", "r7", "r8", "memory");
+
+	asm(""
+		"vmhraddshs	v1,v1,v17,v31\n"
+		"vmhraddshs	v5,v5,v19,v31\n"
+		"vmhraddshs	v2,v2,v18,v31\n"
+		"vmhraddshs	v6,v6,v18,v31\n"
+		"vmhraddshs	v3,v3,v19,v31\n"
+		"vmhraddshs	v7,v7,v17,v31\n"
+\
+		"vmhraddshs      v11,v27,v7,v1\n"
+		"vmhraddshs      v19,v27,v1,v31\n"
+		"vmhraddshs      v12,v26,v6,v2\n"
+		"vmhraddshs      v13,v30,v3,v5\n"
+		"vmhraddshs      v17,v28,v5,v3\n"
+		"vsubshs		v18,v19,v7\n"
+	"");
+
+	/* Second stage. */
+	asm(""
+		"vmhraddshs      v19,v26,v2,v31\n"
+		"vaddshs		v15,v0,v4\n"
+		"vsubshs		v10,v0,v4\n"
+		"vsubshs		v14,v19,v6\n"
+		"vaddshs		v16,v18,v13\n"
+		"vsubshs		v13,v18,v13\n"
+		"vsubshs		v18,v11,v17\n"
+		"vaddshs		v11,v11,v17\n"
+	"");
+
+	/* Third stage. */
+	asm(""
+		"vaddshs		v17,v15,v12\n"
+		"vsubshs		v12,v15,v12\n"
+		"vaddshs		v15,v10,v14\n"
+		"vsubshs		v10,v10,v14\n"
+		"vsubshs		v14,v18,v13\n"
+		"vaddshs		v13,v18,v13\n"
+	"");
+
+	/* Fourth stage. */
+	asm(""
+		"vmhraddshs      v2,v25,v14,v10\n"
+		"vsubshs		v4,v12,v16\n"
+		"vmhraddshs      v1,v25,v13,v15\n"
+		"vaddshs		v0,v17,v11\n"
+		"vmhraddshs      v5,v29,v14,v10\n"
+		"vmrghh  v8,v0,v4\n"
+		"vaddshs		v3,v12,v16\n"
+		"vmrglh  v9,v0,v4\n"
+		"vmhraddshs      v6,v29,v13,v15\n"
+		"vmrghh  v10,v1,v5\n"
+		"vsubshs		v7,v17,v11\n"
+	"");
+
+	/* Transpose the matrix again. */
+	asm(""
+		"vmrglh  v11,v1,v5\n"
+		"vmrghh  v12,v2,v6\n"
+		"vmrglh  v13,v2,v6\n"
+		"vmrghh  v14,v3,v7\n"
+		"vmrglh  v15,v3,v7\n"
+\
+		"vmrghh  v16,v8,v12\n"
+		"vmrglh  v17,v8,v12\n"
+		"vmrghh  v18,v9,v13\n"
+		"vmrglh  v19,v9,v13\n"
+		"vmrghh  v20,v10,v14\n"
+		"vmrglh  v21,v10,v14\n"
+		"vmrghh  v22,v11,v15\n"
+		"vmrglh  v23,v11,v15\n"
+\
+		"vmrglh  v1,v16,v20\n"
+		"vmrglh  v7,v19,v23\n"
+		"vmrglh  v3,v17,v21\n"
+		"vmrghh  v2,v17,v21\n"
+		"vmhraddshs      v11,v27,v7,v1\n"
+		"vmrghh  v6,v19,v23\n"
+		"vmhraddshs      v19,v27,v1,v31\n"
+		"vmrglh  v5,v18,v22\n"
+		"vmhraddshs      v12,v26,v6,v2\n"
+		"vmrghh  v0,v16,v20\n"
+		"vmhraddshs      v13,v30,v3,v5\n"
+		"vmrghh  v4,v18,v22\n"
+		"vmhraddshs      v17,v28,v5,v3\n"
+		"vsubshs		v18,v19,v7\n"
+	"");
+
+	/* Add a rounding bias for the final shift.  v0 is added into every
+	   vector, so the bias propagates from here. */
+	asm(""
+		"vaddshs	v0,v0,v24\n"
+	"");
+
+	/* Second stage. */
+	asm(""
+		"vmhraddshs      v19,v26,v2,v31\n"
+		"vaddshs		v15,v0,v4\n"
+		"vsubshs		v10,v0,v4\n"
+		"vsubshs		v14,v19,v6\n"
+		"vaddshs		v16,v18,v13\n"
+		"vsubshs		v13,v18,v13\n"
+		"vsubshs		v18,v11,v17\n"
+		"vaddshs		v11,v11,v17\n"
+	"");
+
+	/* Third stage. */
+	asm(""
+		"vaddshs		v17,v15,v12\n"
+		"vsubshs		v12,v15,v12\n"
+		"vaddshs		v15,v10,v14\n"
+		"vsubshs		v10,v10,v14\n"
+		"vsubshs		v14,v18,v13\n"
+		"vaddshs		v13,v18,v13\n"
+	"");
+
+	/* Fourth stage. */
+	asm(""
+		"vmhraddshs	v2,v25,v14,v10\n"
+		"vsubshs		v4,v12,v16\n"
+		"vmhraddshs	v1,v25,v13,v15\n"
+		"vaddshs		v0,v17,v11\n"
+		"vmhraddshs	v5,v29,v14,v10\n"
+		"vaddshs		v3,v12,v16\n"
+		"vspltish	v23,6\n"
+		"vmhraddshs	v6,v29,v13,v15\n"
+		"vsubshs		v7,v17,v11\n"
+	"");
+
+	/* Copy out each 8 values. */
+	asm(""
+		"vmaxsh		v0,v0,v31\n"
+		"vmaxsh		v1,v1,v31\n"
+		"vsrah		v0,v0,v23\n"
+		"vsrah		v1,v1,v23\n"
+		"vpkuhus		v0,v0,v0\n"
+		"vmaxsh		v2,v2,v31\n"
+		"stvewx		v0,%0,%1\n"
+		"vpkuhus		v1,v1,v1\n"
+		"vmaxsh		v3,v3,v31\n"
+		"stvewx		v0,%0,%2\n"
+		"stvewx		v1,%0,%3\n"
+		"stvewx		v1,%0,%4\n"
+	"" : : "b" (output), "b" (0), "b" (4), "b" (0+stride), "b" (4+stride));
+	output += stride<<1;
+	asm(""
+		"vsrah		v2,v2,v23\n"
+		"vsrah		v3,v3,v23\n"
+		"vpkuhus		v2,v2,v2\n"
+		"vmaxsh		v4,v4,v31\n"
+		"stvewx		v2,%0,%1\n"
+		"vpkuhus		v3,v3,v3\n"
+		"vmaxsh		v5,v5,v31\n"
+		"stvewx		v2,%0,%2\n"
+		"stvewx		v3,%0,%3\n"
+		"stvewx		v3,%0,%4\n"
+	"" : : "b" (output), "b" (0), "b" (4), "b" (0+stride), "b" (4+stride));
+	output += stride<<1;
+	asm(""
+		"vsrah		v4,v4,v23\n"
+		"vsrah		v5,v5,v23\n"
+		"vpkuhus		v4,v4,v4\n"
+		"vmaxsh		v6,v6,v31\n"
+		"stvewx		v4,%0,%1\n"
+		"vpkuhus		v5,v5,v5\n"
+		"vmaxsh		v7,v7,v31\n"
+		"stvewx		v4,%0,%2\n"
+		"stvewx		v5,%0,%3\n"
+		"stvewx		v5,%0,%4\n"
+	"" : : "b" (output), "b" (0), "b" (4), "b" (0+stride), "b" (4+stride));
+	output += stride<<1;
+	asm(""
+		"vsrah		v6,v6,v23\n"
+		"vsrah		v7,v7,v23\n"
+		"vpkuhus		v6,v6,v6\n"
+		"stvewx		v6,%0,%1\n"
+		"vpkuhus		v7,v7,v7\n"
+		"stvewx		v6,%0,%2\n"
+		"stvewx		v7,%0,%3\n"
+		"stvewx		v7,%0,%4\n"
+	"" : : "b" (output), "b" (0), "b" (4), "b" (0+stride), "b" (4+stride));
+}
diff -urN -x CVS -x .cvsignore ogle-0.9.2/mpeg2_video/new_table.h ogle/mpeg2_video/new_table.h
--- ogle-0.9.2/mpeg2_video/new_table.h	1970-01-01 01:00:00.000000000 +0100
+++ ogle/mpeg2_video/new_table.h	2001-10-04 05:41:47.000000000 +0200
@@ -0,0 +1,932 @@
+
+//#define RL_BITFIELD
+//#define INDEXBITS
+
+#ifdef RL_BITFIELD
+#define VLC_CODE_BITS(X) ((X).code_bits)
+#define VLC_RUN(X) ((X).run)
+#define VLC_LEVEL(X) ((X).level)
+
+#define VLC_RL(NR, RUN, LEVEL) \
+  { NR-1, RUN, LEVEL }
+
+typedef struct {
+  unsigned int code_bits : 4; // 1-16 (-1)         4bit (humm...)
+  unsigned int run       : 6; // 0-31? (+ eob+63)  6bit
+  unsigned int level     : 6; // 0-40  (+ eob, na) 6bit
+} __attribute__ ((packed)) index_table_t;
+
+#else
+
+#define VLC_CODE_BITS(X) ((X) >> 12)
+#define VLC_RUN(X) (((X) >> 6) & 0x3f)
+#define VLC_LEVEL(X) ((X) & 0x3f)
+
+#define VLC_RL(NR, RUN, LEVEL) \
+  ((((NR-1) & 0x0f) << 12) | (((RUN) & 0x3f) <<  6) | (((LEVEL) & 0x3f) <<  0))
+
+typedef uint16_t index_table_t;
+
+#endif
+
+
+#ifdef INDEXBITS
+#define TOP_OFFSET(T, X) ((T)[(X)].offset)
+#define TOP_IBITS(T, X) ((T)[(X)].index_bits)
+
+#define TOP_VAL(OFFSET, INDEX_BITS) { OFFSET, INDEX_BITS }
+
+typedef struct {
+  uint8_t offset;       // offs in index_table 0-81 7bits
+  uint8_t index_bits;   // 8-nr of bit to index the sub table with 0-8 4bit
+} base_table_t;         // => total size 2byte / 16bit 
+
+#else
+
+#define TOP_OFFSET(T, X) ((T)[(X)])
+/* This should calculate the number of bits to shift the sub index with
+   The offset from in the top table 0->0,  1->4,  2->6,  3->6
+   and all others must have the lower 5 bits [8-31] */
+#define TOP_IBITS(T, X) \
+   ( ((X) & (16+2)) | (((X) & (8+4+2)) << 1) | (((X) & 1) << 2) \
+     | ((X) >> 2) | ((X) >> 4) )
+
+#define TOP_VAL(OFFSET, INDEX_BITS) OFFSET
+
+typedef uint8_t base_table_t;
+#endif
+
+
+
+
+
+const base_table_t top_b15[256] = {
+  TOP_VAL( 83,  0 ), /* all except for the 0,0,0 error cases (32) */
+  TOP_VAL( 67,  4 ), /* all except for the 0,0,0 error cases (6) */
+  TOP_VAL( 55,  6 ),
+  TOP_VAL( 51,  6 ),
+  	      
+  TOP_VAL( 24,  8 ), /*share*/
+  TOP_VAL( 24,  8 ), /*share*/
+  TOP_VAL( 24,  8 ), /*share*/
+  TOP_VAL( 24,  8 ), /*share*/
+  TOP_VAL( 50,  8 ),
+  TOP_VAL( 50,  8 ),
+  TOP_VAL( 20,  8 ), /*share*/
+  TOP_VAL( 20,  8 ), /*share*/
+  TOP_VAL( 49,  8 ),
+  TOP_VAL( 49,  8 ),
+  TOP_VAL( 23,  8 ), /*share*/
+  TOP_VAL( 23,  8 ), /*share*/
+  TOP_VAL( 48,  8 ),
+  TOP_VAL( 48,  8 ),
+  TOP_VAL( 48,  8 ),
+  TOP_VAL( 48,  8 ),
+  TOP_VAL( 47,  8 ),
+  TOP_VAL( 47,  8 ),
+  TOP_VAL( 47,  8 ),
+  TOP_VAL( 47,  8 ),
+  TOP_VAL( 46,  8 ),
+  TOP_VAL( 46,  8 ),
+  TOP_VAL( 46,  8 ),
+  TOP_VAL( 46,  8 ),
+  TOP_VAL( 16,  8 ), /*share*/
+  TOP_VAL( 16,  8 ), /*share*/
+  TOP_VAL( 16,  8 ), /*share*/
+  TOP_VAL( 16,  8 ), /*share*/
+  TOP_VAL( 45,  8 ),
+  TOP_VAL( 12,  8 ), /*share*/
+  TOP_VAL( 44,  8 ),
+  TOP_VAL( 43,  8 ),
+  TOP_VAL( 15,  8 ), /*share*/
+  TOP_VAL( 13,  8 ), /*share*/
+  TOP_VAL( 11,  8 ), /*share*/
+  TOP_VAL( 42,  8 ),
+  TOP_VAL( 41,  8 ),
+  TOP_VAL( 41,  8 ),
+  TOP_VAL( 41,  8 ),
+  TOP_VAL( 41,  8 ),
+  TOP_VAL( 41,  8 ),
+  TOP_VAL( 41,  8 ),
+  TOP_VAL( 41,  8 ),
+  TOP_VAL( 41,  8 ),
+  TOP_VAL( 40,  8 ),
+  TOP_VAL( 40,  8 ),
+  TOP_VAL( 40,  8 ),
+  TOP_VAL( 40,  8 ),
+  TOP_VAL( 40,  8 ),
+  TOP_VAL( 40,  8 ),
+  TOP_VAL( 40,  8 ),
+  TOP_VAL( 40,  8 ),
+  TOP_VAL(  5,  8 ), /*share*/
+  TOP_VAL(  5,  8 ), /*share*/
+  TOP_VAL(  5,  8 ), /*share*/
+  TOP_VAL(  5,  8 ), /*share*/
+  TOP_VAL(  5,  8 ), /*share*/
+  TOP_VAL(  5,  8 ), /*share*/
+  TOP_VAL(  5,  8 ), /*share*/
+  TOP_VAL(  5,  8 ), /*share*/
+  TOP_VAL(  2,  8 ), /*share*/
+  TOP_VAL(  2,  8 ), /*share*/
+  TOP_VAL(  2,  8 ), /*share*/
+  TOP_VAL(  2,  8 ), /*share*/
+  TOP_VAL(  2,  8 ), /*share*/
+  TOP_VAL(  2,  8 ), /*share*/
+  TOP_VAL(  2,  8 ), /*share*/
+  TOP_VAL(  2,  8 ), /*share*/
+  TOP_VAL(  2,  8 ), /*share*/
+  TOP_VAL(  2,  8 ), /*share*/
+  TOP_VAL(  2,  8 ), /*share*/
+  TOP_VAL(  2,  8 ), /*share*/
+  TOP_VAL(  2,  8 ), /*share*/
+  TOP_VAL(  2,  8 ), /*share*/
+  TOP_VAL(  2,  8 ), /*share*/
+  TOP_VAL(  2,  8 ), /*share*/
+  TOP_VAL(  2,  8 ), /*share*/
+  TOP_VAL(  2,  8 ), /*share*/
+  TOP_VAL(  2,  8 ), /*share*/
+  TOP_VAL(  2,  8 ), /*share*/
+  TOP_VAL(  2,  8 ), /*share*/
+  TOP_VAL(  2,  8 ), /*share*/
+  TOP_VAL(  2,  8 ), /*share*/
+  TOP_VAL(  2,  8 ), /*share*/
+  TOP_VAL(  2,  8 ), /*share*/
+  TOP_VAL(  2,  8 ), /*share*/
+  TOP_VAL(  2,  8 ), /*share*/
+  TOP_VAL(  2,  8 ), /*share*/
+  TOP_VAL(  2,  8 ), /*share*/
+  TOP_VAL(  2,  8 ), /*share*/
+  TOP_VAL(  2,  8 ), /*share*/
+  TOP_VAL(  2,  8 ), /*share*/
+  TOP_VAL( 39,  8 ),
+  TOP_VAL( 39,  8 ),
+  TOP_VAL( 39,  8 ),
+  TOP_VAL( 39,  8 ),
+  TOP_VAL( 39,  8 ),
+  TOP_VAL( 39,  8 ),
+  TOP_VAL( 39,  8 ),
+  TOP_VAL( 39,  8 ),
+  TOP_VAL( 39,  8 ),
+  TOP_VAL( 39,  8 ),
+  TOP_VAL( 39,  8 ),
+  TOP_VAL( 39,  8 ),
+  TOP_VAL( 39,  8 ),
+  TOP_VAL( 39,  8 ),
+  TOP_VAL( 39,  8 ),
+  TOP_VAL( 39,  8 ),
+  TOP_VAL( 38,  8 ),
+  TOP_VAL( 38,  8 ),
+  TOP_VAL( 38,  8 ),
+  TOP_VAL( 38,  8 ),
+  TOP_VAL( 38,  8 ),
+  TOP_VAL( 38,  8 ),
+  TOP_VAL( 38,  8 ),
+  TOP_VAL( 38,  8 ),
+  TOP_VAL( 38,  8 ),
+  TOP_VAL( 38,  8 ),
+  TOP_VAL( 38,  8 ),
+  TOP_VAL( 38,  8 ),
+  TOP_VAL( 38,  8 ),
+  TOP_VAL( 38,  8 ),
+  TOP_VAL( 38,  8 ),
+  TOP_VAL( 38,  8 ),
+  TOP_VAL(  0,  8 ), /*share*/
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ), /*share*/
+  TOP_VAL( 37,  8 ),
+  TOP_VAL( 37,  8 ),
+  TOP_VAL( 37,  8 ),
+  TOP_VAL( 37,  8 ),
+  TOP_VAL( 37,  8 ),
+  TOP_VAL( 37,  8 ),
+  TOP_VAL( 37,  8 ),
+  TOP_VAL( 37,  8 ),
+  TOP_VAL( 37,  8 ),
+  TOP_VAL( 37,  8 ),
+  TOP_VAL( 37,  8 ),
+  TOP_VAL( 37,  8 ),
+  TOP_VAL( 37,  8 ),
+  TOP_VAL( 37,  8 ),
+  TOP_VAL( 37,  8 ),
+  TOP_VAL( 37,  8 ),
+  TOP_VAL( 37,  8 ),
+  TOP_VAL( 37,  8 ),
+  TOP_VAL( 37,  8 ),
+  TOP_VAL( 37,  8 ),
+  TOP_VAL( 37,  8 ),
+  TOP_VAL( 37,  8 ),
+  TOP_VAL( 37,  8 ),
+  TOP_VAL( 37,  8 ),
+  TOP_VAL( 37,  8 ),
+  TOP_VAL( 37,  8 ),
+  TOP_VAL( 37,  8 ),
+  TOP_VAL( 37,  8 ),
+  TOP_VAL( 37,  8 ),
+  TOP_VAL( 37,  8 ),
+  TOP_VAL( 37,  8 ),
+  TOP_VAL( 37,  8 ),
+  TOP_VAL( 36,  8 ),
+  TOP_VAL( 36,  8 ),
+  TOP_VAL( 36,  8 ),
+  TOP_VAL( 36,  8 ),
+  TOP_VAL( 36,  8 ),
+  TOP_VAL( 36,  8 ),
+  TOP_VAL( 36,  8 ),
+  TOP_VAL( 36,  8 ),
+  TOP_VAL( 35,  8 ),
+  TOP_VAL( 35,  8 ),
+  TOP_VAL( 35,  8 ),
+  TOP_VAL( 35,  8 ),
+  TOP_VAL( 35,  8 ),
+  TOP_VAL( 35,  8 ),
+  TOP_VAL( 35,  8 ),
+  TOP_VAL( 35,  8 ),
+  TOP_VAL( 22,  8 ), /*share*/
+  TOP_VAL( 22,  8 ), /*share*/
+  TOP_VAL( 34,  8 ),
+  TOP_VAL( 34,  8 ),
+  TOP_VAL( 33,  8 ),
+  TOP_VAL( 33,  8 ),
+  TOP_VAL( 32,  8 ),
+  TOP_VAL( 32,  8 ),
+  TOP_VAL( 31,  8 ),
+  TOP_VAL( 31,  8 ),
+  TOP_VAL( 30,  8 ),
+  TOP_VAL( 29,  8 ),
+  TOP_VAL( 28,  8 ),
+  TOP_VAL( 27,  8 ),
+  TOP_VAL( 26,  8 ),
+  TOP_VAL( 25,  8 )
+};
+//const base_table_t top_b15_2[256];
+
+const base_table_t top_b14[256] = {
+  TOP_VAL( 83,  0 ),
+  TOP_VAL( 67,  4 ),
+  TOP_VAL( 63,  6 ),
+  TOP_VAL( 59,  6 ),
+	      
+  TOP_VAL( 24,  8 ),
+  TOP_VAL( 24,  8 ),
+  TOP_VAL( 24,  8 ),
+  TOP_VAL( 24,  8 ),
+  TOP_VAL( 23,  8 ),
+  TOP_VAL( 23,  8 ),
+  TOP_VAL( 22,  8 ),
+  TOP_VAL( 22,  8 ),
+  TOP_VAL( 21,  8 ),
+  TOP_VAL( 21,  8 ),
+  TOP_VAL( 20,  8 ),
+  TOP_VAL( 20,  8 ),
+  TOP_VAL( 19,  8 ),
+  TOP_VAL( 19,  8 ),
+  TOP_VAL( 19,  8 ),
+  TOP_VAL( 19,  8 ),
+  TOP_VAL( 18,  8 ),
+  TOP_VAL( 18,  8 ),
+  TOP_VAL( 18,  8 ),
+  TOP_VAL( 18,  8 ),
+  TOP_VAL( 17,  8 ),
+  TOP_VAL( 17,  8 ),
+  TOP_VAL( 17,  8 ),
+  TOP_VAL( 17,  8 ),
+  TOP_VAL( 16,  8 ),
+  TOP_VAL( 16,  8 ),
+  TOP_VAL( 16,  8 ),
+  TOP_VAL( 16,  8 ),
+  TOP_VAL( 15,  8 ),
+  TOP_VAL( 14,  8 ),
+  TOP_VAL( 13,  8 ),
+  TOP_VAL( 12,  8 ),
+  TOP_VAL( 11,  8 ),
+  TOP_VAL( 10,  8 ),
+  TOP_VAL(  9,  8 ),
+  TOP_VAL(  8,  8 ),
+  TOP_VAL(  7,  8 ),
+  TOP_VAL(  7,  8 ),
+  TOP_VAL(  7,  8 ),
+  TOP_VAL(  7,  8 ),
+  TOP_VAL(  7,  8 ),
+  TOP_VAL(  7,  8 ),
+  TOP_VAL(  7,  8 ),
+  TOP_VAL(  7,  8 ),
+  TOP_VAL(  6,  8 ),
+  TOP_VAL(  6,  8 ),
+  TOP_VAL(  6,  8 ),
+  TOP_VAL(  6,  8 ),
+  TOP_VAL(  6,  8 ),
+  TOP_VAL(  6,  8 ),
+  TOP_VAL(  6,  8 ),
+  TOP_VAL(  6,  8 ),
+  TOP_VAL(  5,  8 ),
+  TOP_VAL(  5,  8 ),
+  TOP_VAL(  5,  8 ),
+  TOP_VAL(  5,  8 ),
+  TOP_VAL(  5,  8 ),
+  TOP_VAL(  5,  8 ),
+  TOP_VAL(  5,  8 ),
+  TOP_VAL(  5,  8 ),
+  TOP_VAL(  4,  8 ),
+  TOP_VAL(  4,  8 ),
+  TOP_VAL(  4,  8 ),
+  TOP_VAL(  4,  8 ),
+  TOP_VAL(  4,  8 ),
+  TOP_VAL(  4,  8 ),
+  TOP_VAL(  4,  8 ),
+  TOP_VAL(  4,  8 ),
+  TOP_VAL(  4,  8 ),
+  TOP_VAL(  4,  8 ),
+  TOP_VAL(  4,  8 ),
+  TOP_VAL(  4,  8 ),
+  TOP_VAL(  4,  8 ),
+  TOP_VAL(  4,  8 ),
+  TOP_VAL(  4,  8 ),
+  TOP_VAL(  4,  8 ),
+  TOP_VAL(  3,  8 ),
+  TOP_VAL(  3,  8 ),
+  TOP_VAL(  3,  8 ),
+  TOP_VAL(  3,  8 ),
+  TOP_VAL(  3,  8 ),
+  TOP_VAL(  3,  8 ),
+  TOP_VAL(  3,  8 ),
+  TOP_VAL(  3,  8 ),
+  TOP_VAL(  3,  8 ),
+  TOP_VAL(  3,  8 ),
+  TOP_VAL(  3,  8 ),
+  TOP_VAL(  3,  8 ),
+  TOP_VAL(  3,  8 ),
+  TOP_VAL(  3,  8 ),
+  TOP_VAL(  3,  8 ),
+  TOP_VAL(  3,  8 ),
+  TOP_VAL(  2,  8 ),
+  TOP_VAL(  2,  8 ),
+  TOP_VAL(  2,  8 ),
+  TOP_VAL(  2,  8 ),
+  TOP_VAL(  2,  8 ),
+  TOP_VAL(  2,  8 ),
+  TOP_VAL(  2,  8 ),
+  TOP_VAL(  2,  8 ),
+  TOP_VAL(  2,  8 ),
+  TOP_VAL(  2,  8 ),
+  TOP_VAL(  2,  8 ),
+  TOP_VAL(  2,  8 ),
+  TOP_VAL(  2,  8 ),
+  TOP_VAL(  2,  8 ),
+  TOP_VAL(  2,  8 ),
+  TOP_VAL(  2,  8 ),
+  TOP_VAL(  2,  8 ),
+  TOP_VAL(  2,  8 ),
+  TOP_VAL(  2,  8 ),
+  TOP_VAL(  2,  8 ),
+  TOP_VAL(  2,  8 ),
+  TOP_VAL(  2,  8 ),
+  TOP_VAL(  2,  8 ),
+  TOP_VAL(  2,  8 ),
+  TOP_VAL(  2,  8 ),
+  TOP_VAL(  2,  8 ),
+  TOP_VAL(  2,  8 ),
+  TOP_VAL(  2,  8 ),
+  TOP_VAL(  2,  8 ),
+  TOP_VAL(  2,  8 ),
+  TOP_VAL(  2,  8 ),
+  TOP_VAL(  2,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  1,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 ),
+  TOP_VAL(  0,  8 )
+};
+//const base_table_t top_b14_2[256];
+
+
+const index_table_t sub_table[] = {
+  VLC_RL(  2,  0,  1 ), /* replace with {1, 0, 1} for DCT_DC_FIRST */ /*share*/
+  VLC_RL(  1, 63, 63 ), /* replace with {1, 0, 1} for DCT_DC_FIRST */ /* eob */
+  VLC_RL(  3,  1,  1 ), /*share*/
+  VLC_RL(  4,  2,  1 ), 
+  VLC_RL(  4,  0,  2 ), 
+  VLC_RL(  5,  3,  1 ), /*share*/
+  VLC_RL(  5,  4,  1 ), 
+  VLC_RL(  5,  0,  3 ), 
+  VLC_RL(  8, 10,  1 ), 
+  VLC_RL(  8,  0,  5 ), 
+  VLC_RL(  8,  1,  3 ), 
+  VLC_RL(  8,  3,  2 ), /*share*/
+  VLC_RL(  8, 11,  1 ), /*share*/
+  VLC_RL(  8, 12,  1 ), /*share*/
+  VLC_RL(  8,  0,  6 ), 
+  VLC_RL(  8, 13,  1 ), /*share*/
+  VLC_RL(  6,  5,  1 ), /*share*/
+  VLC_RL(  6,  1,  2 ), 
+  VLC_RL(  6,  6,  1 ), 
+  VLC_RL(  6,  7,  1 ), 
+  VLC_RL(  7,  8,  1 ), /*share*/
+  VLC_RL(  7,  0,  4 ), 
+  VLC_RL(  7,  9,  1 ), /*share*/
+  VLC_RL(  7,  2,  2 ), /*share*/
+  VLC_RL(  6, 63, 63 ), /* index = 24 (esq, not really needed) */ /*share*/
+  VLC_RL(  8,  0, 15 ), /*  0 25 */
+  VLC_RL(  8,  0, 14 ), /*  1 26 */
+  VLC_RL(  8,  4,  2 ), /*  2 27 */
+  VLC_RL(  8,  2,  3 ), /*  3 28 */
+  VLC_RL(  8,  0, 13 ), /*  4 29 */ 
+  VLC_RL(  8,  0, 12 ), /*  5 30 */ 
+  VLC_RL(  7,  0,  9 ), /*  6 31 */ 
+  VLC_RL(  7,  0,  8 ), /*  7 32 */ 
+  VLC_RL(  7, 10,  1 ), /*  8 33 */ 
+  VLC_RL(  7,  1,  3 ), /*  9 34 */ 
+  VLC_RL(  5,  0,  5 ), /* 11 35 */
+  VLC_RL(  5,  0,  4 ), /* 12 36 */
+  VLC_RL(  3,  0,  2 ), /* 13 37 */
+  VLC_RL(  4,  0,  3 ), /* 15 38 */
+  VLC_RL(  3, 63, 63 ), /* 16 39 */ /* eob */
+  VLC_RL(  5,  1,  2 ), /* 19 40 */ 
+  VLC_RL(  5,  2,  1 ), /* 20 41 */ 
+  VLC_RL(  8,  1,  4 ), /* 21 42 */ 
+  VLC_RL(  8,  0, 10 ), /* 25 43 */ 
+  VLC_RL(  8,  0, 11 ), /* 26 44 */ 
+  VLC_RL(  8,  1,  5 ), /* 28 45 */ 
+  VLC_RL(  6,  4,  1 ), /* 30 46 */ 
+  VLC_RL(  6,  0,  6 ), /* 31 47 */ 
+  VLC_RL(  6,  0,  7 ), /* 32 48 */ 
+  VLC_RL(  7,  6,  1 ), /* 34 49 */ 
+  VLC_RL(  7,  7,  1 ), /* 36 50 */ 
+  
+  VLC_RL( 10,  2,  4 ), /* 38 51 */ 
+  VLC_RL( 10, 16,  1 ), /* 38    */    
+  VLC_RL(  9, 15,  1 ), /* 38    */    
+  VLC_RL(  9, 15,  1 ), /* 38    */  
+  
+  VLC_RL(  9,  5,  2 ), /* 42 55 */ 
+  VLC_RL(  9, 14,  1 ), /* 42    */
+  VLC_RL(  9,  5,  2 ), /* 42    */ /* repeat two previous*/
+  VLC_RL(  9, 14,  1 ), /* 42    */ /* to get 0,4,6,6 in both top tables */
+  
+  VLC_RL( 10,  1,  4 ), /* 25 -> 59 */
+  VLC_RL( 10, 15,  1 ), 
+  VLC_RL( 10, 14,  1 ), 
+  VLC_RL( 10,  4,  2 ), 
+  
+  VLC_RL( 10, 16,  1 ), /* 29 -> 63 */
+  VLC_RL( 10,  5,  2 ), 
+  VLC_RL( 10,  0,  7 ), 
+  VLC_RL( 10,  2,  3 ), 
+  
+  VLC_RL( 12,  0, 11 ), /* 33 -> 67 */ /*share*/
+  VLC_RL( 12,  8,  2 ), 
+  VLC_RL( 12,  4,  3 ), 
+  VLC_RL( 12,  0, 10 ), 
+  VLC_RL( 12,  2,  4 ), 
+  VLC_RL( 12,  7,  2 ), 
+  VLC_RL( 12, 21,  1 ), 
+  VLC_RL( 12, 20,  1 ), 
+  VLC_RL( 12,  0,  9 ), 
+  VLC_RL( 12, 19,  1 ), 
+  VLC_RL( 12, 18,  1 ), 
+  VLC_RL( 12,  1,  5 ), 
+  VLC_RL( 12,  3,  3 ), 
+  VLC_RL( 12,  0,  8 ), 
+  VLC_RL( 12,  6,  2 ), 
+  VLC_RL( 12, 17,  1 ), 
+  
+  VLC_RL(  1,  0,  0 ), /* 49 -> 83 */ /*share*/
+  VLC_RL(  1,  0,  0 ), /* could replace 81 with 81-16 = 75 */
+  VLC_RL(  1,  0,  0 ), /* if we remove the 16 0,0,0 lines */
+  VLC_RL(  1,  0,  0 ), /* the 0,0,0 are all 'impossible' */
+  VLC_RL(  1,  0,  0 ), /* i.e. errors, code that should not appear normaly */
+  VLC_RL(  1,  0,  0 ), 
+  VLC_RL(  1,  0,  0 ), 
+  VLC_RL(  1,  0,  0 ), 
+  VLC_RL(  1,  0,  0 ), 
+  VLC_RL(  1,  0,  0 ), 
+  VLC_RL(  1,  0,  0 ), 
+  VLC_RL(  1,  0,  0 ), 
+  VLC_RL(  1,  0,  0 ), 
+  VLC_RL(  1,  0,  0 ), 
+  VLC_RL(  1,  0,  0 ), 
+  VLC_RL(  1,  0,  0 ), 
+  VLC_RL( 16,  1, 18 ), 
+  VLC_RL( 16,  1, 17 ), 
+  VLC_RL( 16,  1, 16 ), 
+  VLC_RL( 16,  1, 15 ), 
+  VLC_RL( 16,  6,  3 ), 
+  VLC_RL( 16, 16,  2 ), 
+  VLC_RL( 16, 15,  2 ), 
+  VLC_RL( 16, 14,  2 ), 
+  VLC_RL( 16, 13,  2 ), 
+  VLC_RL( 16, 12,  2 ), 
+  VLC_RL( 16, 11,  2 ), 
+  VLC_RL( 16, 31,  1 ), 
+  VLC_RL( 16, 30,  1 ), 
+  VLC_RL( 16, 29,  1 ), 
+  VLC_RL( 16, 28,  1 ), 
+  VLC_RL( 16, 27,  1 ), 
+  VLC_RL( 15,  0, 40 ), 
+  VLC_RL( 15,  0, 40 ), 
+  VLC_RL( 15,  0, 39 ), 
+  VLC_RL( 15,  0, 39 ), 
+  VLC_RL( 15,  0, 38 ), 
+  VLC_RL( 15,  0, 38 ), 
+  VLC_RL( 15,  0, 37 ), 
+  VLC_RL( 15,  0, 37 ), 
+  VLC_RL( 15,  0, 36 ), 
+  VLC_RL( 15,  0, 36 ), 
+  VLC_RL( 15,  0, 35 ), 
+  VLC_RL( 15,  0, 35 ), 
+  VLC_RL( 15,  0, 34 ), 
+  VLC_RL( 15,  0, 34 ), 
+  VLC_RL( 15,  0, 33 ), 
+  VLC_RL( 15,  0, 33 ), 
+  VLC_RL( 15,  0, 32 ), 
+  VLC_RL( 15,  0, 32 ), 
+  VLC_RL( 15,  1, 14 ), 
+  VLC_RL( 15,  1, 14 ), 
+  VLC_RL( 15,  1, 13 ), 
+  VLC_RL( 15,  1, 13 ), 
+  VLC_RL( 15,  1, 12 ), 
+  VLC_RL( 15,  1, 12 ), 
+  VLC_RL( 15,  1, 11 ), 
+  VLC_RL( 15,  1, 11 ), 
+  VLC_RL( 15,  1, 10 ), 
+  VLC_RL( 15,  1, 10 ), 
+  VLC_RL( 15,  1,  9 ), 
+  VLC_RL( 15,  1,  9 ), 
+  VLC_RL( 15,  1,  8 ), 
+  VLC_RL( 15,  1,  8 ), 
+  VLC_RL( 14,  0, 31 ), 
+  VLC_RL( 14,  0, 31 ), 
+  VLC_RL( 14,  0, 31 ), 
+  VLC_RL( 14,  0, 31 ), 
+  VLC_RL( 14,  0, 30 ), 
+  VLC_RL( 14,  0, 30 ), 
+  VLC_RL( 14,  0, 30 ), 
+  VLC_RL( 14,  0, 30 ), 
+  VLC_RL( 14,  0, 29 ), 
+  VLC_RL( 14,  0, 29 ), 
+  VLC_RL( 14,  0, 29 ), 
+  VLC_RL( 14,  0, 29 ), 
+  VLC_RL( 14,  0, 28 ), 
+  VLC_RL( 14,  0, 28 ), 
+  VLC_RL( 14,  0, 28 ), 
+  VLC_RL( 14,  0, 28 ), 
+  VLC_RL( 14,  0, 27 ), 
+  VLC_RL( 14,  0, 27 ), 
+  VLC_RL( 14,  0, 27 ), 
+  VLC_RL( 14,  0, 27 ), 
+  VLC_RL( 14,  0, 26 ), 
+  VLC_RL( 14,  0, 26 ), 
+  VLC_RL( 14,  0, 26 ), 
+  VLC_RL( 14,  0, 26 ), 
+  VLC_RL( 14,  0, 25 ), 
+  VLC_RL( 14,  0, 25 ), 
+  VLC_RL( 14,  0, 25 ), 
+  VLC_RL( 14,  0, 25 ), 
+  VLC_RL( 14,  0, 24 ), 
+  VLC_RL( 14,  0, 24 ), 
+  VLC_RL( 14,  0, 24 ), 
+  VLC_RL( 14,  0, 24 ), 
+  VLC_RL( 14,  0, 23 ), 
+  VLC_RL( 14,  0, 23 ), 
+  VLC_RL( 14,  0, 23 ), 
+  VLC_RL( 14,  0, 23 ), 
+  VLC_RL( 14,  0, 22 ), 
+  VLC_RL( 14,  0, 22 ), 
+  VLC_RL( 14,  0, 22 ), 
+  VLC_RL( 14,  0, 22 ), 
+  VLC_RL( 14,  0, 21 ), 
+  VLC_RL( 14,  0, 21 ), 
+  VLC_RL( 14,  0, 21 ), 
+  VLC_RL( 14,  0, 21 ), 
+  VLC_RL( 14,  0, 20 ), 
+  VLC_RL( 14,  0, 20 ), 
+  VLC_RL( 14,  0, 20 ), 
+  VLC_RL( 14,  0, 20 ), 
+  VLC_RL( 14,  0, 19 ), 
+  VLC_RL( 14,  0, 19 ), 
+  VLC_RL( 14,  0, 19 ), 
+  VLC_RL( 14,  0, 19 ), 
+  VLC_RL( 14,  0, 18 ), 
+  VLC_RL( 14,  0, 18 ), 
+  VLC_RL( 14,  0, 18 ), 
+  VLC_RL( 14,  0, 18 ), 
+  VLC_RL( 14,  0, 17 ), 
+  VLC_RL( 14,  0, 17 ), 
+  VLC_RL( 14,  0, 17 ), 
+  VLC_RL( 14,  0, 17 ), 
+  VLC_RL( 14,  0, 16 ), 
+  VLC_RL( 14,  0, 16 ), 
+  VLC_RL( 14,  0, 16 ), 
+  VLC_RL( 14,  0, 16 ), 
+  VLC_RL( 13, 10,  2 ), 
+  VLC_RL( 13, 10,  2 ), 
+  VLC_RL( 13, 10,  2 ), 
+  VLC_RL( 13, 10,  2 ), 
+  VLC_RL( 13, 10,  2 ), 
+  VLC_RL( 13, 10,  2 ), 
+  VLC_RL( 13, 10,  2 ), 
+  VLC_RL( 13, 10,  2 ), 
+  VLC_RL( 13,  9,  2 ), 
+  VLC_RL( 13,  9,  2 ), 
+  VLC_RL( 13,  9,  2 ), 
+  VLC_RL( 13,  9,  2 ), 
+  VLC_RL( 13,  9,  2 ), 
+  VLC_RL( 13,  9,  2 ), 
+  VLC_RL( 13,  9,  2 ), 
+  VLC_RL( 13,  9,  2 ), 
+  VLC_RL( 13,  5,  3 ), 
+  VLC_RL( 13,  5,  3 ), 
+  VLC_RL( 13,  5,  3 ), 
+  VLC_RL( 13,  5,  3 ), 
+  VLC_RL( 13,  5,  3 ), 
+  VLC_RL( 13,  5,  3 ), 
+  VLC_RL( 13,  5,  3 ), 
+  VLC_RL( 13,  5,  3 ), 
+  VLC_RL( 13,  3,  4 ), 
+  VLC_RL( 13,  3,  4 ), 
+  VLC_RL( 13,  3,  4 ), 
+  VLC_RL( 13,  3,  4 ), 
+  VLC_RL( 13,  3,  4 ), 
+  VLC_RL( 13,  3,  4 ), 
+  VLC_RL( 13,  3,  4 ), 
+  VLC_RL( 13,  3,  4 ), 
+  VLC_RL( 13,  2,  5 ), 
+  VLC_RL( 13,  2,  5 ), 
+  VLC_RL( 13,  2,  5 ), 
+  VLC_RL( 13,  2,  5 ), 
+  VLC_RL( 13,  2,  5 ), 
+  VLC_RL( 13,  2,  5 ), 
+  VLC_RL( 13,  2,  5 ), 
+  VLC_RL( 13,  2,  5 ), 
+  VLC_RL( 13,  1,  7 ), 
+  VLC_RL( 13,  1,  7 ), 
+  VLC_RL( 13,  1,  7 ), 
+  VLC_RL( 13,  1,  7 ), 
+  VLC_RL( 13,  1,  7 ), 
+  VLC_RL( 13,  1,  7 ), 
+  VLC_RL( 13,  1,  7 ), 
+  VLC_RL( 13,  1,  7 ), 
+  VLC_RL( 13,  1,  6 ), 
+  VLC_RL( 13,  1,  6 ), 
+  VLC_RL( 13,  1,  6 ), 
+  VLC_RL( 13,  1,  6 ), 
+  VLC_RL( 13,  1,  6 ), 
+  VLC_RL( 13,  1,  6 ), 
+  VLC_RL( 13,  1,  6 ), 
+  VLC_RL( 13,  1,  6 ), 
+  VLC_RL( 13,  0, 15 ), 
+  VLC_RL( 13,  0, 15 ), 
+  VLC_RL( 13,  0, 15 ), 
+  VLC_RL( 13,  0, 15 ), 
+  VLC_RL( 13,  0, 15 ), 
+  VLC_RL( 13,  0, 15 ), 
+  VLC_RL( 13,  0, 15 ), 
+  VLC_RL( 13,  0, 15 ), 
+  VLC_RL( 13,  0, 14 ), 
+  VLC_RL( 13,  0, 14 ), 
+  VLC_RL( 13,  0, 14 ), 
+  VLC_RL( 13,  0, 14 ), 
+  VLC_RL( 13,  0, 14 ), 
+  VLC_RL( 13,  0, 14 ), 
+  VLC_RL( 13,  0, 14 ), 
+  VLC_RL( 13,  0, 14 ), 
+  VLC_RL( 13,  0, 13 ), 
+  VLC_RL( 13,  0, 13 ), 
+  VLC_RL( 13,  0, 13 ), 
+  VLC_RL( 13,  0, 13 ), 
+  VLC_RL( 13,  0, 13 ), 
+  VLC_RL( 13,  0, 13 ), 
+  VLC_RL( 13,  0, 13 ), 
+  VLC_RL( 13,  0, 13 ), 
+  VLC_RL( 13,  0, 12 ), 
+  VLC_RL( 13,  0, 12 ), 
+  VLC_RL( 13,  0, 12 ), 
+  VLC_RL( 13,  0, 12 ), 
+  VLC_RL( 13,  0, 12 ), 
+  VLC_RL( 13,  0, 12 ), 
+  VLC_RL( 13,  0, 12 ), 
+  VLC_RL( 13,  0, 12 ), 
+  VLC_RL( 13, 26,  1 ), 
+  VLC_RL( 13, 26,  1 ), 
+  VLC_RL( 13, 26,  1 ), 
+  VLC_RL( 13, 26,  1 ), 
+  VLC_RL( 13, 26,  1 ), 
+  VLC_RL( 13, 26,  1 ), 
+  VLC_RL( 13, 26,  1 ), 
+  VLC_RL( 13, 26,  1 ), 
+  VLC_RL( 13, 25,  1 ), 
+  VLC_RL( 13, 25,  1 ), 
+  VLC_RL( 13, 25,  1 ), 
+  VLC_RL( 13, 25,  1 ), 
+  VLC_RL( 13, 25,  1 ), 
+  VLC_RL( 13, 25,  1 ), 
+  VLC_RL( 13, 25,  1 ), 
+  VLC_RL( 13, 25,  1 ), 
+  VLC_RL( 13, 24,  1 ), 
+  VLC_RL( 13, 24,  1 ), 
+  VLC_RL( 13, 24,  1 ), 
+  VLC_RL( 13, 24,  1 ), 
+  VLC_RL( 13, 24,  1 ), 
+  VLC_RL( 13, 24,  1 ), 
+  VLC_RL( 13, 24,  1 ), 
+  VLC_RL( 13, 24,  1 ), 
+  VLC_RL( 13, 23,  1 ), 
+  VLC_RL( 13, 23,  1 ), 
+  VLC_RL( 13, 23,  1 ), 
+  VLC_RL( 13, 23,  1 ), 
+  VLC_RL( 13, 23,  1 ), 
+  VLC_RL( 13, 23,  1 ), 
+  VLC_RL( 13, 23,  1 ), 
+  VLC_RL( 13, 23,  1 ), 
+  VLC_RL( 13, 22,  1 ), 
+  VLC_RL( 13, 22,  1 ), 
+  VLC_RL( 13, 22,  1 ), 
+  VLC_RL( 13, 22,  1 ), 
+  VLC_RL( 13, 22,  1 ), 
+  VLC_RL( 13, 22,  1 ), 
+  VLC_RL( 13, 22,  1 ), 
+  VLC_RL( 13, 22,  1 )
+};
diff -urN -x CVS -x .cvsignore ogle-0.9.2/mpeg2_video/shutup.c ogle/mpeg2_video/shutup.c
--- ogle-0.9.2/mpeg2_video/shutup.c	1970-01-01 01:00:00.000000000 +0100
+++ ogle/mpeg2_video/shutup.c	2002-01-16 19:36:09.000000000 +0100
@@ -0,0 +1,33 @@
+/* 
+ * This is a simple wrapper to test the xscreensaver-interfacing
+ * functions.
+ *
+ *             /August.
+ */
+
+
+#include "xscreensaver-comm.c"
+
+int
+main()
+{
+  printf("A dot should appear every 50 seconds.\n\n");
+  
+  if(! look_for_good_xscreensaver())
+    {
+      printf("Found no screensaver!\n");
+      exit(1);
+    }
+   else
+    { 
+      printf("Found a working screensaver.\n");
+
+      while (1)
+       {
+         fprintf(stderr, ".");
+         sleep(50);
+         nudge_xscreensaver();
+       }
+    }
+  exit(0);
+}
diff -urN -x CVS -x .cvsignore ogle-0.9.2/mpeg2_video/spu_mixer.c ogle/mpeg2_video/spu_mixer.c
--- ogle-0.9.2/mpeg2_video/spu_mixer.c	2003-10-20 22:28:27.000000000 +0200
+++ ogle/mpeg2_video/spu_mixer.c	2006-12-12 21:14:43.000000000 +0100
@@ -21,13 +21,10 @@
 #include <assert.h>
 #include <stdlib.h>
 #include <signal.h>
-#include <sys/mman.h>
 #include <sys/types.h>
 #include <sys/stat.h>
-#include <sys/shm.h>
 #include <fcntl.h>
 #include <unistd.h>
-#include <sys/msg.h>
 #include <errno.h>
 #include <string.h>
 
@@ -37,12 +34,7 @@
 #include "timemath.h"
 #include "sync.h"
 #include "spu_mixer.h"
-
-#ifndef SHM_SHARE_MMU
-#define SHM_SHARE_MMU 0
-#endif
-
-
+#include "shm.h"
 
 
 
@@ -76,6 +68,7 @@
   int has_highlight;
   uint8_t color[4];
   uint8_t contrast[4];
+  int32_t nav_serial;
 } spu_handle_t;
 
 typedef struct {
@@ -85,6 +78,7 @@
   int y_start;
   int x_end;
   int y_end;
+  int32_t nav_serial;
 } highlight_t;
 
 
@@ -114,12 +108,16 @@
 
 static highlight_t highlight = {{0,1,2,3}, {0xf, 0xa, 0x6,0x2}, 2,2,718, 450};
 
+static uint32_t spu_state;
+
 extern int video_scr_nr;
+extern int *video_flush_to_scrid;
 extern int msgqid;
 
 extern MsgEventQ_t *msgq;
 
 static int flush_to_scrid = -1;
+static int32_t flush_to_navserial = -1;
 static int rgbmode,pixelstride;
 
 #define MAX_BUF_SIZE 65536
@@ -190,8 +188,8 @@
   
   //DNOTE("spu_mixer: shmid: %d\n", shmid);
   
-  if(shmid >= 0) {
-    if((shmaddr = shmat(shmid, NULL, SHM_SHARE_MMU)) == (void *)-1) {
+  if(shmid != -1) {
+    if((shmaddr = ogle_shmat(shmid)) == (void *)-1) {
       ERROR("%s", "spu_mixer: attach_decoder_buffer()");
       perror("shmat");
       return -1;
@@ -204,8 +202,8 @@
   q_head = (q_head_t *)stream_shmaddr;
   shmid = q_head->data_buf_shmid;
   
-  if(shmid >= 0) {
-    if((shmaddr = shmat(shmid, NULL, SHM_SHARE_MMU)) == (void *)-1) {
+  if(shmid != -1) {
+    if((shmaddr = ogle_shmat(shmid)) == (void *)-1) {
       ERROR("%s", "spu: attach_data_buffer()");
       perror("shmat");
       return -1;
@@ -217,6 +215,7 @@
   
   initialized = 1;
   return 0;
+
 }
 
 
@@ -256,24 +255,37 @@
   case MsgEventQSPUHighlight:
     {
       int n;
-      
+      DNOTE("hilite %d, %d -> %d, %d,  %d\n",
+	    ev->spuhighlight.x_start,
+	    ev->spuhighlight.y_start,
+	    ev->spuhighlight.x_end,
+	    ev->spuhighlight.y_end,
+	    ev->spuhighlight.nav_serial);
+	    
       /* Enable the highlight, should have PTS or scr I think */
       spu_info.has_highlight = 1;
-      
+      highlight.nav_serial = ev->spuhighlight.nav_serial;
       highlight.x_start = ev->spuhighlight.x_start;
       highlight.y_start = ev->spuhighlight.y_start;
       highlight.x_end = ev->spuhighlight.x_end;
       highlight.y_end = ev->spuhighlight.y_end;
-
+      DNOTE("%s", "col/cont:");
       for(n = 0; n < 4; n++) {
 	highlight.color[n] = ev->spuhighlight.color[n];
+	DNOTEC(" %d", highlight.color[n]);
       }
       for(n = 0; n < 4; n++) {
 	highlight.contrast[n] = ev->spuhighlight.contrast[n];
+	DNOTEC(" %d", highlight.contrast[n]);
       }
+      DNOTEC("%s", "\n");
       redraw_request();
     }
     break;
+  case MsgEventQSPUState:
+    spu_state = ev->spustate.state;
+    redraw_request();
+    break;
   default:
     /* DNOTE("spu_mixer: ignoring event type (%d)\n", ev->type); */
     return 0;
@@ -284,7 +296,7 @@
 
 
 static int get_q(char *dst, int readlen, uint64_t *display_base_time, 
-		 int *new_scr_nr)
+		 int *new_scr_nr, int32_t *nav_serial)
 {
   MsgEvent_t ev;
   q_head_t *q_head;
@@ -304,16 +316,18 @@
   static int read_offset = 0;
   //  clocktime_t pts_time;
   int cpy_len;
+  volatile int *in_use;
 
   q_head = (q_head_t *)stream_shmaddr;
   q_elems = (q_elem_t *)(stream_shmaddr+sizeof(q_head_t));
   elem = q_head->read_nr;
-  
+
+  in_use = &(q_elems[elem].in_use); 
   if(!read_offset) {    
-    if(!q_elems[elem].in_use) {
+    if(!*in_use) {
       q_head->reader_requests_notification = 1;
       
-      if(!q_elems[elem].in_use) {
+      if(!*in_use) {
 	return 0;
       }
     }
@@ -343,7 +357,7 @@
   if(PTS_DTS_flags & 0x1) {
     DTS = data_elem->DTS;
   }
-  
+  *nav_serial = data_elem->serial;
   //DNOTE("spu_mixer: len: %d\n", len);
   //DNOTE("spu_mixer: readlen: %d\n", readlen);
   //DNOTE("spu_mixer: read_offset: %d\n", read_offset);
@@ -414,7 +428,7 @@
 
 
 static int get_data(uint8_t *databuf, int bufsize, 
-		    uint64_t *dtime, int *scr_nr)
+		    uint64_t *dtime, int *scr_nr, int32_t *nav_serial)
 {
   int r;
   static int bytes_to_read = 0;
@@ -435,7 +449,8 @@
   }
   if(state == 0) {
     while(bytes_to_read > 0) {
-      r = get_q(&databuf[2-bytes_to_read], bytes_to_read, dtime, scr_nr);
+      r = get_q(&databuf[2-bytes_to_read], bytes_to_read, dtime,
+		scr_nr, nav_serial);
       
       if(r > 0) {
 	bytes_to_read -= r;
@@ -469,7 +484,8 @@
 
   // get the rest of the spu
   while(bytes_to_read > 0) {
-    r = get_q(&databuf[spu_size-bytes_to_read], bytes_to_read, dtime, scr_nr);
+    r = get_q(&databuf[spu_size-bytes_to_read], bytes_to_read, dtime,
+	      scr_nr, nav_serial);
     
     if(r > 0) {
       bytes_to_read -= r;
@@ -592,15 +608,15 @@
     /* Command Sequence */
       
     DPRINTF(3, "\t\t\tDisplay Control Command: 0x%02x\n", command);
-      
+
     switch (command) {
     case 0x00: /* forced display start (often a menu) */
       DPRINTF(3, "\t\t\t\tforced display start\n");
-      spu_info->display_start = 1; // spu_info->menu = 1;
+      spu_info->display_start = 0x1; // spu_info->menu = 1;
       break;
     case 0x01: /* display start */
       DPRINTF(3, "\t\t\t\tdisplay start\n");
-      spu_info->display_start = 1;
+      spu_info->display_start = 0x2;
       break;
     case 0x02: /* display stop */
       DPRINTF(3, "\t\t\t\tdisplay stop\n");
@@ -959,7 +975,10 @@
   aligned = 1;
   set_byte(&spu_info->buffer[fieldoffset[field]]);
   
-  //DNOTE("\nDecoding overlay picture data\n");
+  DNOTE("Decoding overlay picture data, hilite: %d, hiliser: %d, spuser: %d\n",
+	spu_info->has_highlight,
+	highlight.nav_serial,
+	spu_info->nav_serial);
   
   //initialize(spu_info->width, spu_info->height);
   x = 0;
@@ -1145,21 +1164,31 @@
 
   /* If next_time haven't been set, try to set it. */
   if(spu_info->next_time == 0) {
-    
+
     if(spu_info->next_DCSQ_offset == spu_info->last_DCSQ) {
       unsigned char *b = spu_info->next_buffer;
       
       if(get_data(spu_info->next_buffer, MAX_BUF_SIZE, 
-		   &spu_info->base_time, &spu_info->scr_nr) <= 0) {
+		  &spu_info->base_time, &spu_info->scr_nr, 
+		  &spu_info->nav_serial) <= 0) {
 	if(flush_to_scrid != -1) {
 	  // FIXME: assumes order of src_nr
 	  if(ctrl_time[spu_info->scr_nr].scr_id < flush_to_scrid) {
 	    /* Reset state  */
-	    //DNOTE("spu: flush/reset 2\n");
+#if 0 //todo
+	    DNOTE("not getdata scr %d < flushto %d (%d),  hili: %d spu: %d\n",
+		  ctrl_time[spu_info->scr_nr].scr_id, flush_to_scrid,
+		  flush_to_navserial,
+		  highlight.nav_serial, spu_info->nav_serial); 
+#endif
 	    spu_info->display_start = 0;
-	    spu_info->has_highlight = 0;
+	    
+	    if(highlight.nav_serial < flush_to_navserial) {
+	      spu_info->has_highlight = 0;
+	    }
 	  }
 	}
+
 	return 0;
       }
       /* The offset to the first DCSQ */
@@ -1184,9 +1213,14 @@
 
       
       /* Reset state  */
-      //DNOTE("spu: flush/reset 3\n");
       spu_info->display_start = 0;
-      spu_info->has_highlight = 0;
+      if(highlight.nav_serial < flush_to_navserial) {
+	spu_info->has_highlight = 0;
+      }
+      DNOTE("scr %d < flushto %d (%d),  hili: %d spu: %d\n",
+	    ctrl_time[spu_info->scr_nr].scr_id, flush_to_scrid,
+	    flush_to_navserial,
+	    highlight.nav_serial, spu_info->nav_serial); 
       
       return 1;
     } else {
@@ -1194,13 +1228,27 @@
     }
   }
 
-  if(spu_info->scr_nr < video_scr_nr) { // FIXME: assumes order of src_nr
-    //DNOTE("spu: spu_info->scr_nr != video_scr_nr\n");
+#if 0
+  DNOTE("video_scr_nr %d (%d), v_ft: %d\n",
+	video_scr_nr,
+	ctrl_time[video_scr_nr].scr_id,
+	*video_flush_to_scrid);
+#endif
+
+  if((ctrl_time[spu_info->scr_nr].scr_id < ctrl_time[video_scr_nr].scr_id) ||
+     (ctrl_time[spu_info->scr_nr].scr_id < *video_flush_to_scrid)) {
+#if 0
+    DNOTE("spu: spu_info->scr_nr (%d)[%d] != video_scr_nr (%d)[%d]\n",
+	  spu_info->scr_nr,
+	  ctrl_time[spu_info->scr_nr].scr_id,
+	  video_scr_nr,
+	  ctrl_time[video_scr_nr].scr_id);
+#endif
     return 1;
   }
 
   if(ctrl_time[spu_info->scr_nr].offset_valid == OFFSET_NOT_VALID) {
-    //DNOTE("scr_nr: %d, OFFSET_NOT_VALID\n", spu_info->scr_nr);
+    DNOTE("scr_nr: %d, OFFSET_NOT_VALID\n", spu_info->scr_nr);
     return 0;
   }
   PTS_TO_CLOCKTIME(next_time, spu_info->next_time);
@@ -1210,10 +1258,14 @@
   //  timesub(&errtime, &spu_info->next_time, &realtime);
 
   if(TIME_SS(errtime) < 0 || TIME_S(errtime) < 0) {
-    //DNOTE("spu: errtime: %ld.%09ld\n",TIME_S(errtime),TIME_SS(errtime));
+#if 0
+    DNOTE("spu: errtime: %s%ld.%09ld\n", 
+	  (TIME_S(errtime) < 0 || TIME_SS(errtime) < 0 ? "-": ""),
+	  TIME_S(errtime),
+	  (TIME_SS(errtime) < 0 ? -TIME_SS(errtime) : TIME_SS(errtime)));
+#endif
     return 1;
   }
-  
   return 0;
 }
 
@@ -1274,7 +1326,7 @@
   }
 
 
-  if(spu_info.display_start /* || spu_info.menu */) {
+  if(spu_info.display_start & spu_state) {
     
     palette = palette_rgb;
 
@@ -1317,7 +1369,8 @@
   }
 
 
-  if(spu_info.display_start /* || spu_info.menu */) {
+  if(spu_info.display_start & spu_state) {
+    
     int width = img->info->picture.padded_width;
     int height = img->info->picture.padded_height;
     //DNOTE("decoding data\n");
@@ -1326,7 +1379,10 @@
     mix_function = display_mix_function_yuv;
     
     //ugly hack
-    if(img->info->is_reference || (ctrl_data->speed < 1.0)) {
+    //If picture is used as reference (mpeg reference picture) we can't
+    // mix into it.
+    //We can't rely on that there is a new picture for every spu.
+    if(1 || img->info->is_reference || (ctrl_data->speed < 1.0)) {
       int size;
       size = width * height;
       memcpy(reserv->y, img->y, size);
@@ -1344,7 +1400,7 @@
 
 
 
-void flush_subpicture(int scr_id)
+void flush_subpicture(int scr_id, int32_t nav_serial)
 {
   /*
    * Check for, and execute all pending spu command sequences.
@@ -1357,7 +1413,7 @@
   
   //DNOTE("spu: flush_subpicture to scr_id: %d\n", scr_id);
   flush_to_scrid = scr_id;
-
+  flush_to_navserial = nav_serial;
   while(next_spu_cmd_pending(&spu_info)) {
 
     if(spu_info.next_DCSQ_offset == spu_info.last_DCSQ) {
@@ -1379,3 +1435,13 @@
     spu_info.next_time = 0;
   }
 }
+
+int poll_subpicture(void)
+{
+  //ugly hack
+  if(!initialized) {
+    return 0;
+  }
+
+  return next_spu_cmd_pending(&spu_info);
+}
diff -urN -x CVS -x .cvsignore ogle-0.9.2/mpeg2_video/spu_mixer.h ogle/mpeg2_video/spu_mixer.h
--- ogle-0.9.2/mpeg2_video/spu_mixer.h	2003-10-20 18:34:33.000000000 +0200
+++ ogle/mpeg2_video/spu_mixer.h	2006-01-25 17:54:11.000000000 +0100
@@ -27,7 +27,8 @@
 
 int init_spu(void);
 
-void flush_subpicture(int scr_nr);
+void flush_subpicture(int scr_nr, int32_t nav_serial);
+int poll_subpicture(void);
 
 #endif /* SPU_MIXER_H_INCLUDED */
 
diff -urN -x CVS -x .cvsignore ogle-0.9.2/mpeg2_video/video_mpeg2.c ogle/mpeg2_video/video_mpeg2.c
--- ogle-0.9.2/mpeg2_video/video_mpeg2.c	2002-11-03 17:13:34.000000000 +0100
+++ ogle/mpeg2_video/video_mpeg2.c	2005-10-02 02:14:34.000000000 +0200
@@ -1536,6 +1536,7 @@
   } while(((seq.mb_column + 1) < seq.mb_width) && (nextbits(23) != 0));
   
   DINDENT(-2);
+  DINDENT(-2);
 }
 
 
diff -urN -x CVS -x .cvsignore ogle-0.9.2/mpeg2_video/video_output.c ogle/mpeg2_video/video_output.c
--- ogle-0.9.2/mpeg2_video/video_output.c	2003-09-17 11:29:32.000000000 +0200
+++ ogle/mpeg2_video/video_output.c	2006-12-12 21:01:55.000000000 +0100
@@ -21,10 +21,14 @@
 #include <unistd.h>
 
 #include <signal.h>
-#include <sys/shm.h>
+
 #include <time.h>
 #include <errno.h>
 
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
 #ifdef __bsdi__
 #include <sys/param.h>
 #include <sys/sysctl.h>
@@ -43,15 +47,14 @@
 #include "video_types.h"
 #include "timemath.h"
 #include "sync.h"
+#include "shm.h"
+
 #include "spu_mixer.h"
 #include "video_output.h"
 #include "xscreensaver-comm.h"
 
 #include "screenshot.h"
 
-#ifndef SHM_SHARE_MMU
-#define SHM_SHARE_MMU 0
-#endif
 
 extern void display_init(int padded_width, int padded_height,
 		  int picture_buffer_shmid,
@@ -66,7 +69,7 @@
 int register_event_handler(int(*eh)(MsgEventQ_t *, MsgEvent_t *));
 int event_handler(MsgEventQ_t *q, MsgEvent_t *ev);
 
-
+static int print_fps = 1;
 char *program_name;
 int dlevel;
 
@@ -93,11 +96,17 @@
 ctrl_data_t *ctrl_data;
 ctrl_time_t *ctrl_time;
 
+#ifdef SOCKIPC
+#else
 int msgqid = -1;
+#endif
+
 MsgEventQ_t *msgq;
 
 
+
 static int flush_to_scrid = -1;
+int *video_flush_to_scrid = &flush_to_scrid;
 static int prev_scr_nr = 0;
 
 
@@ -179,19 +188,20 @@
     return 0;
   }
 
-  if(shmid >= 0) {
-    if((shmaddr = shmat(shmid, NULL, SHM_SHARE_MMU)) == (void *)-1) {
+  if(shmid != -1) {
+    if((shmaddr = ogle_shmat(shmid)) == (void *)-1) {
       ERROR("%s", "attach_ctrl_data()\n");
       perror("shmat");
       return -1;
     }
-    
+
     ctrl_data_shmid = shmid;
     ctrl_data = (ctrl_data_t*)shmaddr;
     ctrl_time = (ctrl_time_t *)(shmaddr+sizeof(ctrl_data_t));
   }    
   
   return 0;
+
 }
 
 
@@ -212,35 +222,37 @@
 #endif
   
   //DNOTE("attach_data_q: q_shmid: %d\n", q_shmid);
-  
-  if(q_shmid < 0) {
-    ERROR("%s", "attach_data_q(), q_shmid < 0\n");
+
+
+  if(q_shmid == -1) {
+    ERROR("%s", "attach_data_q(), q_shmid == -1\n");
     return -1;
   }
-  if((q_shmaddr = shmat(q_shmid, NULL, SHM_SHARE_MMU)) == (void *)-1) {
+  if((q_shmaddr = ogle_shmat(q_shmid)) == (void *)-1) {
     ERROR("%s", "attach_data_q()\n");
     perror("shmat");
     return -1;
   }
+  
 
   q_head = (q_head_t *)q_shmaddr;
   q_elems = (q_elem_t *)(q_shmaddr+sizeof(q_head_t));
-
+  
   data_shmid = q_head->data_buf_shmid;
-
+  
   //DNOTE("attach_data_q: data_shmid: %d\n", data_shmid);
-
-  if(data_shmid < 0) {
+  
+  if(data_shmid == -1) {
     ERROR("%s", "attach_data_q(), data_shmid\n");
     return -1;
   }
-
-  if((data_shmaddr = shmat(data_shmid, NULL, SHM_SHARE_MMU)) == (void *)-1) {
+  
+  if((data_shmaddr = ogle_sysv_shmat(data_shmid)) == (void *)-1) {
     ERROR("%s", "attach_data_q()");
     perror("shmat");
     return -1;
   }
-    
+  
   data_head = (data_buf_head_t *)data_shmaddr;
   
   data_elems = (picture_data_elem_t *)(data_shmaddr + 
@@ -308,12 +320,12 @@
 
   client = (*data_q_p)->q_head->writer;
 
-  if(shmdt((char *)(*data_q_p)->data_head) == -1) {
+  if(ogle_sysv_shmdt((*data_q_p)->data_head) == -1) {
     ERROR("%s", "detach_data_q data_head");
     perror("shmdt");
   }
   
-  if(shmdt((char *)(*data_q_p)->q_head) == -1) {
+  if(ogle_shmdt((*data_q_p)->q_head) == -1) {
     ERROR("%s", "detach_data_q q_head");
     perror("shmdt");
   }
@@ -399,6 +411,9 @@
 
   if(flush_to_scrid != -1) {
     if(ctrl_time[video_scr_nr].scr_id < flush_to_scrid) {
+      if(last_image_buf != NULL) {
+	display(last_image_buf);    
+      }
       redraw_done();
       return;
     } else {
@@ -442,8 +457,12 @@
     break;
   case MsgEventQFlushData:
     DPRINTF(1, "vo: got flush\n");
+#ifdef NAV_SEARCH_DEBUG
+    fprintf(stderr, "\n************\nvo: got flush: %d, %d\n*********\n",
+	    ev->flushdata.to_scrid, ev->flushdata.to_navserial);
+#endif
     flush_to_scrid = ev->flushdata.to_scrid;
-    flush_subpicture(flush_to_scrid);
+    flush_subpicture(flush_to_scrid, ev->flushdata.to_navserial);
     break;
   case MsgEventQAttachQ:
     attach_picture_buffer(ev->attachq.q_shmid);
@@ -496,6 +515,9 @@
       set_speed(&ctrl_time[prev_scr_nr].sync_point, ev->speed.speed);
     }
     break;
+  case MsgEventQStop:
+    set_videostate(ev->stop.state);
+    break;
   case MsgEventQSaveScreenshot:
     if(ev->savescreenshot.formatstr[0]) {
       screenshot_set_formatstr(ev->savescreenshot.formatstr);
@@ -648,6 +670,7 @@
 {
   int elem;
   MsgEvent_t ev;
+  volatile int *in_use;
   struct itimerval timer;
   timer.it_interval.tv_sec = 0;
   timer.it_interval.tv_usec = 0;
@@ -659,11 +682,12 @@
   data_q->q_head->read_nr =
     (data_q->q_head->read_nr+1)%data_q->q_head->nr_of_qelems;
 
-  if(!data_q->q_elems[elem].in_use) {
+  in_use = &(data_q->q_elems[elem].in_use); 
+  if(!*in_use) {
     data_q->q_head->reader_requests_notification = 1;
     //DNOTE("elem not in use, setting notification req\n");
 
-    while(!data_q->q_elems[elem].in_use) {
+    while(!*in_use) {
       if(process_interrupted) {
 	// might never have had dispay_init called
 	display_exit();
@@ -674,7 +698,12 @@
       if(MsgNextEventInterruptible(msgq, &ev) == -1) {
 	switch(errno) {
 	case EINTR:
-	  continue;
+	  timer.it_value.tv_usec = 0; // disable timer
+	  setitimer(ITIMER_REAL, &timer, NULL);
+	  if(poll_subpicture()) {
+	    redraw_request();
+	  }
+	  //  continue;
 	  break;
 	default:
 	  FATAL("%s", "waiting for notification");
@@ -683,10 +712,11 @@
 	  display_exit(); //clean up and exit
 	  break;
 	}
+      } else {
+	timer.it_value.tv_usec = 0; // disable timer
+	setitimer(ITIMER_REAL, &timer, NULL);
+	event_handler(msgq, &ev);
       }
-      timer.it_value.tv_usec = 0; // disable timer
-      setitimer(ITIMER_REAL, &timer, NULL);
-      event_handler(msgq, &ev);
       if(redraw_needed) {
 	redraw_screen();
       }
@@ -723,7 +753,7 @@
       if(process_interrupted) {
 	display_exit();
       }
-      if(MsgSendEvent(msgq, data_q->q_head->writer, &ev, IPC_NOWAIT) == -1) {
+      if(MsgSendEvent(msgq, data_q->q_head->writer, &ev, 0) == -1) {
 	MsgEvent_t c_ev;
 	switch(errno) {
 	case EAGAIN:
@@ -824,7 +854,7 @@
   int avg_nr = 23;
   picture_data_elem_t *pinfos;
   data_q_t *old_data_q = NULL;
-  
+
   TIME_S(prefered_time) = 0;
   
   sig.sa_handler = int_handler;
@@ -873,7 +903,12 @@
     video_scr_nr = pinfos[buf_id].scr_nr;
     
     // Consume all messages for us and spu_mixer
+#ifdef SOCKIPC
+#warning "todo"
+    {
+#else
     if(msgqid != -1) {
+#endif
       MsgEvent_t ev;
       while(MsgCheckEvent(msgq, &ev) != -1) {
 	event_handler(msgq, &ev);
@@ -1005,13 +1040,14 @@
       oavg_time = avg_time;
       clocktime_get(&avg_time);
       
-      fprintf(stderr, "display: frame rate: %.3f fps\n",
-	      200.0/(((double)TIME_S(avg_time)+
-		      (double)TIME_SS(avg_time)/CT_FRACTION)-
-		     ((double)TIME_S(oavg_time)+
-		      (double)TIME_SS(oavg_time)/CT_FRACTION))
-	      );
-
+      if(print_fps) {
+	fprintf(stderr, "display: frame rate: %.3f fps\n",
+		200.0/(((double)TIME_S(avg_time)+
+			(double)TIME_SS(avg_time)/CT_FRACTION)-
+		       ((double)TIME_S(oavg_time)+
+			(double)TIME_SS(oavg_time)/CT_FRACTION))
+		);
+      }
     }
     /*
     clocktime_get(&real_time2);
@@ -1078,19 +1114,34 @@
 	  program_name);
 }
 
+
 int main(int argc, char **argv)
 {
   MsgEvent_t ev;
   int c; 
-
+#ifdef SOCKIPC
+  char *msgqid;
+  MsgEventQType_t msgq_type;
+#endif
   program_name = argv[0];
   GET_DLEVEL();
-
+  char *ep;
+  if((ep = getenv("OGLE_PRINT_FPS")) && !strcmp(ep, "0")) {
+    print_fps = 0;
+  }
+  
   /* Parse command line options */
   while ((c = getopt(argc, argv, "m:h?")) != EOF) {
     switch (c) {
     case 'm':
+#ifdef SOCKIPC
+      if(get_msgqtype(optarg, &msgq_type, &msgqid) == -1) {
+	fprintf(stderr, "unknown msgq type\n");
+	return 1;
+      }
+#else
       msgqid = atoi(optarg);
+#endif
       break;
     case 'h':
     case '?':
@@ -1099,12 +1150,15 @@
     }
   }
 
+#ifdef SOCKIPC
+#else
   if(msgqid == -1) {
     if(argc - optind != 1){
       usage();
       return 1;
     }
   }
+#endif
   
   errno = 0;
 
@@ -1129,9 +1183,17 @@
 
   DNOTE("CLK_TCK: %ld\n", clk_tck);
 
+#ifdef SOCKIPC
+#warning "not impl"
+#else
   if(msgqid != -1) {
-    
+#endif
+
+#ifdef SOCKIPC
+    if((msgq = MsgOpen(msgq_type, msgqid, strlen(msgqid))) == NULL) {
+#else
     if((msgq = MsgOpen(msgqid)) == NULL) {
+#endif
       FATAL("%s", "couldn't get message q\n");
       exit(1);
     }
@@ -1177,10 +1239,13 @@
 
     display_process();
     
+#ifdef SOCKIPC
+#warning "not impl"
+#else
   } else {
     fprintf(stderr, "what?\n");
   }
-  
+#endif
   exit(0);
 }
 
diff -urN -x CVS -x .cvsignore ogle-0.9.2/mpeg2_video/video_output_ffb.c ogle/mpeg2_video/video_output_ffb.c
--- ogle-0.9.2/mpeg2_video/video_output_ffb.c	1970-01-01 01:00:00.000000000 +0100
+++ ogle/mpeg2_video/video_output_ffb.c	2001-07-27 11:43:04.000000000 +0200
@@ -0,0 +1,800 @@
+/* Ogle - A video player
+ * Copyright (C) 2000, 2001 Björn Englund, Håkan Hjort
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+
+
+#ifdef HAVE_MLIB
+#include <mlib_types.h>
+#include <mlib_status.h>
+#include <mlib_sys.h>
+#include <mlib_video.h>
+#include <mlib_algebra.h>
+#include <mlib_image.h>
+#else /* ! HAVE_MLIB */
+#ifdef HAVE_MMX
+#include "mmx.h"
+#endif /* HAVE_MMX */
+#include "c_mlib.h"
+#endif /* ! HAVE_MLIB */
+
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+#include <X11/extensions/XShm.h>
+#include <sys/types.h>
+#include <sys/ipc.h>
+#include <sys/shm.h>
+
+#include <sys/mman.h>
+#include "common.h"
+#include "video_types.h"
+#include "yuv2rgb.h"
+#include "screenshot.h"
+
+
+int ffb_fd;
+char *ffb_start;
+
+#ifdef HAVE_XV
+#include <X11/extensions/Xv.h>
+#include <X11/extensions/Xvlib.h>
+static XvPortID xv_port;
+static XvImage *xv_image;
+static unsigned int xv_version;
+static unsigned int xv_release;
+static unsigned int xv_request_base;
+static unsigned int xv_event_base;
+static unsigned int xv_error_base;
+static unsigned int xv_num_adaptors;
+static unsigned int xv_num_formats;
+static XvAdaptorInfo *xv_adaptor_info;
+static XvImageFormatValues *xv_formats;
+static int xv_id;
+
+#endif /* HAVE_XV */
+
+typedef struct {
+  Window win;
+  unsigned char *data;
+  XImage *ximage;
+  yuv_image_t *image;
+  int grid;
+  int color_grid;
+  macroblock_t *mbs;
+} debug_win;
+
+static debug_win windows[1];
+
+
+static XVisualInfo vinfo;
+static XShmSegmentInfo shm_info;
+static Display *mydisplay;
+static Window window_stat;
+static GC mygc;
+static GC statgc;
+static char *title = "Mjölner";
+static int color_depth, pixel_stride, mode;
+
+
+extern unsigned int debug;
+static int show_window[1] = {1};
+static int run = 0;
+static int screenshot = 0;
+static int scaled_image_width;
+static int scaled_image_height;
+#ifdef HAVE_MLIB
+static int scalemode = MLIB_BILINEAR;
+static int scalemode_change = 0;
+#endif /* HAVE_MLIB */
+
+
+extern void display_process_exit(void);
+
+void exit_program(int);
+
+static void draw_win(debug_win *dwin);
+
+void display_init(int padded_width, int padded_height,
+		  int horizontal_size, int vertical_size)
+{
+  int screen;
+  
+  XSizeHints hint;
+  XEvent xev;
+  XGCValues xgcv;
+  Colormap theCmap;
+  XWindowAttributes attribs;
+  XSetWindowAttributes xswa;
+  unsigned long xswamask;
+
+
+  mydisplay = XOpenDisplay(NULL);
+
+  if (mydisplay == NULL)
+    fprintf(stderr,"Can not open display\n");
+
+  /* Check for availability of shared memory */
+  if (!XShmQueryExtension(mydisplay)) {
+    fprintf(stderr, "No shared memory available!\n");
+    exit(1);
+  }
+
+  screen = DefaultScreen(mydisplay);
+
+  hint.x = 0;
+  hint.y = 0;
+  hint.width = horizontal_size;
+  hint.height = vertical_size;
+  hint.flags = PPosition | PSize;
+
+  /* Scale init. */
+  scaled_image_width = horizontal_size;
+  scaled_image_height = vertical_size;
+  
+  /* Make the window */
+  XGetWindowAttributes(mydisplay, DefaultRootWindow(mydisplay), &attribs);
+  color_depth = attribs.depth;
+  if (color_depth != 15 && color_depth != 16 && 
+      color_depth != 24 && color_depth != 32) {
+    fprintf(stderr,"Only 15,16,24, and 32bpp supported. Trying 24bpp!\n");
+    color_depth = 24;
+  }
+  
+  XMatchVisualInfo(mydisplay,screen,color_depth,TrueColor,&vinfo);
+  printf("visual id is  %lx\n",vinfo.visualid);
+
+  theCmap   = XCreateColormap(mydisplay, RootWindow(mydisplay,screen), 
+			      vinfo.visual, AllocNone);
+
+  xswa.background_pixel = 0;
+  xswa.border_pixel     = 1;
+  xswa.colormap         = theCmap;
+  xswamask = CWBackPixel | CWBorderPixel | CWColormap;
+
+  windows[0].win = XCreateWindow(mydisplay, RootWindow(mydisplay,screen),
+				 hint.x, hint.y, hint.width, hint.height, 
+				 4, color_depth, CopyFromParent, vinfo.visual, 
+				 xswamask, &xswa);
+
+  window_stat = XCreateSimpleWindow(mydisplay, RootWindow(mydisplay,screen),
+				    hint.x, hint.y, 200, 200, 0,
+				    0, 0);
+
+  XSelectInput(mydisplay, windows[0].win, StructureNotifyMask | KeyPressMask 
+	       | ButtonPressMask | ExposureMask);
+  XSelectInput(mydisplay, window_stat, StructureNotifyMask | KeyPressMask 
+	       | ButtonPressMask | ExposureMask);
+
+  /* Tell other applications about this window */
+  XSetStandardProperties(mydisplay, windows[0].win, 
+			 title, title, None, NULL, 0, &hint);
+  XSetStandardProperties(mydisplay, window_stat, 
+			 "stat", "stat", None, NULL, 0, &hint);
+
+  /* Map window. */
+  XMapWindow(mydisplay, window_stat);
+  XMapWindow(mydisplay, windows[0].win);
+  
+  
+  // This doesn't work correctly
+  /* Wait for map. */
+  do {
+    XNextEvent(mydisplay, &xev);
+  }
+  while (xev.type != MapNotify || xev.xmap.event != windows[0].win);
+  
+  //   XSelectInput(mydisplay, mywindow, NoEventMask);
+
+  XFlush(mydisplay);
+  XSync(mydisplay, False);
+   
+  /* Create the colormaps. */   
+  mygc = XCreateGC(mydisplay, windows[0].win, 0L, &xgcv);
+  statgc = XCreateGC(mydisplay, window_stat, 0L, &xgcv);
+   
+#ifdef HAVE_XV
+  /* This section of the code looks for the Xv extension for hardware
+   * yuv->rgb and scaling. If it is not found, or any suitable adapter
+   * is not found, it just falls through to the other code. Otherwise it
+   * returns
+   *
+   * The variable xv_port tells if Xv is used */
+  {
+    int result;
+
+    xv_port = 0; /* We have no port yet. */
+
+    /* Check for the Xvideo extension */
+    result = XvQueryExtension (mydisplay, &xv_version, &xv_release, 
+                               &xv_request_base, &xv_event_base, 
+                               &xv_error_base);
+    if (result == Success) {
+      fprintf (stderr, "Found Xv extension, checking for suitable adaptors\n");
+      /* Check for available adaptors */
+      result = XvQueryAdaptors (mydisplay, DefaultRootWindow (mydisplay), 
+                                &xv_num_adaptors, &xv_adaptor_info);
+      if (result == Success) {
+        int i, j;
+
+        /* Check adaptors */
+        for (i = 0; i < xv_num_adaptors; i++) {
+          if ((xv_adaptor_info[i].type & XvInputMask) &&
+              (xv_adaptor_info[i].type & XvImageMask)) { 
+            xv_port = xv_adaptor_info[i].base_id;
+            fprintf(stderr, 
+                    "Found adaptor \"%s\" checking for suitable formats\n",
+                    xv_adaptor_info[i].name);
+            /* Check image formats of adaptor */
+            xv_formats = XvListImageFormats (mydisplay, xv_port, 
+                                             &xv_num_formats);
+            for (j = 0; j < xv_num_formats; j++) {
+              if (xv_formats[j].id == 0x32315659) { /* where is this from? */
+                fprintf (stderr, "Found image format \"%s\", using it\n", 
+                       xv_formats[j].guid);
+                xv_id = xv_formats[j].id;
+                break;
+              } 
+            }
+            if (j != xv_num_formats) { /* Found matching format */
+              fprintf (stderr, "Using Xvideo port %li for hw scaling\n", xv_port);
+              /* allocate XvImages */
+              xv_image = XvShmCreateImage (mydisplay, xv_port, xv_id, NULL,
+                                            padded_width, padded_height, 
+                                            &shm_info);
+              shm_info.shmid = shmget (IPC_PRIVATE, xv_image->data_size, 
+                                         IPC_CREAT | 0777);
+              shm_info.shmaddr = shmat (shm_info.shmid, 0, 0);
+              shm_info.readOnly = FALSE;
+              xv_image->data = shm_info.shmaddr;
+              XShmAttach (mydisplay, &shm_info);
+              XSync (mydisplay, FALSE);
+              shmctl (shm_info.shmid, IPC_RMID, 0);
+              memset (xv_image->data, 128, xv_image->data_size); /* grayscale */
+
+              return; /* All set up! */
+            } else {
+              xv_port = 0;
+            }
+          }
+        } 
+      } 
+    }
+  }
+#endif /* HAVE_XV */
+
+  /* Create shared memory image */
+  windows[0].ximage = XShmCreateImage(mydisplay, vinfo.visual, color_depth,
+				      ZPixmap, NULL, &shm_info,
+				      padded_width,
+				      padded_height);
+  
+  if (windows[0].ximage == NULL) {
+    fprintf(stderr, "Shared memory: couldn't create Shm image\n");
+    goto shmemerror;
+  }
+  
+  /* Get a shared memory segment */
+  shm_info.shmid = shmget(IPC_PRIVATE,
+			  windows[0].ximage->bytes_per_line * 
+			  windows[0].ximage->height, 
+			  IPC_CREAT | 0777);
+  
+  if (shm_info.shmid < 0) {
+    fprintf(stderr, "Shared memory: Couldn't get segment\n");
+    goto shmemerror;
+  }
+  
+  /* Attach shared memory segment */
+  shm_info.shmaddr = (char *) shmat(shm_info.shmid, 0, 0);
+  if (shm_info.shmaddr == ((char *) -1)) {
+    fprintf(stderr, "Shared memory: Couldn't attach segment\n");
+    goto shmemerror;
+  }
+  
+  windows[0].ximage->data = shm_info.shmaddr;
+  shm_info.readOnly = False;
+  XShmAttach(mydisplay, &shm_info);
+  XSync(mydisplay, 0);
+
+  windows[0].data = windows[0].ximage->data;
+  
+  pixel_stride = windows[0].ximage->bits_per_pixel;
+  // If we have blue in the lowest bit then obviously RGB 
+  mode = ((windows[0].ximage->blue_mask & 0x01) != 0) ? 1 : 2;
+  /*
+#ifdef WORDS_BIGENDIAN 
+  if (windows[0].ximage->byte_order != MSBFirst)
+#else
+  if (windows[0].ximage->byte_order != LSBFirst) 
+#endif
+  {
+    fprintf( stderr, "No support for non-native XImage byte order!\n" );
+    exit(1);
+  }
+  */
+
+  if((ffb_fd = open("/dev/fb", O_RDWR)) == NULL) {
+    perror("ffb open");
+  }
+  
+  ffb_start = mmap(NULL, 0x800000, PROT_READ | PROT_WRITE,
+		   MAP_SHARED, ffb_fd, 0x06004000);
+
+  yuv2rgb_init(pixel_stride, mode);
+  
+  return;
+  
+ shmemerror:
+  exit(1);
+
+}
+
+void display_change_size(int new_width, int new_height) {
+  int padded_width = windows[0].image->padded_width;
+  int padded_height = windows[0].image->padded_height;
+  
+  // Check to not 'reallocate' if the size is the same or less than 
+  // minimum size...
+  if( (new_width < padded_width && new_height < padded_height) ||
+      (scaled_image_width == new_width && scaled_image_height == new_height) ){
+    scaled_image_width = new_width;
+    scaled_image_height = new_height;
+    return;
+  }
+  
+  /* Save the new size so we know what to scale to. */
+  scaled_image_width = new_width;
+  scaled_image_height = new_height;
+  
+  /* Stop events temporarily, while creating new display_image */
+  XSelectInput(mydisplay, windows[0].win, NoEventMask);
+  
+  XSync(mydisplay,True);
+  
+  /* Destroy old display */
+  XShmDetach(mydisplay, &shm_info);
+  XDestroyImage(windows[0].ximage);
+  shmdt(shm_info.shmaddr);
+  if(shm_info.shmaddr == ((char *) -1)) {
+    fprintf(stderr, "Shared memory: Couldn't detache segment\n");
+    exit(-10);
+  }
+  shmctl(shm_info.shmid, IPC_RMID, 0);
+  if(shm_info.shmid == -1) {
+    fprintf(stderr, "Shared memory: Couldn't rm segment\n");
+    exit(-10);
+  }
+  XSync(mydisplay, True);
+  
+  memset( &shm_info, 0, sizeof( XShmSegmentInfo ) );
+  
+  /* Create new display */
+  windows[0].ximage = XShmCreateImage(mydisplay, vinfo.visual, 
+				      color_depth, ZPixmap, 
+				      NULL, &shm_info,
+				      scaled_image_width,
+				      scaled_image_height);
+  
+  if(windows[0].ximage == NULL) {
+    fprintf(stderr, "Shared memory: couldn't create Shm image\n");
+    exit(-10);
+  }
+  
+  /* Get a shared memory segment */
+  shm_info.shmid = shmget(IPC_PRIVATE,
+			  windows[0].ximage->bytes_per_line * 
+			  windows[0].ximage->height, 
+			  IPC_CREAT | 0777);
+  
+  if(shm_info.shmid < 0) {
+    fprintf(stderr, "Shared memory: Couldn't get segment\n");
+    exit(-10);
+  }
+  
+  /* Attach shared memory segment */
+  shm_info.shmaddr = (char *) shmat(shm_info.shmid, 0, 0);
+  if(shm_info.shmaddr == ((char *) -1)) {
+    fprintf(stderr, "Shared memory: Couldn't attach segment\n");
+    exit(-10);
+  }
+  
+  windows[0].ximage->data = shm_info.shmaddr;
+  windows[0].data = windows[0].ximage->data;
+  
+  shm_info.readOnly = False;
+  XShmAttach(mydisplay, &shm_info);
+  
+  XSync(mydisplay, 0);
+  
+  
+  /* Force a change of the widow size. */
+  XResizeWindow(mydisplay, windows[0].win, 
+		scaled_image_width, scaled_image_height);
+  
+  /* Turn on events */
+  XSelectInput(mydisplay, windows[0].win, StructureNotifyMask 
+	       | KeyPressMask | ButtonPressMask | ExposureMask);
+}
+
+void display_exit(void) 
+{
+  // Need to add some test to se if we can detatch/free/destroy things
+  XShmDetach(mydisplay, &shm_info);
+  XDestroyImage(windows[0].ximage);
+  shmdt(shm_info.shmaddr);
+  shmctl(shm_info.shmid, IPC_RMID, 0);
+  display_process_exit();
+}
+
+
+
+ 
+void add_grid(unsigned char *data, XImage *ximg)
+{
+  int m,n;
+  
+  for(m = 0; m < ximg->height; m++) {
+    if(m%16 == 0) {
+      for(n = 0; n < ximg->width*4; n+=4) {
+	data[m*ximg->width*4+n+1] = 127;
+	data[m*ximg->width*4+n+2] = 127;
+	data[m*ximg->width*4+n+3] = 127;
+      }
+    } else {
+      for(n = 0; n < ximg->width*4; n+=16*4) {
+	data[m*ximg->width*4+n+1] = 127;
+	data[m*ximg->width*4+n+2] = 127;
+	data[m*ximg->width*4+n+3] = 127;
+      }
+    }
+  }
+}
+
+
+void add_2_box_sides(unsigned char *data,
+		     unsigned char r, unsigned char g, unsigned char b,
+		     XImage *ximg)
+{
+  int n;
+  
+  for(n = 0; n < 16*4; n+=4) {
+    data[n+1] = b;
+    data[n+2] = g;
+    data[n+3] = r;
+  }
+  
+  for(n = 0; n < ximg->width*4*16; n+=ximg->width*4) {
+    data[n+1] = b;
+    data[n+2] = g;
+    data[n+3] = r;
+  }
+  
+  return;
+}
+
+
+/* This assumes a 720x480 image */
+void add_color_grid(debug_win *win)
+{
+  int m;
+  
+  for(m = 0; m < 30*45; m++) {
+    if(win->mbs[m].skipped) {
+
+      add_2_box_sides(&(win->data[m/45*win->ximage->width*4*16+(m%45)*16*4]),
+		      150, 150, 150, win->ximage);
+      
+    } else if(win->mbs[m].modes.macroblock_intra) {
+
+      add_2_box_sides(&(win->data[m/45*win->ximage->width*4*16+(m%45)*16*4]),
+		      0, 255, 255, win->ximage);
+      
+    } else if(win->mbs[m].modes.macroblock_motion_forward &&
+	      win->mbs[m].modes.macroblock_motion_backward) {
+      
+      add_2_box_sides(&(win->data[m/45*win->ximage->width*4*16+(m%45)*16*4]),
+		      255, 0, 0, win->ximage);
+      
+    } else if(win->mbs[m].modes.macroblock_motion_forward) {
+      
+      add_2_box_sides(&(win->data[m/45*win->ximage->width*4*16+(m%45)*16*4]),
+		      255, 255, 0, win->ximage);
+
+    } else if(win->mbs[m].modes.macroblock_motion_backward) {
+      
+      add_2_box_sides(&(win->data[m/45*win->ximage->width*4*16+(m%45)*16*4]),
+		      0, 0, 255, win->ximage);
+    }
+  }
+}
+
+
+void display(yuv_image_t *current_image)
+{
+  XEvent ev;
+  int nextframe = 0;  
+  
+  windows[0].image = current_image;
+  
+  if(show_window[0]) {
+    draw_win(&windows[0]);
+  }
+  
+  while(!nextframe) {
+
+    if(run) {
+      nextframe = 1;
+      if(XCheckMaskEvent(mydisplay, 0xFFFFFFFF, &ev) == False) {
+	continue;
+      }
+    } else {
+      XNextEvent(mydisplay, &ev);
+    }
+
+    switch(ev.type) {
+    case Expose:
+      if(windows[0].win == ev.xexpose.window)
+	if(show_window[0])
+	  draw_win(&(windows[0]));
+      break;
+#if defined(HAVE_MLIB) || defined(HAVE_XV)
+    case ConfigureNotify:
+      if(ev.xconfigure.window == windows[0].win) {
+	display_change_size( ev.xconfigure.width, ev.xconfigure.height );
+      }
+      break;    
+#endif /* HAVE_MLIB || HAVE_XV */
+    case ButtonPress:
+      switch(ev.xbutton.button) {
+      case 0x1:
+	break;
+      case 0x2:
+	break;
+      case 0x3:
+	break;
+      }
+      break;
+    case KeyPress:
+      {
+	char buff[2];
+	static int debug_change = 0;
+
+	XLookupString(&(ev.xkey), buff, 2, NULL, NULL);
+	buff[1] = '\0';
+	switch(buff[0]) {
+	case 'n':
+	  nextframe = 1;
+	  break;
+	case 'd':
+	  debug_change = 1;
+	  break;
+	case 'w':
+	  show_window[0] = !show_window[0];
+	  break;
+	case 'r':
+	  run = !run;
+	  nextframe = 1;
+	  break;
+	case 'p':
+	  screenshot = 1;
+	  draw_win(&(windows[0]));
+	  break;
+	case 'q':
+	  display_exit();
+	  break;
+	case 's':
+	  scalemode_change = 1;
+	  break;
+	case '1':
+	case '2':
+	case '3':
+	  if(debug_change) 
+	    break; /* Handled below the switch */
+	  else if(scalemode_change) {
+#ifdef HAVE_MLIB
+	    switch(atoi(&buff[0])) {
+	    case 1:
+	      scalemode = MLIB_NEAREST;
+	      break;
+	    case 2:
+	      scalemode = MLIB_BILINEAR;
+	      break;
+	    case 3:
+	      scalemode = MLIB_BICUBIC;
+	      break;
+	    case 4:
+	      scalemode = MLIB_BICUBIC2;
+	      break;
+	    default:
+	      break;
+	    }
+#endif
+	    scalemode_change = 0;	  
+	  }
+	  else { /* Scale size */
+#ifdef HAVE_MLIB
+	    int x = atoi(&buff[0]);
+	    display_change_size(windows[0].image->horizontal_size * x, 
+				windows[0].image->vertical_size * x);
+#endif
+	  }
+	  break;
+	default:
+	  break;
+	} /* end case KeyPress */
+	if(debug_change && buff[0] != 'd') {
+	  debug = atoi(&buff[0]);
+	  debug_change = 0;
+	}
+      }
+      break;
+    default:
+      break;
+    }
+  }
+
+  return;
+}
+
+void draw_win_x11(debug_win *dwin)
+{ 
+  yuv2rgb(ffb_start, dwin->image->y, dwin->image->u, dwin->image->v,
+          dwin->image->padded_width,
+          dwin->image->padded_height,
+          0x2000,
+          dwin->image->padded_width, dwin->image->padded_width/2 );
+  /*
+  if(dwin->grid) {
+    if(dwin->color_grid) {
+      add_color_grid(dwin);
+    } else {  
+      add_grid(dwin->data, dwin->ximage);
+    }       
+  }       
+
+  if(screenshot) {
+    screenshot = 0;
+    screenshot_jpg(dwin->data, dwin->ximage);
+  }
+
+  XShmPutImage(mydisplay, dwin->win, mygc, dwin->ximage, 
+	       0, 0, 0, 0, 
+               dwin->image->horizontal_size, dwin->image->vertical_size, 1);
+  */
+  // XSync(mydisplay, False); or
+  // XFlushmydisplay);
+}
+
+#ifdef HAVE_MLIB
+void draw_win(debug_win *dwin)
+{
+  mlib_image *mimage_s;
+  mlib_image *mimage_d;
+  
+  /* Put the decode rgb data at the end of the data segment. */
+  char *address = dwin->data;
+  
+  int dest_size = dwin->ximage->bytes_per_line * dwin->ximage->height;
+  int sorce_size = dwin->image->padded_width*(pixel_stride/8) * dwin->image->padded_height;
+  
+  int offs = dest_size - sorce_size - 4096;
+  if( offs > 0 )
+    address += offs;
+    
+  // Because mlib_YUV* reads out of bounds we need to make sure that the end
+  // of the picture isn't on the pageboundary for in the last page allocated
+  // There is also something strange with the mlib_ImageZoom in NEAREST mode.
+			      
+  /* We must some how guarantee that the ximage isn't used by X11. 
+     Rigth now it's done by the XSync call at the bottom... */
+  
+  yuv2rgb(ffb_start, dwin->image->y, dwin->image->u, dwin->image->v,
+	  dwin->image->padded_width, 
+	  dwin->image->padded_height, 
+	  0x2000,
+	  dwin->image->padded_width, dwin->image->padded_width/2 );
+  /*
+  if(dwin->grid) {
+    if(dwin->color_grid) {
+      add_color_grid(dwin);
+    } else {  
+      add_grid(dwin->data, dwin->ximage);
+    }       
+  }       
+  
+  if( (scaled_image_width != dwin->image->horizontal_size) ||
+      (scaled_image_height != dwin->image->vertical_size )) {
+    // Destination image
+    mimage_d = mlib_ImageCreateStruct(MLIB_BYTE, 4,
+				      scaled_image_width, 
+				      scaled_image_height,
+				      dwin->ximage->bytes_per_line, 
+				      dwin->data);
+    // Source image 
+    mimage_s = mlib_ImageCreateStruct(MLIB_BYTE, 4, 
+				      dwin->image->horizontal_size, 
+				      dwin->image->vertical_size,
+				      dwin->image->padded_width*4, address);
+    // Extra fast 2x Zoom 
+    if((scaled_image_width == 2 * dwin->image->horizontal_size) &&
+       (scaled_image_height == 2 * dwin->image->vertical_size)) {
+      mlib_ImageZoomIn2X(mimage_d, mimage_s, 
+			 scalemode, MLIB_EDGE_DST_FILL_ZERO);
+    } else {
+      mlib_ImageZoom 
+	(mimage_d, mimage_s,
+	 (double)scaled_image_width/(double)dwin->image->horizontal_size, 
+	 (double)scaled_image_height/(double)dwin->image->vertical_size,
+	 scalemode, MLIB_EDGE_DST_FILL_ZERO);
+    }
+    mlib_ImageDelete(mimage_s);
+    mlib_ImageDelete(mimage_d);
+  }
+  
+  if(screenshot) {
+    screenshot = 0;
+    screenshot_jpg(dwin->data, dwin->ximage);
+  }
+  
+  XShmPutImage(mydisplay, dwin->win, mygc, dwin->ximage, 0, 0, 0, 0, 
+	       scaled_image_width, scaled_image_height, 1);
+  */
+  //TEST
+//  XSync(mydisplay, False);
+}
+#endif /* HAVE_MLIB */
+
+#ifdef HAVE_XV
+void draw_win(debug_win *dwin)
+{
+  unsigned char *dst;
+  int size;
+
+  if (xv_port == 0) { /* No xv found */
+    draw_win_x11(dwin);
+  } else {
+    dst = xv_image->data;
+    /* Copy Y data */
+    size = dwin->image->padded_width*dwin->image->padded_height;
+    memcpy(dst + xv_image->offsets[0], dwin->image->y, size); 
+    /* Copy U data */
+    size = dwin->image->padded_width*dwin->image->padded_height/4;
+    memcpy(dst + xv_image->offsets[1], dwin->image->v, size);
+    /* Copy V data */
+    size = dwin->image->padded_width*dwin->image->padded_height/4;
+    memcpy(dst + xv_image->offsets[2], dwin->image->u, size);
+
+    XvShmPutImage(mydisplay, xv_port, dwin->win, mygc, xv_image, 
+                  0, 0, 
+                  dwin->image->horizontal_size, dwin->image->vertical_size,
+                  0, 0, 
+                  scaled_image_width, scaled_image_height,
+                  False);
+    XFlush(mydisplay);
+  }
+}
+#endif /* HAVE_XV */
+
+#if !defined(HAVE_MLIB) && !defined(HAVE_XV)
+void draw_win(debug_win *dwin)
+{
+   draw_win_x11(dwin);
+}
+#endif /* Neither HAVE_MLIB or HAVE_XV */
+
diff -urN -x CVS -x .cvsignore ogle-0.9.2/mpeg2_video/video_output_x11.c ogle/mpeg2_video/video_output_x11.c
--- ogle-0.9.2/mpeg2_video/video_output_x11.c	2003-11-04 13:02:10.000000000 +0100
+++ ogle/mpeg2_video/video_output_x11.c	2006-12-14 20:26:13.000000000 +0100
@@ -1,5 +1,5 @@
 /* Ogle - A video player
- * Copyright (C) 2000, 2001 Björn Englund, Håkan Hjort
+ * Copyright (C) 2000, 2001, 2005 Björn Englund, Håkan Hjort
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -83,6 +83,10 @@
 #endif /* HAVE_XV */
 
 
+#define DEINTERLACE_TEST
+#ifdef DEINTERLACE_TEST
+static int deint;
+#endif
 //ugly hack
 extern data_q_t *cur_data_q;
 /*
@@ -102,10 +106,8 @@
 
 /* end needed for sun ffb2 */
 
-
 extern int XShmGetEventBase(Display *dpy);
 static int CompletionType;
-static int xshmeventbase;
 
 typedef struct {
   int x0;
@@ -138,6 +140,7 @@
 static Display *mydisplay = NULL;
 static int screen_nr;
 static GC mygc;
+static GC colorkey_gc;
 static char title[100];
 
 static int color_depth, pixel_stride, mode;
@@ -145,10 +148,6 @@
 
 static int screenshot = 0;
 static int screenshot_spu = 0;
-static int view_area_mode = 0;
-static area_t src_view_area;
-static area_t new_view_area;
-
 
 static struct {
   int zoom_n;              /* Zoom factor. */
@@ -166,9 +165,13 @@
 
 static int use_xshm = 1;
 static int use_xv = 1;
+static int use_xvcolorkey = 1;
 
-
+#ifdef SOCKIPC
+#warning "todo"
+#else
 extern int msgqid;
+#endif
 extern yuv_image_t *image_bufs;
 
 extern void display_process_exit(void);
@@ -195,12 +198,28 @@
 static void draw_win_x11(window_info *dwin);
 static void display_change_size(yuv_image_t *img, int new_width, 
 				int new_height, int resize_window);
+static void clear_window(void);
+static void clear_borders(void);
+static void display_adjust_size(yuv_image_t *current_image,
+				int given_width, int given_height);
 
 static Bool true_predicate(Display *dpy, XEvent *ev, XPointer arg)
 {
     return True;
 }
 
+static unsigned int videostate = 1;
+void set_videostate(unsigned int state)
+{
+  videostate = state;
+
+  if(state == 0) {
+    if(mydisplay) {
+      clear_window();
+    }
+  }
+}
+
 static Cursor hidden_cursor;
 
 #ifndef MIN
@@ -259,12 +278,25 @@
 }
 
 
+typedef struct {
+  int major;
+  int available;
+  int use;
+} x_extension_t;
+
+static x_extension_t xshm;
+static x_extension_t xv;
+
 static unsigned long req_serial;
 static int (*prev_xerrhandler)(Display *dpy, XErrorEvent *ev);
 
 static int xshm_errorhandler(Display *dpy, XErrorEvent *ev)
 {
-  if(ev->serial == req_serial) {
+  if(ev->request_code == xshm.major) {
+    if(ev->serial != req_serial) {
+      WARNING("unexpected error serial: %lu, waited for (xshm): %lu\n",
+	    ev->serial, req_serial);
+    }
     /* this could be an error to the xshmattach request 
      * we assume that xshm doesn't work,
      * eg we are using a remote display
@@ -280,12 +312,75 @@
     /* if we get another error we should handle it, 
      * so we give it to the previous errorhandler
      */
-    ERROR("unexpected error serial: %lu, waited for: %lu\n",
+    ERROR("unexpected error serial: %lu, waited for (xshm): %lu\n",
+	  ev->serial, req_serial);
+    return prev_xerrhandler(dpy, ev);
+  }
+}
+
+static int xvgetport_errorhandler(Display *dpy, XErrorEvent *ev)
+{
+  if(ev->request_code == xv.major) {
+    if(ev->serial != req_serial) {
+      WARNING("unexpected error serial: %lu, waited for (xv): %lu\n",
+	      ev->serial, req_serial);
+    }
+    /* this could be an error to the xvgetportattr request
+     * we assume that XV_COLORKEY isn't available,
+     * eg we are not using an overlay with colorkey
+     */
+    WARNING("req_code: %d\n", ev->request_code);
+    WARNING("minor_code: %d\n", ev->minor_code);
+    WARNING("error_code: %d\n", ev->error_code);
+    
+    use_xvcolorkey = 0;
+    WARNING("%s", "XV_COLORKEY not available\n");
+    return 0;
+  } else {
+    /* if we get another error we should handle it,
+     * so we give it to the previous errorhandler
+     */
+    ERROR("unexpected error serial: %lu, waited for (xv): %lu\n",
 	  ev->serial, req_serial);
     return prev_xerrhandler(dpy, ev);
   }
 }
 
+static void set_xv_errorhandler(Display *dpy)
+{
+  int major, event, error;
+  
+  if(XQueryExtension(dpy, "XVideo", &major, &event, &error) == True) {
+    xv.available = 1;
+    xv.major = major;
+  } else {
+    xv.available = 0;
+    xv.major = -1;
+  }
+
+  prev_xerrhandler = XSetErrorHandler(xvgetport_errorhandler);
+}
+
+static void set_xshm_errorhandler(Display *dpy)
+{
+  int major, event, error;
+  
+  if(XQueryExtension(dpy, "MIT-SHM", &major, &event, &error) == True) {
+    xshm.available = 1;
+    xshm.major = major;
+  } else {
+    xshm.available = 0;
+    xshm.major = -1;
+  }
+  
+  prev_xerrhandler = XSetErrorHandler(xshm_errorhandler);
+}
+
+static void set_prev_errorhandler(void)
+{
+  XSetErrorHandler(prev_xerrhandler);
+}
+
 /* This section of the code looks for the Xv extension for hardware
  * yuv->rgb and scaling. If it is not found, or any suitable adapter
  * is not found, use_xv will be set to 0. Otherwise it allocates a
@@ -299,9 +394,9 @@
 {
   int xv_found = 0;
 #ifdef HAVE_XV
-  int i, j;
+  int i, j, k;
   int result;
-
+  int n;
   xv_port = 0; /* We have no port yet. */
   
   /* Check for the Xvideo extension */
@@ -318,7 +413,7 @@
        xv_version, xv_release);
   
   /* Check for available adaptors */
-  result = XvQueryAdaptors(mydisplay, DefaultRootWindow (mydisplay), 
+  result = XvQueryAdaptors(mydisplay, window.win, 
 			   &xv_num_adaptors, &xv_adaptor_info);
   if(result != Success) {
     WARNING("%s", "No Xv adaptors found\n");
@@ -333,26 +428,45 @@
     if(!(xv_adaptor_info[i].type & XvInputMask) ||
        !(xv_adaptor_info[i].type & XvImageMask))
       continue;
-    
-    xv_port = xv_adaptor_info[i].base_id;
-      
-    /* Check image formats of adaptor */
-    xv_formats = XvListImageFormats(mydisplay, xv_port, &xv_num_formats);
-    for(j = 0; j < xv_num_formats; j++) {
-      if(xv_formats[j].id == 0x32315659) { /* YV12 */
-	//if(xv_formats[j].id == 0x30323449) { /* I420 */
-	xv_id = xv_formats[j].id;
-	break;
-      } 
-    }
-    /* No matching format found */
-    if(j == xv_num_formats)
-      continue;
+
+    /* Check Available Ports */
+    for (j = 0; j <  xv_adaptor_info[i].num_ports && !xv_port ; j++) {
       
-    NOTE("Xv adaptor \"%s\" port %li image format %i\n",
-	 xv_adaptor_info[i].name, xv_port, xv_id);
+      /* Check Image formats of adaptor */
+      xv_formats = XvListImageFormats(mydisplay, 
+				      xv_adaptor_info[i].base_id + j,
+				      &xv_num_formats);
+      for (k = 0; k < xv_num_formats; k ++) {
+	/* Check for proper format (YV12) and see if we can grab the port */
+	if ( (xv_formats[k].id == 0x32315659) &&
+	     (XvGrabPort(mydisplay,xv_adaptor_info[i].base_id+j,0) == Success)
+	     ) {
+	  xv_id = xv_formats[k].id;
+	  xv_port = xv_adaptor_info[i].base_id + j;
+	  break;
+	}	
+      }
       
-    /* Allocate XvImages */
+      /* delete stuff nicely */
+      XFree(xv_formats);
+    }
+    
+    /* Check next Adapter */
+    if (xv_port==0) continue;
+    
+    /* Report what we found */
+
+    NOTE("Xv adaptor \"%s\" port %li image format 0x%X (%c%c%c%c)\n", xv_adaptor_info[i].name, xv_port, xv_id,
+	 ((unsigned char *)&xv_id)[0],
+	 ((unsigned char *)&xv_id)[1],
+	 ((unsigned char *)&xv_id)[2],
+	 ((unsigned char *)&xv_id)[3]);
+    
+    DNOTE("Xv createimage %dx%d\n", padded_width, padded_height);
+
+    DNOTE("XvShmCreateImage: %ld\n", NextRequest(mydisplay));
+
+    /* Allocate XvImage */
     xv_image = XvShmCreateImage(mydisplay, xv_port, xv_id, NULL,
 				padded_width,
 				padded_height, 
@@ -362,7 +476,7 @@
     if(xv_image == NULL)
       continue;
     
-    /* Test and see if we really got padded_width x padded_height */
+  /* Test and see if we really got padded_width x padded_height */
     if(xv_image->width != padded_width ||
        xv_image->height != padded_height) {
       FATAL("XvShmCreateImage got size: %d x %d\n",
@@ -372,30 +486,37 @@
     
     shm_info.shmid = picture_buffer_shmid;
     shm_info.shmaddr = picture_buffer_addr;
-    
+
     /* Set the data pointer to the decoders picture segment. */  
     //    xv_image->data = picture_data->y;
     shm_info.readOnly = True;
-    
-    /* make sure we don't have any unhandled errors */
-    XSync(mydisplay, False);
-    
-    /* set error handler so we can check if xshmattach failed */
-    prev_xerrhandler = XSetErrorHandler(xshm_errorhandler);
-    
-    /* get the serial of the xshmattach request */
-    req_serial = NextRequest(mydisplay);
-    
-    /* try to attach */
-    XShmAttach(mydisplay, &shm_info);
-    
-    /* make sure xshmattach has been processed and any errors
-       have been returned to us */
-    XSync(mydisplay, False);
-    
-    /* revert to the previous xerrorhandler */
-    XSetErrorHandler(prev_xerrhandler);
-    
+
+    /* Try to use xshm if use_xshm is set.
+       If it fails, use_xshm will be set to 0
+    */
+    if(use_xshm) {
+      /* make sure we don't have any unhandled errors */
+      XSync(mydisplay, False);
+      
+      /* set error handler so we can check if xshmattach failed */
+      set_xshm_errorhandler(mydisplay);
+      
+      /* get the serial of the xshmattach request */
+      req_serial = NextRequest(mydisplay);
+      
+      /* try to attach */
+      if(!XShmAttach(mydisplay, &shm_info)) {
+	ERROR("xshmattach failed\n");
+      }
+      
+      /* make sure xshmattach has been processed and any errors
+	 have been returned to us */
+      XSync(mydisplay, False);
+      
+      /* revert to the previous xerrorhandler */
+      set_prev_errorhandler();
+    }
+
     if(use_xshm) {
 #if 0
       shmctl(shm_info.shmid, IPC_RMID, 0); // only works on Linux..
@@ -404,11 +525,48 @@
       CompletionType = XShmGetEventBase(mydisplay) + ShmCompletion;
     }
     xv_found = 1;
-
-    /* All set up! */
+    
+    /* clear window with colorkey in case XV_AUTOPAINT_COLORKEY isn't enabled*/
+    {
+      char const * const attr_name = "XV_COLORKEY";
+      Atom attr_atom = XInternAtom(mydisplay, attr_name, False);
+      unsigned int val;
+      long ret;
+      
+      /* set error handler so we can check if xvgetportattr failed */
+      set_xv_errorhandler(mydisplay);
+      
+      /* get the serial of the XvGetPortAttribute request */
+      req_serial = NextRequest(mydisplay);
+      
+      ret = XvGetPortAttribute(mydisplay, xv_port, attr_atom, &val);
+      
+      /* revert to the previous xerrorhandler */
+      set_prev_errorhandler();
+      
+      if((ret != Success) || (use_xvcolorkey == 0)) {
+	ERROR("Couldn't get attribute: %s\n", attr_name);
+      } else {
+	XGCValues gcval;
+	gcval.foreground = val;
+	gcval.fill_style = FillSolid;
+	colorkey_gc = XCreateGC(mydisplay, window.win,
+				GCForeground | GCFillStyle, &gcval);
+
+	XFillRectangle(mydisplay, window.win, colorkey_gc,
+		       0, 0,
+		       window.window_area.width,
+		       window.window_area.height);
+      }
+    }
+    /* Allt set up! */
     break;
   }
+  /* Clean up */
+  XvFreeAdaptorInfo(xv_adaptor_info);
+
 #endif /* HAVE_XV */
+  /* In case we didn't find a working Xv */  
   if(!xv_found) {
     use_xv = 0;
   }
@@ -426,6 +584,14 @@
 static void display_init_xshm()
 {
   
+  if(!XShmQueryExtension(mydisplay)) {    
+    if(use_xshm) {
+      WARNING("XShm extension not available on %s\n",
+	      DisplayString(mydisplay));
+    }
+    use_xshm = 0;
+  }
+
   /* Create shared memory image */
   window.ximage = XShmCreateImage(mydisplay, vinfo.visual, color_depth,
 				  ZPixmap, NULL, &shm_info,
@@ -447,6 +613,14 @@
     exit(1);
   }
   
+  {
+    int shmsize = window.ximage->bytes_per_line * window.ximage->height;
+    DNOTE("init_xshm getting bpp: %d, h: %d = %d bytes sysv shm\n",
+	  window.ximage->bytes_per_line,
+	  window.ximage->height,
+	  shmsize);
+  }
+
   /* Get a shared memory segment */
   shm_info.shmid = shmget(IPC_PRIVATE,
 			  window.ximage->bytes_per_line * 
@@ -475,25 +649,27 @@
   /* make sure we don't have any unhandled errors */
   XSync(mydisplay, False);
 
-  
-  /* set error handler so we can check if xshmattach failed */
-  prev_xerrhandler = XSetErrorHandler(xshm_errorhandler);
-  
-  /* get the serial of the xshmattach request */
-  req_serial = NextRequest(mydisplay);
-
-  /* try to attach */
-  XShmAttach(mydisplay, &shm_info);
+  if(use_xshm) {
+    
+    /* set error handler so we can check if xshmattach failed */
+    set_xshm_errorhandler(mydisplay);
+    
+    /* get the serial of the xshmattach request */
+    req_serial = NextRequest(mydisplay);
+    
+    /* try to attach */
+    XShmAttach(mydisplay, &shm_info);
+    
+    /* make sure xshmattach has been processed and any errors
+       have been returned to us */
+    XSync(mydisplay, False);
+    
+    /* revert to the previous xerrorhandler */
+    set_prev_errorhandler();
+    
+    CompletionType = XShmGetEventBase(mydisplay) + ShmCompletion;  
+  }
 
-  /* make sure xshmattach has been processed and any errors
-     have been returned to us */
-  XSync(mydisplay, False);
-  
-  /* revert to the previous xerrorhandler */
-  XSetErrorHandler(prev_xerrhandler);
-  
-  CompletionType = XShmGetEventBase(mydisplay) + ShmCompletion;  
-  
   pixel_stride = window.ximage->bits_per_pixel;
 
   // If we have blue in the lowest bit then obviously RGB 
@@ -682,6 +858,17 @@
 
 }
 
+static void set_videoarea(window_info *w, int width, int height)
+{
+  w->video_area.width = width;
+  w->video_area.height = height;
+  w->video_area.x = ((int)w->window_area.width - 
+		     (int)w->video_area.width) / 2;
+  w->video_area.y = ((int)w->window_area.height -
+		     (int)w->video_area.height) / 2;
+  
+  return;
+}
 
 void display_init(int padded_width, int padded_height,
 		  int picture_buffer_shmid,
@@ -756,7 +943,8 @@
     scr = XDefaultScreenOfDisplay(mydisplay);
     
     init_config(mydisplay);
-    
+
+
     /* Assume (for now) that the window will be the same size as the source. */
     scale.image_width = padded_width;
     scale.image_height = padded_height;
@@ -891,13 +1079,8 @@
 	    xev.xconfigure.width, 
 	    xev.xconfigure.height);
 	  */
-	  window.video_area.width = scale.image_width;
-	  window.video_area.height = scale.image_height;
-	  window.video_area.x = (window.window_area.width - 
-				 window.video_area.width) / 2;
-	  window.video_area.y = (window.window_area.height -
-				 window.video_area.height) / 2;
-	  
+	  set_videoarea(&window, scale.image_width, scale.image_height);
+
 	  XTranslateCoordinates(mydisplay, window.win,
 				DefaultRootWindow(mydisplay), 
 				0,
@@ -917,12 +1100,6 @@
     /* Create the colormaps. (needed in the PutImage calls) */   
     mygc = XCreateGC(mydisplay, window.win, 0L, &xgcv);
     
-    
-    
-    
-    xshmeventbase = XShmGetEventBase(mydisplay);  
-    //DNOTE("xshmeventbase: %d\n", xshmeventbase);
-    
   }
   
   /* Try to use XFree86 Xv (X video) extension for display.
@@ -996,13 +1173,11 @@
       XResizeWindow(mydisplay, window.win, 
 		    scale.image_width, scale.image_height);
     }
-
     return;
   }
   
   
   if(!use_xv) {
-    
     XSync(mydisplay,True);
     
     /* Destroy old display */
@@ -1041,10 +1216,23 @@
     if(window.ximage->bytes_per_line *  window.ximage->height
        < padded_width * padded_height * 4) {
       alloc_size = padded_width * padded_height * 4;
+      {
+	DNOTE("display_change_size: getting bpp:%d, h:%d = %d bytes sysv shm\n",
+	      padded_width,
+	      padded_height,
+	      alloc_size);
+      }
     } else {
       alloc_size = window.ximage->bytes_per_line * window.ximage->height;
+      {
+	DNOTE("display_change_size: getting bpp:%d, h:%d = %d bytes sysv shm\n",
+	      window.ximage->bytes_per_line,
+	      window.ximage->height,
+	      alloc_size);
+      }
     }
     
+
     /* Get a shared memory segment */
     shm_info.shmid = shmget(IPC_PRIVATE, alloc_size, IPC_CREAT | 0666);
 
@@ -1071,10 +1259,13 @@
     XSync(mydisplay, False);
   }
   
+
   /* Save the new size so we know what to scale to. */
   scale.image_width = new_width;
-  scale.image_height = new_height;
+  scale.image_height = new_height; 
   
+  set_videoarea(&window, scale.image_width, scale.image_height);
+
   /* Force a change of the window size. */
   if(resize_window == True) {
     XResizeWindow(mydisplay, window.win, 
@@ -1083,6 +1274,48 @@
 }
 
 
+static area_t bound_viewarea(yuv_image_t *img, area_t area)
+{
+  yuv_picture_t *p = &img->info->picture;
+  
+  if(area.width <= 0 || area.height <= 0) {
+   //reset viewarea
+   area.x = 0;
+   area.y = 0;
+    area.width = p->horizontal_size;
+    area.height = p->vertical_size;
+  } else {
+    if(area.x < 0)
+      area.x = 0;
+    if(area.y < 0)
+      area.y = 0;
+    if(area.x + area.width > p->horizontal_size)
+      area.width = p->horizontal_size - area.x;
+    if(area.y + area.height > p->vertical_size)
+      area.height = p->vertical_size - area.y;
+  }
+
+  return area;
+}
+
+static area_t viewarea; //only accessed by get/set_viewarea()
+
+static area_t get_viewarea(yuv_image_t *img)
+{
+  return bound_viewarea(img, viewarea);
+}
+
+
+static void set_viewarea(yuv_image_t *img, area_t area)
+{
+  
+  viewarea = bound_viewarea(img, area);
+
+  display_adjust_size(img, -1, -1);
+  clear_borders();
+
+}
+
 static void display_adjust_size(yuv_image_t *current_image,
 				int given_width, int given_height) {
   int dpy_sar_frac_n, dpy_sar_frac_d;
@@ -1090,7 +1323,8 @@
   int64_t scale_frac_n, scale_frac_d;
   int base_width, base_height, max_width, max_height;
   int new_width, new_height;
-  
+  area_t src_view_area;
+
   if(aspect_mode == AspectModeSrcVM) {
     sar_frac_n // hack
       = aspect_new_frac_d * current_image->info->picture.horizontal_size;
@@ -1131,36 +1365,7 @@
   }
   */
 
-  if(view_area_mode == 0) {
-    new_view_area.x = 0;
-    new_view_area.y = 0;
-    new_view_area.width = current_image->info->picture.horizontal_size;
-    new_view_area.height = current_image->info->picture.vertical_size;
-    src_view_area = new_view_area;
-  } else if(view_area_mode == 1) {
-    src_view_area = new_view_area;
-  }
-	  
-  if(src_view_area.x < 0) {
-    src_view_area.x = 0;
-    new_view_area.x = src_view_area.x;
-  }
-  if(src_view_area.y < 0) {
-    src_view_area.y = 0;
-    new_view_area.y = src_view_area.y;
-  }
-  if(src_view_area.x + src_view_area.width >
-     current_image->info->picture.horizontal_size) {
-    src_view_area.width =
-      current_image->info->picture.horizontal_size - src_view_area.x;
-    new_view_area.width = src_view_area.width;
-  }
-  if(src_view_area.y + src_view_area.height >
-     current_image->info->picture.vertical_size) {
-    src_view_area.height =
-      current_image->info->picture.vertical_size - src_view_area.y;
-    new_view_area.height = src_view_area.height;
-  }
+  src_view_area = get_viewarea(current_image);
 
   /* Keep either the height or the width constant. */ 
   if(scale_frac_n > scale_frac_d) {
@@ -1276,6 +1481,10 @@
 
 void clear_borders(void)
 {
+
+  if(use_xv) {
+    clear_window();
+  }
   // top border
   if(window.video_area.y > 0) {
     XClearArea(mydisplay, window.win,
@@ -1328,6 +1537,35 @@
   }
 }
 
+
+static void set_rubberband(yuv_image_t *img, int start, int x, int y)
+{
+  static int x0;
+  static int y0;
+  area_t area;
+  
+  if(start) {
+    x0 = x;
+    y0 = y;
+    return;
+  }
+  
+  area.width = x - x0;
+  area.height = y - y0;
+  area.x = x0;
+  area.y = y0;
+  
+  if(area.width < 1 || area.height < 1) {
+    area.x = area.y = area.width = area.height = 0;
+    set_viewarea(img, area); //reset viewarea
+  } else {
+    set_viewarea(img, area);
+  }
+  
+}
+
+
+
 void check_x_events(yuv_image_t *current_image)
 {
   XEvent ev;
@@ -1335,15 +1573,19 @@
   clocktime_t cur_time;
   static Bool cursor_visible = True;
   static Time last_motion;
+  area_t src_view_area;
   
   while(XCheckIfEvent(mydisplay, &ev, true_predicate, NULL) != False) {
-    
+  
+    src_view_area = get_viewarea(current_image);
+
     switch(ev.type) {
     case KeyPress:
       // send keypress to whoever wants it
       if(input_mask & INPUT_MASK_KeyPress) {
 	MsgEvent_t m_ev;
-	KeySym keysym;
+	KeySym keysym, base_keysym;
+	base_keysym = XLookupKeysym(&(ev.xkey), 0);
 	XLookupString(&(ev.xkey), NULL, 0, &keysym, NULL);
 	m_ev.type = MsgEventQInputKeyPress;
 	m_ev.input.x = (ev.xkey.x - window.video_area.x) *
@@ -1356,7 +1598,34 @@
 	m_ev.input.y_root = ev.xkey.y_root;
 	m_ev.input.mod_mask = ev.xkey.state;
 	m_ev.input.input = keysym;
+	m_ev.input.input_base = base_keysym;
+	m_ev.input.input_keycode = ev.xkey.keycode;
 
+#ifdef DEINTERLACE_TEST
+#ifdef HAVE_XV
+	if(use_xv) {
+	  if(keysym == XK_m) {
+	    if(deint != 1) {
+	      fprintf(stderr, "displaying only top field\n");
+	      deint = 1;
+	      xv_image = XvShmCreateImage(mydisplay, xv_port, xv_id, NULL,
+					  xv_image->width*2,
+					  xv_image->height/2, 
+					  &shm_info);
+	    }
+	  } else if(keysym == XK_M) {
+	    if(deint != 0) {
+	      fprintf(stderr, "displaying both fields\n");
+	      deint = 0;
+	      xv_image = XvShmCreateImage(mydisplay, xv_port, xv_id, NULL,
+					  xv_image->width/2,
+					  xv_image->height*2, 
+					  &shm_info);
+	    }
+	  }
+	}
+#endif
+#endif       
 	if(MsgSendEvent(msgq, input_client, &m_ev, IPC_NOWAIT) == -1) {
 	  switch(errno) {
 	  case EAGAIN:
@@ -1383,7 +1652,8 @@
       // send keyrelease to whoever wants it
       if(input_mask & INPUT_MASK_KeyRelease) {
 	MsgEvent_t m_ev;
-	KeySym keysym;
+	KeySym keysym, base_keysym;
+	base_keysym = XLookupKeysym(&(ev.xkey), 0);
 	XLookupString(&(ev.xkey), NULL, 0, &keysym, NULL);
 	m_ev.type = MsgEventQInputKeyRelease;
 	m_ev.input.x = (ev.xkey.x - window.video_area.x) *
@@ -1396,6 +1666,8 @@
 	m_ev.input.y_root = ev.xkey.y_root;
 	m_ev.input.mod_mask = ev.xkey.state;
 	m_ev.input.input = keysym;
+	m_ev.input.input_base = base_keysym;
+	m_ev.input.input_keycode = ev.xkey.keycode;
 
 	if(MsgSendEvent(msgq, input_client, &m_ev, IPC_NOWAIT) == -1) {
 	  switch(errno) {
@@ -1437,9 +1709,7 @@
 	m_ev.input.input = ev.xbutton.button;
 
 	if(ev.xbutton.button == 2) {
-	  view_area_mode = 2;
-	  new_view_area.x = m_ev.input.x;
-	  new_view_area.y = m_ev.input.y;
+	  set_rubberband(current_image, 1, m_ev.input.x, m_ev.input.y); 
 	}
 
 	if(MsgSendEvent(msgq, input_client, &m_ev, IPC_NOWAIT) == -1) {
@@ -1486,44 +1756,34 @@
 	m_ev.input.y_root = ev.xbutton.y_root;
 	m_ev.input.mod_mask = ev.xbutton.state;
 	m_ev.input.input = ev.xbutton.button;
-
+	
 	if(ev.xbutton.button == 2) {
-	  int w, h;
-	  w = m_ev.input.x - new_view_area.x;
-	  h = m_ev.input.y - new_view_area.y;
-
-	  if(w < 1 || h < 1) {
-	    view_area_mode = 0;
-	  } else {
-	    new_view_area.width = w;
-	    new_view_area.height = h; 
-	    view_area_mode = 1;
-	  }
+	  set_rubberband(current_image, 0, m_ev.input.x, m_ev.input.y);
 	}
-	
-      if(input_mask & INPUT_MASK_ButtonRelease) {
-	if(MsgSendEvent(msgq, input_client, &m_ev, IPC_NOWAIT) == -1) {
-	  switch(errno) {
-	  case EAGAIN:
-	    // msgq full, drop message
-	    break;
+      
+	if(input_mask & INPUT_MASK_ButtonRelease) {
+	  if(MsgSendEvent(msgq, input_client, &m_ev, IPC_NOWAIT) == -1) {
+	    switch(errno) {
+	    case EAGAIN:
+	      // msgq full, drop message
+	      break;
 #ifdef EIDRM
-	  case EIDRM:
+	    case EIDRM:
 #endif
-	  case EINVAL:
-	    FATAL("%s", "buttonrelease\n");
-	    perror("MsgSendEvent");
-	    display_exit(); //TODO clean up and exit
-	    break;
-	  default:
-	    FATAL("%s", "buttonrelease, couldn't send notification\n");
-	    perror("MsgSendEvent");
-	    display_exit(); //TODO clean up and exit
-	    break;
+	    case EINVAL:
+	      FATAL("%s", "buttonrelease\n");
+	      perror("MsgSendEvent");
+	      display_exit(); //TODO clean up and exit
+	      break;
+	    default:
+	      FATAL("%s", "buttonrelease, couldn't send notification\n");
+	      perror("MsgSendEvent");
+	      display_exit(); //TODO clean up and exit
+	      break;
+	    }
 	  }
 	}
       }
-      }
       if(cursor_visible == False) {
 	restore_cursor(mydisplay, window.win);
 	cursor_visible = True;
@@ -1584,6 +1844,7 @@
       
       if(ev.xexpose.window == window.win) {
 	if(use_xv) {
+	  clear_borders();
 	  draw_win_xv(&window);
  	} else {
 	  draw_win_x11(&window);
@@ -1593,22 +1854,17 @@
     case ConfigureNotify:
       // remove all configure notify in queue
       while(XCheckTypedEvent(mydisplay, ConfigureNotify, &ev) == True); 
-      
+
       if(ev.xconfigure.window == window.win) {
 	Window dummy_win;
 	window.window_area.width = ev.xconfigure.width;
 	window.window_area.height = ev.xconfigure.height;
-	
+
 	display_adjust_size(current_image, 
 			    ev.xconfigure.width, 
 			    ev.xconfigure.height);
 	
-	window.video_area.width = scale.image_width;
-	window.video_area.height = scale.image_height;
-	window.video_area.x = (window.window_area.width - 
-			       window.video_area.width) / 2;
-	window.video_area.y = (window.window_area.height -
-			       window.video_area.height) / 2;
+	set_videoarea(&window, scale.image_width, scale.image_height);
 
 	XTranslateCoordinates(mydisplay, window.win,
 			      DefaultRootWindow(mydisplay), 
@@ -1622,6 +1878,9 @@
 				window.window_area.x,
 				window.window_area.y);
 	clear_borders();
+	if(use_xv) {
+	  draw_win_xv(&window);
+	}
       }
       break;    
     default:
@@ -1639,10 +1898,38 @@
   }
 }
 
+static void clear_window(void)
+{
+  if(use_xv && use_xvcolorkey && videostate) {
+    XFillRectangle(mydisplay, window.win, colorkey_gc,
+		   0, 0,
+		   window.window_area.width,
+		   window.window_area.height);
+  } else {
+    XClearArea(mydisplay, window.win,
+	       0, 0,
+	       window.window_area.width,
+	       window.window_area.height,
+	       False);
+  }
+}
+
 void display(yuv_image_t *current_image)
 {
   static int sar_frac_n, sar_frac_d; 
-  
+  static int p_width = -1, p_height = -1;
+
+  if(p_width != current_image->info->picture.horizontal_size ||
+     p_height != current_image->info->picture.vertical_size) {
+
+    p_width = current_image->info->picture.horizontal_size;
+    p_height = current_image->info->picture.vertical_size;
+
+    display_adjust_size(current_image, -1, -1);
+    //TODO move this
+    clear_borders();
+  }
+
   if(aspect_mode == AspectModeSrcMPEG) {
     /* New source aspect ratio? */
     if(current_image->info->picture.sar_frac_n != sar_frac_n ||
@@ -1653,46 +1940,22 @@
       
       display_adjust_size(current_image, -1, -1);
       //TODO move this
-      XClearArea(mydisplay, window.win,
-		 0, 0,
-		 window.window_area.width,
-		 window.window_area.height,
-		 False);
-
+      clear_borders();
     }
   }
   if(aspect_mode == AspectModeSrcVM) {
     /* New VM aspect ratio? */
     if(aspect_new_frac_n != sar_frac_n || aspect_new_frac_d != sar_frac_d) {
-      
+
       sar_frac_n = aspect_new_frac_n;
       sar_frac_d = aspect_new_frac_d;
     
       display_adjust_size(current_image, -1, -1);
       //TODO move this
-      XClearArea(mydisplay, window.win,
-		 0, 0,
-		 window.window_area.width,
-		 window.window_area.height,
-		 False);
-
+      clear_borders();
     }
   }
   
-  if((new_view_area.x != src_view_area.x ||
-      new_view_area.y != src_view_area.y ||
-      new_view_area.width != src_view_area.width ||
-      new_view_area.height != src_view_area.height) &&
-     view_area_mode != 2) {
-    display_adjust_size(current_image, -1, -1);
-    //TODO move this
-    XClearArea(mydisplay, window.win,
-	       0, 0,
-	       window.window_area.width,
-	       window.window_area.height,
-	       False);
-  }
-  
   if(((window.win_state == WINDOW_STATE_NORMAL) && 
       (zoom_mode == ZoomModeFullScreen)) ||
      ((window.win_state == WINDOW_STATE_FULLSCREEN) &&
@@ -1726,6 +1989,10 @@
 
   if(mydisplay) {
     XSync(mydisplay,True);
+    if(use_xv)
+#ifdef HAVE_XV
+      XvUngrabPort(mydisplay,xv_port,CurrentTime);
+#endif
     if(use_xshm)
       XShmDetach(mydisplay, &shm_info);
     if(window.ximage != 0)
@@ -1754,7 +2021,10 @@
 {
   int sar_frac_n = 0, sar_frac_d = 0; /* initialize to shut up compiler */ 
   char *address = dwin->ximage->data;
-  
+
+  if(videostate == 0) {
+    return;
+  }
 #ifdef HAVE_MLIB
   int dest_size = dwin->ximage->bytes_per_line * dwin->ximage->height;
   int source_size = (dwin->image->info->picture.padded_width*(pixel_stride/8) 
@@ -1802,13 +2072,8 @@
     rect_t fb_rect;
     rect_t clip_rect;
 
-    window.video_area.width = dwin->image->info->picture.horizontal_size;
-    window.video_area.height = dwin->image->info->picture.vertical_size;
-    window.video_area.x = (int)(window.window_area.width - 
-				window.video_area.width) / 2;
-    window.video_area.y = (int)(window.window_area.height -
-				window.video_area.height) / 2;
-  
+    set_videoarea(&window, dwin->image->info->picture.horizontal_size,
+		  dwin->image->info->picture.vertical_size);
     
     stride = dwin->image->info->picture.padded_width;
     y = dwin->image->y;
@@ -1914,11 +2179,19 @@
 	
     
 #ifdef SPU
+#ifdef SOCKIPC
+#warning "todo"
+#else
     if(msgqid != -1) {
+#endif
       mix_subpicture_rgb((char *)&rgb_fb[fb_area.y*2048+fb_area.x],
 			 2048, fb_area.height); 
+#ifdef SOCKIPC
+#warning "todo"
+#else
     }
 #endif
+#endif
     }
     return;
   }  
@@ -1935,12 +2208,20 @@
 	  dwin->image->info->picture.padded_width/2);
   
 #ifdef SPU
+#ifdef SOCKIPC
+#warning "todo"
+#else
   if(msgqid != -1) {
+#endif
     mix_subpicture_rgb(address,
 		       dwin->image->info->picture.padded_width,
 		       dwin->image->info->picture.padded_height); 
+#ifdef SOCKIPC
+#warning "todo"
+#else
   }
 #endif
+#endif
   
   if(screenshot_spu) {
     screenshot_spu = 0;
@@ -1951,10 +2232,10 @@
 		       sar_frac_n, sar_frac_d);
   }
   
-
 #ifdef HAVE_MLIB
   if((scale.image_width != dwin->image->info->picture.horizontal_size) ||
      (scale.image_height != dwin->image->info->picture.vertical_size)) {
+    area_t src_view_area = get_viewarea(dwin->image);
     /* Destination image */
     mimage_d = mlib_ImageCreateStruct(MLIB_BYTE, 4,
 				      scale.image_width, 
@@ -1989,15 +2270,10 @@
     screenshot_yuv_jpg(dwin->image, dwin->ximage, sar_frac_n, sar_frac_d);
   }
   
-  window.video_area.width = scale.image_width;
-  window.video_area.height = scale.image_height;
-  window.video_area.x = (window.window_area.width - 
-			 window.video_area.width) / 2;
-  window.video_area.y = (window.window_area.height -
-			 window.video_area.height) / 2;
+  set_videoarea(&window, scale.image_width, scale.image_height);
 
-  /*
   
+  /*  
   fprintf(stderr, "dwin->win: %d, mygc: %d, dwin->ximage: %d, 0, 0,\n",
 	  dwin->win, mygc, dwin->ximage);
   fprintf(stderr, "x: %d %x,  y: %d %x, w: %d %x, h: %d %x\n",
@@ -2074,8 +2350,13 @@
 {
 #ifdef HAVE_XV
   yuv_image_t *draw_image;
-
+  area_t src_view_area;
   int sar_frac_n = 0, sar_frac_d = 0; /* initialize to shut up compiler */   
+
+  if(videostate == 0) {
+    return;
+  }
+
   /* Set the source of the xv_image to the source of the image 
      that we want drawn. */ 
 
@@ -2101,28 +2382,38 @@
   }
 
 #ifdef SPU
+#ifdef SOCKIPC
+#warning "todo"
+#else
   if(msgqid != -1) {
+#endif
     //ugly hack
     if(mix_subpicture_yuv(draw_image, cur_data_q->reserv_image)) {
       draw_image = cur_data_q->reserv_image;
     }
+#ifdef SOCKIPC
+#warning "todo"
+#else
   }
 #endif
+#endif
 
   xv_image->data = draw_image->y;
-
   if(screenshot_spu) {
     screenshot_spu = 0;
     
     screenshot_yuv_jpg(draw_image, dwin->ximage, sar_frac_n, sar_frac_d);
   }
   
-  window.video_area.width = scale.image_width;
-  window.video_area.height = scale.image_height;
-  window.video_area.x = (int)(window.window_area.width - 
-			      window.video_area.width) / 2;
-  window.video_area.y = (int)(window.window_area.height -
-			      window.video_area.height) / 2;
+  set_videoarea(&window, scale.image_width, scale.image_height);
+
+  src_view_area = get_viewarea(draw_image);
+#ifdef DEINTERLACE_TEST
+  if(deint) {
+    src_view_area.y = src_view_area.y/2; 
+    src_view_area.height = src_view_area.height/2; 
+  }
+#endif
   if(use_xshm) {
     XvShmPutImage(mydisplay, xv_port, dwin->win, mygc, xv_image, 
 		  src_view_area.x, src_view_area.y, 
diff -urN -x CVS -x .cvsignore ogle-0.9.2/mpeg2_video/video_output_xil.c ogle/mpeg2_video/video_output_xil.c
--- ogle-0.9.2/mpeg2_video/video_output_xil.c	1970-01-01 01:00:00.000000000 +0100
+++ ogle/mpeg2_video/video_output_xil.c	2001-07-27 11:43:04.000000000 +0200
@@ -0,0 +1,223 @@
+/* Ogle - A video player
+ * Copyright (C) 2000, 2001 Björn Englund, Håkan Hjort, Martin Norbäck
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+
+
+#ifdef HAVE_MLIB
+#include <mlib_types.h>
+#include <mlib_status.h>
+#include <mlib_sys.h>
+#include <mlib_video.h>
+#include <mlib_algebra.h>
+#else /* ! HAVE_MLIB */
+#ifdef HAVE_MMX
+#include "mmx.h"
+#endif /* HAVE_MMX */
+#include "c_mlib.h"
+#endif /* ! HAVE_MLIB */
+
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+#include <sys/ipc.h>
+#include <sys/types.h>
+
+#include "common.h"
+#include "video_types.h"
+#include "yuv2rgb.h"
+
+#define SUNXIL_WARNING_DISABLE
+#include <xil/xil.h>
+
+static XilSystemState state;
+static XilImage display_image, render_image, three_band_image;
+static int image_width, image_height;
+static int resized;
+static float horizontal_scale, vertical_scale;
+
+
+extern buf_ctrl_head_t *buf_ctrl_head;
+
+static XVisualInfo vinfo;
+Display *mydisplay;
+Window window;
+GC mygc;
+int bpp, mode;
+
+void display_init(int padded_width, int padded_height,
+		  int horizontal_size, int vertical_size)
+{
+  int screen;
+  char *hello = "I loathe XIL";
+  XSizeHints hint;
+  XEvent xev;
+
+  XGCValues xgcv;
+  Colormap theCmap;
+  XWindowAttributes attribs;
+  XSetWindowAttributes xswa;
+  unsigned long xswamask;
+
+  mydisplay = XOpenDisplay(NULL);
+
+  if (mydisplay == NULL)
+    fprintf(stderr,"Can not open display\n");
+
+  screen = DefaultScreen(mydisplay);
+
+  hint.x = 0;
+  hint.y = 0;
+  hint.width = horizontal_size;
+  hint.height = vertical_size;
+  hint.flags = PPosition | PSize;
+
+  /* Make the window */
+  XGetWindowAttributes(mydisplay, DefaultRootWindow(mydisplay), &attribs);
+  bpp = attribs.depth;
+  if (bpp != 15 && bpp != 16 && bpp != 24 && bpp != 32) {
+    fprintf(stderr,"Only 15,16,24, and 32bpp supported. Trying 24bpp!\n");
+    bpp = 24;
+  }
+  
+  XMatchVisualInfo(mydisplay,screen,bpp,TrueColor,&vinfo);
+  printf("visual id is  %lx\n",vinfo.visualid);
+
+  theCmap   = XCreateColormap(mydisplay, RootWindow(mydisplay,screen), 
+			      vinfo.visual, AllocNone);
+
+  xswa.background_pixel = 0;
+  xswa.border_pixel     = 1;
+  xswa.colormap         = theCmap;
+  xswamask = CWBackPixel | CWBorderPixel | CWColormap;
+
+  window = XCreateWindow(mydisplay, RootWindow(mydisplay,screen),
+			 hint.x, hint.y, hint.width, hint.height, 
+			 0, bpp, CopyFromParent, vinfo.visual, 
+			 xswamask, &xswa);
+
+  resized = 0;
+
+  XSelectInput(mydisplay, window, StructureNotifyMask);
+
+  /* Tell other applications about this window */
+  XSetStandardProperties(mydisplay, window, 
+			 hello, hello, None, NULL, 0, &hint);
+
+  /* Map window. */
+  XMapWindow(mydisplay, window);
+  
+  // This doesn't work correctly
+  /* Wait for map. */
+  do {
+    XNextEvent(mydisplay, &xev);
+  }
+  while (xev.type != MapNotify || xev.xmap.event != window);
+  
+  XFlush(mydisplay);
+  XSync(mydisplay, False);
+   
+  /* Create the colormaps. */   
+  mygc = XCreateGC(mydisplay, window, 0L, &xgcv);
+
+  bpp = 32;
+   
+  yuv2rgb_init(bpp, MODE_BGR);
+
+  /* Setup XIL */
+  state = xil_open ();
+  if (state == NULL) {
+    exit (1);
+  }
+
+  /* Create display and render images */
+  display_image = xil_create_from_window (state, mydisplay, window);
+  //xil_set_synchronize (display_image, 1);
+
+  render_image = xil_create (state, horizontal_size, vertical_size, 
+                             4, XIL_BYTE);
+  /* Create a child image of render image, for use in xil_copy */
+  three_band_image = xil_create_child(render_image, 0, 0, 
+                                      horizontal_size, vertical_size, 1, 3);
+  image_width = horizontal_size;
+  image_height = vertical_size;
+  
+  return;
+}
+
+void display_exit () {
+}
+
+void resize () {
+  Window root;
+  int x, y;
+  unsigned int w, h, b, d;
+  
+  XGetGeometry (mydisplay, window, &root, &x, &y, &w, &h, &b, &d);
+
+  /* Calculate scale factors */
+  if (w == image_width && h == image_height) {
+    resized = 0;
+    horizontal_scale = 1.0;
+    vertical_scale = 1.0;
+  } else {
+    resized = 1;
+    horizontal_scale = ((float) w)/image_width;
+    vertical_scale = ((float) h)/image_height;
+  }
+
+  /* Stop events temporarily, while creating new display_image */
+  XSelectInput(mydisplay, window, NoEventMask);
+
+  /* Create new display_image */
+  xil_destroy(display_image);
+  display_image = xil_create_from_window(state, mydisplay, window);
+  //xil_set_synchronize(display_image, 1);
+
+  /* Turn on events */
+  XSelectInput (mydisplay, window, StructureNotifyMask);
+}
+
+
+void display(yuv_image_t *image)
+{
+  XilMemoryStorage storage;
+  XEvent event;
+
+  xil_export(render_image);
+  xil_get_memory_storage(render_image, &storage);
+  yuv2rgb(storage.byte.data, image->y, image->u, image->v,
+	  image->padded_width,
+	  image->padded_height, 
+	  image->padded_width*(bpp/8),
+	  image->padded_width, image->padded_width/2 );
+  xil_import(render_image, TRUE);
+  if (resized) {
+    xil_scale(three_band_image, display_image, "bilinear",
+               horizontal_scale, vertical_scale);
+  } else {
+    xil_copy(three_band_image, display_image);
+  }
+  xil_toss(three_band_image);
+  xil_toss(render_image);;
+  
+  /* Check if scale factors need recalculating */
+  if (XCheckWindowEvent (mydisplay, window, StructureNotifyMask, &event))
+    resize();
+}
+
diff -urN -x CVS -x .cvsignore ogle-0.9.2/mpeg2_video/video_scale.c ogle/mpeg2_video/video_scale.c
--- ogle-0.9.2/mpeg2_video/video_scale.c	1970-01-01 01:00:00.000000000 +0100
+++ ogle/mpeg2_video/video_scale.c	2001-12-12 00:50:41.000000000 +0100
@@ -0,0 +1,203 @@
+#include <inttypes.h>
+#include <stdio.h>
+
+inline 
+uint32_t nearest(uint32_t *source, uint32_t src_stride, float x, float y) {
+  unsigned int j,k;
+  j = x + 0.5;
+  k = y + 0.5;
+  return source[j + src_stride/4 * k];
+}
+
+inline
+uint32_t bilinear(uint32_t *source, uint32_t src_stride, float x, float y) {
+  unsigned int j, k;
+  float a, b;
+  float dest_r, dest_g, dest_b;
+  unsigned int pixel_r, pixel_g, pixel_b;
+
+  j = x;
+  k = y;
+  a = x - j;
+  b = y - k;
+  dest_r = (1-a)*(1-b)*(source[j + src_stride/4 * k]&0xff)
+    + a*(1-b)*(source[(j+1) + src_stride/4 * k]&0xff)
+    + b*(1-a)*(source[j + src_stride/4 * (k+1)]&0xff)
+    + a*b*(source[(j+1) + src_stride/4 * (k+1)]&0xff);
+  dest_g = (1-a)*(1-b)*((source[j + src_stride/4 * k]>>8)&0xff)
+    + a*(1-b)*((source[(j+1) + src_stride/4 * k]>>8)&0xff)
+    + b*(1-a)*((source[j + src_stride/4 * (k+1)]>>8)&0xff)
+    + a*b*((source[(j+1) + src_stride/4 * (k+1)]>>8)&0xff);
+  dest_b = (1-a)*(1-b)*((source[j + src_stride/4 * k]>>16)&0xff)
+    + a*(1-b)*((source[(j+1) + src_stride/4 * k]>>16)&0xff)
+    + b*(1-a)*((source[j + src_stride/4 * (k+1)]>>16)&0xff)
+    + a*b*((source[(j+1) + src_stride/4 * (k+1)]>>16)&0xff);
+  pixel_r = dest_r;
+  pixel_g = dest_g;
+  pixel_b = dest_b;
+
+  return (pixel_b<<16) | (pixel_g<<8) | pixel_r;
+}
+
+
+void mylib_VideoScale_YUV420_to_YUYV422(uint8_t *y_src,
+					uint8_t *u_src,
+					uint8_t *v_src,
+					const uint32_t src_width,
+					const uint32_t src_height,
+					const uint32_t src_stride,
+					uint32_t *yuyv_dst,
+					const uint32_t dst_width,
+					const uint32_t dst_height,
+					const uint32_t dst_stride) {
+  unsigned int x, y;
+  double xr, yr;
+  double dx, dy;
+  double dux, duy;
+  uint8_t *src_pixel;
+  uint32_t dst_pixel;
+
+  
+  dx = (double)src_width / (double)dst_width;
+  dy = (double)src_height / (double)dst_height;
+
+  dux = (double)(src_width/2) / (double)(dst_width/2);
+  duy = (double)(src_height/2) / (double)(dst_height/2);
+  
+  for(y = 0;  y < dst_height; y++) {
+    int y_int = (int)((double)(y)*dy);
+    double y_frac = (double)(y)*dy-(double)y_int;
+    double y_frac_inv = 1.0-y_frac;
+
+    int uy_int = (int)((double)(y/2)*duy);
+    double uy_frac = (double)(y/2)*duy-(double)uy_int;
+    double uy_frac_inv = 1.0-uy_frac;
+    
+    for(x = 0; x < dst_width; x++) {
+      double a,b,c,d;
+      uint8_t e;
+      uint32_t dst_pixel = 0;
+      double p,q;
+      int x_int = (int)((double)(x)*dx);
+      double x_frac = (double)(x)*dx-(double)(x_int);
+      
+      src_pixel = y_src +y_int*src_stride + x_int;
+      a = (double)(*src_pixel);
+      b = (double)(*(src_pixel+1));
+      c = (double)(*(src_pixel+src_stride));
+      d = (double)(*(src_pixel+src_stride+1));
+      
+      p = y_frac*c + y_frac_inv*a;
+      q = y_frac*d + y_frac_inv*b;
+
+      e = (uint8_t)(x_frac*q + (1.0-x_frac)*p);
+      
+      dst_pixel = e << 24;
+      x++;
+      x_int = (int)((double)(x)*dx);
+      x_frac = (double)(x)*dx-(double)x_int;
+      
+      src_pixel = y_src+y_int*src_stride+x_int;
+      
+      a = (double)(*(src_pixel));
+      b = (double)(*(src_pixel+1));
+      c = (double)(*(src_pixel+src_stride));
+      d = (double)(*(src_pixel+src_stride+1));
+      
+      p = y_frac*c + y_frac_inv*a;
+      q = y_frac*d + y_frac_inv*b;
+      
+      e = (uint8_t)(x_frac*q + (1.0-x_frac)*p);
+      
+      dst_pixel = dst_pixel | (e << 8);
+      yuyv_dst[y*dst_stride/4+x/2] = dst_pixel;
+ 
+    }
+    
+    
+    
+  }
+}
+
+
+void mylib_VideoScaleABGR( uint8_t *dst, 
+			   uint8_t *src,
+			   const uint32_t dst_h_size,
+			   const uint32_t dst_v_size,
+			   const uint32_t src_h_size,
+			   const uint32_t src_v_size,
+			   const uint32_t dst_stride,
+			   const uint32_t src_stride ) {
+  unsigned int x, y;
+  double xr, yr;
+  double h_scale, v_scale;
+  uint32_t *source = (uint32_t *)src;
+  uint32_t *base;
+  uint32_t *dest = (uint32_t *)dst; 
+  uint32_t ncolor;
+  
+  h_scale = (double)src_h_size / (double)dst_h_size;
+  v_scale = (double)src_v_size / (double)dst_v_size;
+
+  for( y = 0;  y < dst_v_size; y++ ) {
+    unsigned int k;
+    yr = y * v_scale;
+    k = yr;
+    base = &source[k * src_stride/4]; 
+    
+    for( x = 0; x < dst_h_size; x++ ) {
+      unsigned int j;
+      xr = x * h_scale;
+      j = xr;
+      dest[x] = base[j];
+    }
+    dest += dst_stride/4;
+  }
+}
+
+
+
+
+
+
+
+
+/*
+FUNCTION Bicubic (x,y:real) : byte;
+var j,k:integer;
+var a,b:real;
+var dest:real;
+var t1,t2,t3,t4:real;
+var color:integer;
+begin
+  j:=round (x);
+  k:=round (y);
+  a:=x-j;
+  b:=y-k;
+  t1:=-a*(1-a)*(1-a)*RC(j-1,k-1)+
+         (1-2*a*a+a*a*a)*RC(j,k-1)+
+       a*(1+a-a*a)*RC(j+1,k-1)-
+       a*a*(1-a)*RC(j+2,k-1);
+  t2:=-a*(1-a)*(1-a)*RC(j-1,k)+
+         (1-2*a*a+a*a*a)*RC(j,k)+
+       a*(1+a-a*a)*RC(j+1,k)-
+       a*a*(1-a)*RC(j+2,k);
+  t3:=-a*(1-a)*(1-a)*RC(j-1,k+1)+
+         (1-2*a*a+a*a*a)*RC(j,k+1)+
+       a*(1+a-a*a)*RC(j+1,k+1)-
+       a*a*(1-a)*RC(j+2,k+1);
+  t4:=-a*(1-a)*(1-a)*RC(j-1,k+2)+
+         (1-2*a*a+a*a*a)*RC(j,k+2)+
+       a*(1+a-a*a)*RC(j+1,k+2)-
+       a*a*(1-a)*RC(j+2,k+2);
+
+  dest:= -b*(1-b)*(1-b)*t1+
+            (1-2*b*b+b*b*b)*t2+
+          b*(1+b-b*b)*t3+
+          b*b*(b-1)*t4;
+  color:=round(dest);
+  if color<0 then color:=abs(color);  // cannot have negative values !
+  if (color>gifrec.colors) then color:=gifrec.colors; //
+  Bicubic:=color;
+end;
+*/
diff -urN -x CVS -x .cvsignore ogle-0.9.2/mpeg2_video/video_stream.c ogle/mpeg2_video/video_stream.c
--- ogle-0.9.2/mpeg2_video/video_stream.c	2003-03-02 16:54:18.000000000 +0100
+++ ogle/mpeg2_video/video_stream.c	2006-05-08 22:08:54.000000000 +0200
@@ -20,7 +20,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <sys/types.h>
-#include <sys/mman.h>
+
 #include <sys/stat.h>
 #include <fcntl.h>
 #include <unistd.h>
@@ -41,9 +41,6 @@
 #include "c_mlib.h"
 #endif
 
-#include <sys/ipc.h>
-#include <sys/shm.h>
-
 
 #include <ogle/msgevents.h>
 
@@ -56,10 +53,7 @@
 #include "common.h"
 #include "timemath.h"
 #include "sync.h"
-
-#ifndef SHM_SHARE_MMU
-#define SHM_SHARE_MMU 0
-#endif
+#include "shm.h"
 
 
 
@@ -70,6 +64,13 @@
 
 extern int flush_to_scrid;
 
+static int video_state = 1;
+
+int set_video_state(int state)
+{
+  video_state = state;
+}
+
 int get_output_buffer(data_q_t *data_q,
 		      int padded_width, int padded_height, int nr_of_bufs);
 void remove_output_buffer(void);
@@ -108,7 +109,7 @@
 
 
 
-data_q_t *data_q_head;
+data_q_t *data_q_head = NULL;
 static data_q_t *cur_data_q;
 
 int shm_ready = 0;
@@ -265,7 +266,7 @@
   sigaction(SIGINT, &sig, NULL);
 }
 
-int msgqid = -1;
+int standalone = 1;
 
 //char *infilename = NULL;
 
@@ -274,7 +275,13 @@
 {
   int c;
   int output_client = 0;
-  
+#ifdef SOCKIPC
+  char *msgqid;
+  MsgEventQType_t msgq_type;
+#else
+  int msgqid = -1;
+#endif
+
   program_name = argv[0];
   GET_DLEVEL();
   /* Parse command line options */
@@ -293,7 +300,15 @@
       shmem_flag = 0;
       break;
     case 'm':
-      msgqid = atoi(optarg);
+#ifdef SOCKIPC
+      if(get_msgqtype(optarg, &msgq_type, &msgqid) == -1) {
+	fprintf(stderr, "unknown msgq type\n");
+	return 1;
+      }
+#else
+    msgqid = atoi(optarg);
+#endif
+    standalone = 0;
       break;
     case 'h':
     case '?':
@@ -310,7 +325,7 @@
   mlib_Init();
   //init_out_q(nr_of_buffers);
   
-  if(msgqid == -1) {
+  if(standalone) {
     if(optind < argc) {
       infilename = argv[optind];
       infile = fopen(argv[optind], "r");
@@ -319,9 +334,13 @@
     }
   } 
   
-  if(msgqid != -1) {
+  if(!standalone) {
     MsgEvent_t ev;
+#ifdef SOCKIPC
+    if((msgq = MsgOpen(msgq_type, msgqid, strlen(msgqid))) == NULL) {
+#else
     if((msgq = MsgOpen(msgqid)) == NULL) {
+#endif
       FATAL("%s", "couldn't get message qid\n");
       exit(1);
     }
@@ -765,11 +784,11 @@
   data_head = (*data_q_p)->data_head;
   data_shmid = (*data_q_p)->data_head->shmid;
   
-  if(shmdt((char *)data_head) == -1) {
+  if(ogle_sysv_shmdt(data_head) == -1) {
     perror("ERROR[vs]: detach_data_q data_head");
   }
   
-  if(shmdt((char *)q_head) == -1) {
+  if(ogle_shmdt(q_head) == -1) {
     perror("ERROR[vs]: detach_data_q q_head");
   }
 
@@ -789,8 +808,8 @@
     ERROR("%s", "couldn't send destroyq\n");
   }
   
-  ev.type = MsgEventQDestroyBuf;
-  ev.destroybuf.shmid = data_shmid;
+  ev.type = MsgEventQDestroyPicBuf;
+  ev.destroypicbuf.shmid = data_shmid;
 
   if(MsgSendEvent(msgq, CLIENT_RESOURCE_MANAGER, &ev, 0) == -1) {
     ERROR("%s", "couldn't send destroybuf\n");
@@ -807,8 +826,9 @@
   data_q_t **data_q_p;
 
   for(data_q_p = data_q_list; *data_q_p != NULL; data_q_p =&(*data_q_p)->next);
-    
+
   *data_q_p = malloc(sizeof(data_q_t));
+  (*data_q_p)->next = NULL;
   
   if(get_output_buffer(*data_q_p,
 		       padded_width, padded_height,
@@ -848,10 +868,10 @@
   picture_data_elem_t *data_elems = NULL;
   yuv_image_t *image_bufs = NULL;
 
-
+  DNOTE("y_size: %d, uv_size: %d, yuv_size: %d\n", y_size, uv_size, yuv_size);
   DNOTE("%s", "get ouput buffer\n");
   picture_size = ((yuv_size + (pagesize-1))/pagesize*pagesize);
-  
+  DNOTE("psize: %d, nr_bufs: %d\n", picture_size, nr_of_bufs);
   /* Mlib reads ?8? bytes beyond the last pel (in the v-picture), 
      if that pel just before a page boundary then *boom*!! */
   
@@ -872,24 +892,24 @@
   picture_ctrl_size = INC_8b_ALIGNMENT(picture_ctrl_size);
 
   buf_size = picture_ctrl_size + picture_bufs_size;
-  
+  DNOTE("pcs: %d, pbs: %d\n", picture_ctrl_size, picture_bufs_size);
   // Get shared memory buffer
   
   
-  ev.type = MsgEventQReqBuf;
-  ev.reqbuf.size = buf_size;
-  
+  ev.type = MsgEventQReqPicBuf;
+  ev.reqpicbuf.size = buf_size;
+
   if(MsgSendEvent(msgq, CLIENT_RESOURCE_MANAGER, &ev, 0) == -1) {
     ERROR("%s", "couldn't send buffer request\n");
   }
-  
+
   while(1) {
     if(MsgNextEvent(msgq, &ev) != -1) {
-      if(ev.type == MsgEventQGntBuf) {
+      if(ev.type == MsgEventQGntPicBuf) {
 	DPRINTF(1, "video_decoder: got buffer id %d, size %d\n",
-		ev.gntbuf.shmid,
-		ev.gntbuf.size);
-	data_shmid = ev.gntbuf.shmid;
+		ev.gntpicbuf.shmid,
+		ev.gntpicbuf.size);
+	data_shmid = ev.gntpicbuf.shmid;
 	break;
       } else {
 	handle_events(msgq, &ev);
@@ -897,8 +917,8 @@
     }
   }
 
-  if(data_shmid >= 0) {
-    if((data_shmaddr = shmat(data_shmid, NULL, SHM_SHARE_MMU)) == (void *)-1) {
+  if(data_shmid != -1) {
+    if((data_shmaddr = ogle_sysv_shmat(data_shmid)) == (void *)-1) {
       perror("**video_decode: attach_buffer(), shmat()");
       return -1;
     }
@@ -914,20 +934,25 @@
     data_head->write_nr = 0;
     
     
-
+#ifdef HAVE_XV
+    image_bufs = malloc((nr_of_bufs+1)*sizeof(yuv_image_t));
+#else
     image_bufs = malloc(nr_of_bufs*sizeof(yuv_image_t));
-    
+#endif
     data_elems =(picture_data_elem_t *)(data_shmaddr + 
 					sizeof(data_buf_head_t));
 
     picture_data_offset = picture_ctrl_size;
 
-  // TODO this is an ugly hack for not mixing in ref.frames
+    // TODO this is an ugly hack for not mixing in ref.frames
+    for(n = 0;
 #ifdef HAVE_XV
-    for(n = 0; n < (data_head->nr_of_dataelems+1); n++) {
+	n < (data_head->nr_of_dataelems+1);
 #else
-    for(n = 0; n < data_head->nr_of_dataelems; n++) {
+	n < data_head->nr_of_dataelems;
 #endif
+	n++) {
+      
       data_elems[n].displayed = 1;
       data_elems[n].is_reference = 0;
       data_elems[n].picture.y_offset = picture_data_offset;
@@ -936,7 +961,7 @@
       image_bufs[n].v = data_shmaddr + picture_data_offset + y_size;
       data_elems[n].picture.u_offset = picture_data_offset + y_size + uv_size;
       image_bufs[n].u = data_shmaddr + picture_data_offset+y_size+uv_size;
-
+      
       data_elems[n].picture.horizontal_size = seq.horizontal_size;
       data_elems[n].picture.vertical_size = seq.vertical_size;
       data_elems[n].picture.start_x = 0;
@@ -947,37 +972,37 @@
       picture_data_offset += picture_size;
       
     }
-
-
+    
+    
     fwd_ref_image = &image_bufs[0];
     bwd_ref_image = &image_bufs[1];
     
-
+    
     /* send create decoder request msg*/
-    ev.type = MsgEventQReqPicBuf;
+    ev.type = MsgEventQReqPicQ;
+    
+    ev.reqpicq.nr_of_elems = nr_of_bufs;
+    ev.reqpicq.data_buf_shmid = data_shmid;
+    
     
-    ev.reqpicbuf.nr_of_elems = nr_of_bufs;
-    ev.reqpicbuf.data_buf_shmid = data_shmid;
-      
     if(MsgSendEvent(msgq, CLIENT_RESOURCE_MANAGER, &ev, 0) == -1) {
-      ERROR("%s", "couldn't send picbuf request\n");
+      ERROR("%s", "couldn't send picq request\n");
     }
     
     /* wait for answer */
-    
     while(1) {
       if(MsgNextEvent(msgq, &ev) != -1) {
-	if(ev.type == MsgEventQGntPicBuf) {
-	  q_shmid = ev.gntpicbuf.q_shmid;
+	if(ev.type == MsgEventQGntPicQ) {
+	  q_shmid = ev.gntpicq.q_shmid;
 	  break;
 	} else {
 	  handle_events(msgq, &ev);
 	}
       }
     }
-
-    if(q_shmid >= 0) {
-      if((q_shmaddr = shmat(q_shmid, NULL, SHM_SHARE_MMU)) == (void *)-1) {
+    
+    if(q_shmid != -1) {
+      if((q_shmaddr = ogle_shmat(q_shmid)) == (void *)-1) {
 	perror("**video_decode: attach_picq_buffer(), shmat()");
 	return -1;
       }
@@ -993,15 +1018,13 @@
     ERROR("%s", "couldn't get buffer\n");
   }
   
-
-
-
+  
   data_q->q_head = q_head;
   data_q->q_elems = q_elems;
   data_q->data_head = data_head;
   data_q->data_elems = data_elems;
   data_q->image_bufs = image_bufs;
-    
+  
 #ifdef HAVE_MMX
   emms();
 #endif
@@ -1047,7 +1070,7 @@
 	   ((double)(seq.ext.frame_rate_extension_d)+1.0));
     break;
   }
-
+  
   return 0;
 }
 
@@ -1659,17 +1682,18 @@
 {
   MsgEvent_t ev;
   int elem;
-  
+  volatile int *in_use;
   elem = data_q->q_head->write_nr;
   /*
   fprintf(stderr, "DEBUG[vs]: try put picture in q, elem: @%d, bufid: @%d\n",
 	  elem, id);
   */
-  if(data_q->q_elems[elem].in_use) {
+  in_use = &(data_q->q_elems[elem].in_use);
+  if(*in_use) {
     data_q->q_head->writer_requests_notification = 1;
     //fprintf(stderr, "vs:  elem in use, setting notification\n");
     
-    while(data_q->q_elems[elem].in_use) {
+    while(*in_use) {
       //fprintf(stderr, "video_decode: waiting for notification2\n");
       if(MsgNextEvent(msgq, &ev) != -1) {
 	handle_events(msgq, &ev);
@@ -1680,7 +1704,7 @@
   //fprintf(stderr, "vs:  elem free to fill\n");  
   
   data_q->q_elems[elem].data_elem_index = id;
-  data_q->q_elems[elem].in_use = 1;
+  *in_use = 1;
   
   data_q->q_head->write_nr =
     (data_q->q_head->write_nr + 1) % data_q->q_head->nr_of_qelems;
@@ -1722,7 +1746,7 @@
 #endif
   
   
-  if(msgqid != -1) {
+  if(!standalone) {
     MsgEvent_t ev;
     while(MsgCheckEvent(msgq, &ev) != -1) {
       handle_events(msgq, &ev);
@@ -2138,7 +2162,7 @@
 
 
   /* now we can decode the picture if it shouldn't be dropped */
-  if(!drop_frame && (flush_to_scrid == -1)) {
+  if(!drop_frame && (flush_to_scrid == -1) && video_state) {
     /* Decode the slices. */
     if( MPEG2 ) {
       do {
@@ -2188,7 +2212,7 @@
 	last_pts_to_dpy = pinfos[buf_id].PTS;
 	last_scr_nr_to_dpy = pinfos[buf_id].scr_nr;//?
 	
-	if(drop_frame || (flush_to_scrid != -1)) {
+	if(drop_frame || (flush_to_scrid != -1) || !video_state) {
 	  drop_frame = 0;
 	  pinfos[buf_id].is_reference = 0; //this is never set in a B picture?
 	  pinfos[buf_id].displayed = 1;
@@ -2242,7 +2266,7 @@
       last_pts_to_dpy = pinfos[bwd_ref_buf_id].PTS;
       last_scr_nr_to_dpy = pinfos[bwd_ref_buf_id].scr_nr;
 
-      if(flush_to_scrid != -1) {
+      if(flush_to_scrid != -1 || !video_state) {
 	pinfos[bwd_ref_buf_id].is_reference = 0;
 	pinfos[bwd_ref_buf_id].displayed = 1;
       } else {
diff -urN -x CVS -x .cvsignore ogle-0.9.2/mpeg2_video/yuv2rgb.c ogle/mpeg2_video/yuv2rgb.c
--- ogle-0.9.2/mpeg2_video/yuv2rgb.c	2003-10-20 22:28:27.000000000 +0200
+++ ogle/mpeg2_video/yuv2rgb.c	2005-05-16 22:50:16.000000000 +0200
@@ -55,7 +55,7 @@
     ;
   
   if( yuv2rgb == NULL ) {
-    fprintf( stderr, "No accelerated colorspace coversion found\n" );
+    fprintf( stderr, "No accelerated colorspace conversion found\n" );
     yuv2rgb = yuv2rgb_c_init(bpp, mode);
   }
 }
diff -urN -x CVS -x .cvsignore ogle-0.9.2/mpeg2_video/yuv2rgb_mmx.c ogle/mpeg2_video/yuv2rgb_mmx.c
--- ogle-0.9.2/mpeg2_video/yuv2rgb_mmx.c	2003-05-26 23:29:01.000000000 +0200
+++ ogle/mpeg2_video/yuv2rgb_mmx.c	2005-09-01 02:14:15.000000000 +0200
@@ -30,23 +30,23 @@
 
 #ifdef HAVE_MMX
 //static unsigned long  MMX_10w[]         = {0x00100010, 0x00100010};
-static unsigned long  MMX_80w[]         = {0x00800080, 0x00800080};
+static uint32_t MMX_80w[]         = {0x00800080, 0x00800080};
 
-static unsigned long  MMX_00FFw[]       = {0x00ff00ff, 0x00ff00ff};
+static uint32_t MMX_00FFw[]       = {0x00ff00ff, 0x00ff00ff};
 
-static unsigned short MMX_Ublucoeff[]   = {0x0081, 0x0081, 0x0081, 0x0081};
-static unsigned short MMX_Vredcoeff[]   = {0x0066, 0x0066, 0x0066, 0x0066};
+static uint16_t MMX_Ublucoeff[]   = {0x0081, 0x0081, 0x0081, 0x0081};
+static uint16_t MMX_Vredcoeff[]   = {0x0066, 0x0066, 0x0066, 0x0066};
 
-static unsigned short MMX_Ugrncoeff[]   = {0xffe8, 0xffe8, 0xffe8, 0xffe8};
-static unsigned short MMX_Vgrncoeff[]   = {0xffcd, 0xffcd, 0xffcd, 0xffcd};
+static uint16_t MMX_Ugrncoeff[]   = {0xffe8, 0xffe8, 0xffe8, 0xffe8};
+static uint16_t MMX_Vgrncoeff[]   = {0xffcd, 0xffcd, 0xffcd, 0xffcd};
 
-static unsigned short MMX_Ycoeff[]      = {0x004a, 0x004a, 0x004a, 0x004a};
-static unsigned short MMX_redmask[]     = {0xf800, 0xf800, 0xf800, 0xf800};
+static uint16_t MMX_Ycoeff[]      = {0x004a, 0x004a, 0x004a, 0x004a};
+static uint16_t MMX_redmask[]     = {0xf800, 0xf800, 0xf800, 0xf800};
 
-static unsigned short MMX_grnmask[]     = {0x07e0, 0x07e0, 0x07e0, 0x07e0};
+static uint16_t MMX_grnmask[]     = {0x07e0, 0x07e0, 0x07e0, 0x07e0};
 // static unsigned short MMX_blumask[]  = {0x001f, 0x001f, 0x001f, 0x001f};
 
-// get rif of 'defined but unused' warnings
+// get rid of 'defined but unused' warnings
 // gcc doesn't recognise that they _are_ used inside __asm__
 // make dummy use of them
 void __yuv2rgb_mmx_preventwarnings_dontusethis(void)
@@ -69,19 +69,21 @@
 #endif
 #endif
 
-
+/* we depend on long to be 32 bit on x86_32 and 64 bit on x86_64
+   to be able to use the same asm, because pointers are 64bit on x86_64
+*/
 void  YUV2RGB420_MMX_16(uint8_t *out,
                         const uint8_t* lum, const uint8_t* cb,const uint8_t*cr,
-                        const unsigned int cols, const unsigned int rows,
-                        const unsigned int screen_width,
-                        const unsigned int colsY,const unsigned int colsUV) {
-  unsigned short *row1;
-  int x;
-  unsigned char *y;
-  int col1;
-  int mod = screen_width/2-cols;
-  
-  row1 = (unsigned short *)out;
+                        const uint32_t cols, const uint32_t rows,
+                        const uint32_t screen_width,
+                        const uint32_t colsY, const uint32_t colsUV) {
+  uint16_t *row1;
+  long x;
+  uint8_t *y;
+  long col1;
+  long mod = screen_width/2-cols;
+  unsigned long _cols = cols; //this is needed to compile on x86_64
+  row1 = (uint16_t *)out;
   col1 = cols + mod;
   mod += cols + mod;
   mod *= 2;
@@ -225,20 +227,20 @@
          "movq           %%mm4,                  (%4,%5,2)\n"
          "movq           %%mm5,                  8(%4,%5,2)\n"
 
-         "addl           $8,                     %2\n"
-         "addl           $4,                     %0\n"
-         "addl           $4,                     %1\n"
-         "cmpl           %3,                     %6\n"
-         "leal           16(%4),                 %4\n"
+         "add           $8,                     %2\n"
+         "add           $4,                     %0\n"
+         "add           $4,                     %1\n"
+         "cmp           %3,                     %6\n"
+         "lea           16(%4),                 %4\n"
          "jl             1b\n"
-         "addl           %3,                     %2\n"                   /* lum += cols */
-         "addl           %7,                     %4\n"                   /* row1 += mod */
+         "add           %3,                     %2\n" /* lum += cols */
+         "add           %7,                     %4\n" /* row1 += mod */
          "movl           $0,                     %6\n"
-         "cmpl           %8,                     %2\n"
+         "cmp           %8,                     %2\n"
          "jl             1b\n"
          :
-         : "r" (cr), "r" (cb), "r" (lum), "r" (cols), "r" (row1) ,"r" (col1), "m" (x), "m" (mod)
-         , "m" (y)
+         : "r" (cr), "r" (cb), "r" (lum), "r" (_cols), "r" (row1) ,"r" (col1), "m" (x), "m" (mod)
+	   , "m" (y)
          );
       __asm__ __volatile__(
          "emms\n"
@@ -247,7 +249,7 @@
    }
 
 yuv2rgb_fun yuv2rgb_mmx_init(int bpp, int mode) {
-  
+
   if (bpp== 16 && mode == MODE_RGB) {
     fprintf(stdout,"using MMX for yuv2rgb conversion\n"); 
     return YUV2RGB420_MMX_16;
diff -urN -x CVS -x .cvsignore ogle-0.9.2/mpeg_audio/Makefile.am ogle/mpeg_audio/Makefile.am
--- ogle-0.9.2/mpeg_audio/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ ogle/mpeg_audio/Makefile.am	2003-10-14 03:05:15.000000000 +0200
@@ -0,0 +1,24 @@
+# Ogle - A video player
+# Copyright (C) 2000, 2001 Björn Englund, Håkan Hjort, Martin Norbäck
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+pkglib_PROGRAMS = mpg123_wrap
+
+AM_CPPFLAGS = @TOP_INCLUDES@
+AM_CFLAGS = @O_CFLAGS@
+mpg123_wrap_SOURCES = mpg123_wrap.c
+mpg123_wrap_LDADD = $(top_builddir)/common/libcommon.a \
+	$(top_builddir)/ogle/libmsgevents.la
diff -urN -x CVS -x .cvsignore ogle-0.9.2/mpeg_audio/mpg123_wrap.c ogle/mpeg_audio/mpg123_wrap.c
--- ogle-0.9.2/mpeg_audio/mpg123_wrap.c	1970-01-01 01:00:00.000000000 +0100
+++ ogle/mpeg_audio/mpg123_wrap.c	2001-09-16 22:52:31.000000000 +0200
@@ -0,0 +1,415 @@
+/* Ogle - A video player
+ * Copyright (C) 2000, 2001 Björn Englund, Håkan Hjort
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <inttypes.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <sys/shm.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <string.h>
+
+#ifndef SHM_SHARE_MMU
+#define SHM_SHARE_MMU 0
+#endif
+
+#include <ogle/msgevents.h>
+
+#include "debug_print.h"
+#include "common.h"
+#include "queue.h"
+#include "timemath.h"
+#include "sync.h"
+
+
+
+static int get_q();
+static int attach_ctrl_shm(int shmid);
+static int attach_stream_buffer(uint8_t stream_id, uint8_t subtype, int shmid);
+static void handle_events(MsgEventQ_t *q, MsgEvent_t *ev);
+
+static char *program_name;
+
+static char *mmap_base;
+static FILE *outfile;
+
+static int ctrl_data_shmid;
+static ctrl_data_t *ctrl_data;
+static ctrl_time_t *ctrl_time;
+
+static int stream_shmid;
+static char *stream_shmaddr;
+
+static int data_buf_shmid;
+static char *data_buf_shmaddr;
+
+static int msgqid = -1;
+static MsgEventQ_t *msgq;
+
+static int flush_to_scrnr = -1;
+
+void usage()
+{
+  fprintf(stderr, "Usage: %s  [-m <msgid>]\n", 
+	  program_name);
+}
+
+
+int main(int argc, char *argv[])
+{
+  MsgEvent_t ev;
+  int c; 
+  program_name = argv[0];
+  
+  /* Parse command line options */
+  while ((c = getopt(argc, argv, "m:h?")) != EOF) {
+    switch (c) {
+    case 'm':
+      msgqid = atoi(optarg);
+      break;
+    case 'h':
+    case '?':
+      usage();
+      return 1;
+    }
+  }
+
+  if(msgqid == -1) {
+    if(argc - optind != 1){
+      usage();
+      return 1;
+    }
+  }
+
+  // test
+  outfile = fopen("/tmp/audio", "w");
+  
+  if(msgqid != -1) {
+    if((msgq = MsgOpen(msgqid)) == NULL) {
+      fprintf(stderr, "mpg123wrap: couldn't get message q\n");
+      exit(-1);
+    }
+    
+    ev.type = MsgEventQRegister;
+    ev.registercaps.capabilities = DECODE_MPEG1_AUDIO | DECODE_MPEG2_AUDIO;
+    if(MsgSendEvent(msgq, CLIENT_RESOURCE_MANAGER, &ev, 0) == -1) {
+      DPRINTF(1, "mpg123wrap: register capabilities\n");
+    }
+    
+    while(ev.type != MsgEventQDecodeStreamBuf) {
+      MsgNextEvent(msgq, &ev);
+      handle_events(msgq, &ev);
+    }
+    
+  } else {
+    fprintf(stderr, "what?\n");
+  }
+
+  while(1) {
+    get_q();
+  }
+
+  return 0;
+}
+
+static void handle_events(MsgEventQ_t *q, MsgEvent_t *ev)
+{
+  
+  switch(ev->type) {
+  case MsgEventQNotify:
+    DPRINTF(1, "mpg123: got notify\n");
+    break;
+  case MsgEventQFlushData:
+    flush_to_scrnr = ev->flushdata.to_scrnr;
+    break;
+  case MsgEventQDecodeStreamBuf:
+    DPRINTF(1, "mpg123: got stream %x, %x buffer \n",
+	    ev->decodestreambuf.stream_id,
+	    ev->decodestreambuf.subtype);
+    attach_stream_buffer(ev->decodestreambuf.stream_id,
+			  ev->decodestreambuf.subtype,
+			  ev->decodestreambuf.q_shmid);
+    
+    break;
+  case MsgEventQCtrlData:
+    attach_ctrl_shm(ev->ctrldata.shmid);
+    break;
+  default:
+    fprintf(stderr, "mpg123: unrecognized event type: %d\n", ev->type);
+    break;
+  }
+}
+
+
+static void change_file(char *new_filename)
+{
+  int filefd;
+  static struct stat statbuf;
+  int rv;
+  static char *cur_filename = NULL;
+
+  // maybe close file when null ?
+  if(new_filename == NULL) {
+    return;
+  }
+
+  if(new_filename[0] == '\0') {
+    return;
+  }
+
+  // if same filename do nothing
+  if(cur_filename != NULL && strcmp(cur_filename, new_filename) == 0) {
+    return;
+  }
+
+  if(mmap_base != NULL) {
+    munmap(mmap_base, statbuf.st_size);
+  }
+  if(cur_filename != NULL) {
+    free(cur_filename);
+  }
+  
+  filefd = open(new_filename, O_RDONLY);
+  if(filefd == -1) {
+    perror(new_filename);
+    exit(1);
+  }
+
+
+  cur_filename = strdup(new_filename);
+  rv = fstat(filefd, &statbuf);
+  if(rv == -1) {
+    perror("mpg123wrap: fstat");
+    exit(1);
+  }
+  mmap_base = (uint8_t *)mmap(NULL, statbuf.st_size, 
+			      PROT_READ, MAP_SHARED, filefd,0);
+  close(filefd);
+  if(mmap_base == MAP_FAILED) {
+    perror("mpg123wrap: mmap");
+    exit(1);
+  }
+  
+#ifdef HAVE_MADVISE
+  rv = madvise(mmap_base, statbuf.st_size, MADV_SEQUENTIAL);
+  if(rv == -1) {
+    perror("madvise");
+    exit(1);
+  }
+#endif
+
+}
+
+
+int attach_ctrl_shm(int shmid)
+{
+  char *shmaddr;
+  
+  if(shmid >= 0) {
+    if((shmaddr = shmat(shmid, NULL, SHM_SHARE_MMU)) == (void *)-1) {
+      perror("mpg123wrap: attach_ctrl_data(), shmat()");
+      return -1;
+    }
+    
+    ctrl_data_shmid = shmid;
+    ctrl_data = (ctrl_data_t*)shmaddr;
+    ctrl_time = (ctrl_time_t *)(shmaddr+sizeof(ctrl_data_t));
+
+  }    
+  return 0;
+  
+}
+
+int attach_stream_buffer(uint8_t stream_id, uint8_t subtype, int shmid)
+{
+  char *shmaddr;
+  q_head_t *q_head;
+
+  fprintf(stderr, "mpg123wrap: shmid: %d\n", shmid);
+  
+  if(shmid >= 0) {
+    if((shmaddr = shmat(shmid, NULL, SHM_SHARE_MMU)) == (void *)-1) {
+      perror("mpg123wrap: attach_decoder_buffer(), shmat()");
+      return -1;
+    }
+    
+    stream_shmid = shmid;
+    stream_shmaddr = shmaddr;
+    
+  }    
+
+  q_head = (q_head_t *)stream_shmaddr;
+  shmid = q_head->data_buf_shmid;
+  
+  if(shmid >= 0) {
+    if((shmaddr = shmat(shmid, NULL, SHM_SHARE_MMU)) == (void *)-1) {
+      perror("mpeg_audio: attach_data_buffer(), shmat()");
+      return -1;
+    }
+    
+    data_buf_shmid = shmid;
+    data_buf_shmaddr = shmaddr;
+    
+  }    
+  
+  return 0;
+  
+}
+
+
+int get_q()
+{
+  q_head_t *q_head;
+  q_elem_t *q_elems;
+  data_buf_head_t *data_head;
+  data_elem_t *data_elems;
+  data_elem_t *data_elem;
+  int elem;
+  
+  uint8_t PTS_DTS_flags;
+  uint64_t PTS;
+  uint64_t DTS;
+  int scr_nr;
+  int off;
+  int len;
+  static int prev_scr_nr = 0;
+  static clocktime_t time_offset = { 0, 0 };
+  MsgEvent_t ev;
+  
+  q_head = (q_head_t *)stream_shmaddr;
+  q_elems = (q_elem_t *)(stream_shmaddr+sizeof(q_head_t));
+  elem = q_head->read_nr;
+
+  while(MsgCheckEvent(msgq, &ev) != -1) {
+    handle_events(msgq, &ev);
+  }
+
+  if(!q_elems[elem].in_use) {
+    q_head->reader_requests_notification = 1;
+    
+    while(!q_elems[elem].in_use) {
+      DPRINTF(1, "mpg123wrap: waiting for notification1\n");
+      MsgNextEvent(msgq, &ev);
+      handle_events(msgq, &ev);
+    }
+  }
+
+  data_head = (data_buf_head_t *)data_buf_shmaddr;
+  data_elems = (data_elem_t *)(data_buf_shmaddr+sizeof(data_buf_head_t));
+  
+  data_elem = &data_elems[q_elems[elem].data_elem_index];
+
+  
+  PTS_DTS_flags = data_elem->PTS_DTS_flags;
+  PTS = data_elem->PTS;
+  DTS = data_elem->DTS;
+  scr_nr = data_elem->scr_nr;
+  off = data_elem->off;
+  len = data_elem->len;
+
+  if(flush_to_scrnr != -1) {
+    if(flush_to_scrnr != scr_nr) {
+
+      q_head->read_nr = (q_head->read_nr+1)%q_head->nr_of_qelems;
+      
+      change_file(data_elem->filename);
+      // release elem
+      data_elem->in_use = 0;
+      q_elems[elem].in_use = 0;
+      
+      if(q_head->writer_requests_notification) {
+	q_head->writer_requests_notification = 0;
+	ev.type = MsgEventQNotify;
+	if(MsgSendEvent(msgq, q_head->writer, &ev, 0) == -1) {
+	  fprintf(stderr, "mpg123wrap: couldn't send notification\n");
+	}
+      }
+      
+      return 0;
+    } else {
+      flush_to_scrnr = -1;
+    }
+  }
+  
+  if(ctrl_time[scr_nr].sync_master <= SYNC_AUDIO) {
+    ctrl_time[scr_nr].sync_master = SYNC_AUDIO;
+
+    
+    if(ctrl_time[scr_nr].offset_valid == OFFSET_NOT_VALID) {
+      if(PTS_DTS_flags && 0x2) {
+	//set_time_base(PTS, ctrl_time, scr_nr, time_offset);
+      }
+    }
+    if(PTS_DTS_flags && 0x2) {
+      //time_offset = get_time_base_offset(PTS, ctrl_time, scr_nr);
+    }
+    prev_scr_nr = scr_nr;
+    
+    
+    /*
+     * primitive resync in case output buffer is emptied 
+     */
+    if(TIME_SS(time_offset) < 0 || TIME_S(time_offset) < 0) {
+      TIME_S(time_offset) = 0;
+      TIME_SS(time_offset) = 0;
+      fprintf(stderr, "mpg123wrap: setting offset\n");      
+      //set_time_base(PTS, ctrl_time, scr_nr, time_offset);
+    }
+  }
+  
+  if(PTS_DTS_flags & 0x2) {
+    //time_offset = get_time_base_offset(PTS, ctrl_time, scr_nr);
+  }
+
+  /** TODO this is just so we don't buffer alot in the pipe **/
+  {
+    clocktime_t apa = {0, 100000000};
+    timesub(&apa, &time_offset, &apa);
+    if(TIME_SS(apa) > 0) {
+      struct timespec bepa;
+      bepa.tv_sec = TIME_S(time_offset);
+      bepa.tv_nsec = TIME_SS(time_offset) * (1000000000/CT_FRACTION);
+      nanosleep(&bepa, NULL);
+    }
+  }
+  q_head->read_nr = (q_head->read_nr+1)%q_head->nr_of_qelems;
+  change_file(data_elem->filename);
+
+  change_file(data_elem->filename);
+  
+  fwrite(mmap_base+off, len, 1, outfile);
+  
+  data_elem->in_use = 0;
+  q_elems[elem].in_use = 0;
+  
+  // release elem
+  if(q_head->writer_requests_notification) {
+    q_head->writer_requests_notification = 0;
+    ev.type = MsgEventQNotify;
+    if(MsgSendEvent(msgq, q_head->writer, &ev, 0) == -1) {
+      fprintf(stderr, "mpg123wrap: couldn't send notification\n");
+    }
+  }
+
+  return 0;
+}
+
+
diff -urN -x CVS -x .cvsignore ogle-0.9.2/ogle/Makefile.am ogle/ogle/Makefile.am
--- ogle-0.9.2/ogle/Makefile.am	2003-11-04 12:06:59.000000000 +0100
+++ ogle/ogle/Makefile.am	2004-07-29 11:37:18.000000000 +0200
@@ -19,7 +19,7 @@
 pkginclude_HEADERS = dvd.h dvdcontrol.h msgevents.h dvdevents.h dvdbookmarks.h
 
 
-AM_CPPFLAGS = @TOP_INCLUDES@ @XML_CFLAGS@
+AM_CPPFLAGS = @TOP_INCLUDES@ @XML_CPPFLAGS@
 AM_CFLAGS = @O_CFLAGS@
 
 libmsgevents_la_SOURCES = msgevents.c
diff -urN -x CVS -x .cvsignore ogle-0.9.2/ogle/dvd.h ogle/ogle/dvd.h
--- ogle-0.9.2/ogle/dvd.h	2003-08-10 23:15:07.000000000 +0200
+++ ogle/ogle/dvd.h	2004-08-21 10:11:28.000000000 +0200
@@ -30,7 +30,8 @@
   DVD_E_NotImplemented = 128,  /**< The function is not implemented */
   DVD_E_NOMEM,
   DVD_E_RootNotSet,
-  DVD_E_FailedToSend          /**< Unable to send the request/event */
+  DVD_E_FailedToSend,          /**< Unable to send the request/event */
+  DVD_E_Invalid,               /**< Invalid argument */
 } DVDResult_t;
 
 
@@ -150,6 +151,25 @@
   uint8_t Frames;
 } DVDTimecode_t;
 
+
+/**
+ * Video state
+ */
+typedef enum {
+  DVD_VIDEO_STATE_OFF       = 0, /**< video off */
+  DVD_VIDEO_STATE_ON        = 1, /**< video on  */
+} DVDVideoState_t;
+
+/**
+ * Subpicture state
+ */
+typedef enum {
+  DVD_SUBPICTURE_STATE_OFF       = 0, /**< normal subpictures off */
+  DVD_SUBPICTURE_STATE_ON        = 1, /**< normal subpictures on  */
+  DVD_SUBPICTURE_STATE_FORCEDOFF = 2, /**< normal/forced subp off (vts dom) */
+  DVD_SUBPICTURE_STATE_DISABLED  = 3  /**< subpicture overlay off (all dom) */
+} DVDSubpictureState_t;
+
 /** 
  * Subpicture stream number (0-31,62,63)
  */
@@ -248,6 +268,11 @@
 typedef int DVDChannelNumber_t;    /**< TBD */
 
 
+typedef enum {
+  DVD_AUDIO_TYPE_NotSpecified = 0,
+  DVD_AUDIO_TYPE_Language     = 1,
+} DVDAudioType_t;
+
 typedef struct {
   DVDAudioAppMode_t     AppMode;
   DVDAudioFormat_t      AudioFormat;
@@ -257,6 +282,7 @@
   DVDAudioSampleFreq_t  SampleFrequency;
   DVDAudioSampleQuant_t SampleQuantization;
   DVDChannelNumber_t    NumberOfChannels;
+  DVDAudioType_t        AudioType;
 } DVDAudioAttributes_t;
 
 typedef enum {
diff -urN -x CVS -x .cvsignore ogle-0.9.2/ogle/dvdcontrol.c ogle/ogle/dvdcontrol.c
--- ogle-0.9.2/ogle/dvdcontrol.c	2003-08-10 23:15:07.000000000 +0200
+++ ogle/ogle/dvdcontrol.c	2005-08-20 16:37:10.000000000 +0200
@@ -1,5 +1,5 @@
 /* Ogle - A video player
- * Copyright (C) 2000, 2001 Björn Englund, Håkan Hjort
+ * Copyright (C) 2000, 2001, 2005 Björn Englund, Håkan Hjort
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -19,7 +19,6 @@
 #include <stdlib.h>
 #include <stdio.h>
 #include <unistd.h>
-#include <sys/msg.h>
 #include <string.h>
 #include <errno.h>
 
@@ -135,8 +134,10 @@
  * Get a connection to the DVD navigator
  * @todo something
  */
-DVDResult_t DVDOpenNav(DVDNav_t **nav, int msgqid) {
+DVDResult_t DVDOpenNav(DVDNav_t **nav, char* msgq_str) {
   MsgEvent_t ev;
+  MsgEventQType_t msgq_type;
+  char *msgqid;
 
   *nav = (DVDNav_t *)malloc(sizeof(DVDNav_t));
   if(*nav == NULL) {
@@ -144,10 +145,18 @@
   }
   (*nav)->serial = 0;
 
-  if(((*nav)->msgq = MsgOpen(msgqid)) == NULL) {
+  
+  if(get_msgqtype(msgq_str, &msgq_type, &msgqid) == -1) {
+    fprintf(stderr, "DVDOpenMav: unknown msgq type: %s\n", msgq_str);
+    return 1;
+  }
+
+  if(((*nav)->msgq = MsgOpen(MsgEventQType_socket, 
+			     msgqid, strlen(msgqid))) == NULL) {
     free(*nav);
     return DVD_E_Unspecified;
   }
+
   
   ev.type = MsgEventQRegister;
   ev.registercaps.capabilities = UI_DVD_GUI;
@@ -199,10 +208,13 @@
 static const char DVD_E_RootNotSet_STR[] = "Root not set";
 static const char DVD_E_FailedToSend_STR[] = "Failed to send request";
 static const char DVD_E_NOMEM_STR[] = "Out of memory";
+static const char DVD_E_Invalid_STR[] = "Invalid Argument";
+
+
 /**
- * Print DVD error messages
+ * Return DVD error strings
  */
-void DVDPerror(const char *str, DVDResult_t ErrCode)
+const char *DVDStrerror(DVDResult_t ErrCode)
 {
   const char *errstr;
   
@@ -225,16 +237,61 @@
   case DVD_E_NOMEM:
     errstr = DVD_E_NOMEM_STR;
     break;
+  case DVD_E_Invalid:
+    errstr = DVD_E_Invalid_STR;
+    break;
   default:
     errstr = DVD_E_NoSuchError_STR;
     break;
   }
 
+  return errstr;
+}
+
+
+/**
+ * Print DVD error messages
+ */
+void DVDPerror(const char *str, DVDResult_t ErrCode)
+{
+  const char *errstr;
+
+  errstr = DVDStrerror(ErrCode);
+
   fprintf(stderr, "%s%s %s\n",
 	  (str == NULL ? "" : str),
 	  (str == NULL ? "" : ":"),
 	  errstr);
+}
 
+/**
+ * Get the filedescriptor(s) used by libdvdread, poll/select on them
+ * to know when you need to call DVDNextEvent.
+ * When not needed anymore the pointer returned in fds should be
+ * free()d
+ */
+DVDResult_t DVDInternalConnectionNumbers(DVDNav_t *nav, int **fds, int *count)
+{
+  int *ret_fds;
+  int ret_count;
+
+  switch(nav->msgq->type) {
+  case MsgEventQType_socket:
+    ret_count = 1;
+    ret_fds = malloc(sizeof(int)*ret_count);
+    if(ret_fds == NULL) {
+      return DVD_E_NOMEM;
+    }
+    *ret_fds = nav->msgq->socket.sd;
+    *fds = ret_fds;
+    *count = ret_count;
+    return DVD_E_Ok;
+    break;
+  default:  
+    break;
+  }
+  
+  return DVD_E_NotImplemented; 
 }
 
 
@@ -321,7 +378,7 @@
  * 
  * @param nav Specifies the connection to the DVD navigator.
  * @param StreamNr Specifies the audio stream which attributes
- * will be retrieved.
+ * will be retrieved for.
  * @param Attr Points to where the attributes of the specified
  * audio stream will be written.
  *
@@ -331,6 +388,7 @@
  *
  * @retval DVD_E_Ok Success.
  * @retval DVD_E_FailedToSend Failed to send the request.
+ * @retval DVD_E_Invalid StreamNr is out of range ( >= available streams).
  */
 DVDResult_t DVDGetAudioAttributes(DVDNav_t *nav, DVDAudioStream_t StreamNr,
 				  DVDAudioAttributes_t *const Attr)
@@ -396,9 +454,9 @@
  *
  * @param nav Specifies the connection to the DVD navigator.
  * @param StreamsAvailable Points to where the number of available 
- * streams will be written.
- * @param CurrentStream Points to where the current stream will be written.
- *
+ * streams will be written 0 - 8.
+ * @param CurrentStream Points to where the current stream will be written
+ * 0 - 7 or 15 (0xF) in case of no audio stream decoded
  * @return If successful DVD_E_Ok is returned. Otherwise an error code
  * is returned.
  *
@@ -444,7 +502,7 @@
  * @todo more return values
  *
  * @param nav Specifies the connection to the DVD navigator.
- * @param StreamNr Specify the audio stream to retrieve information about.
+ * @param StreamNr Specify the audio stream to retrieve information about 0-7.
  * @param Enabled Specifies if the audio stream is enabled or disabled.
  *
  * @return If successful DVD_E_Ok is returned. Otherwise an error code
@@ -510,6 +568,9 @@
 /** 
  * Querry the currently selected angle.
  * @param nav Specifies the connection to the DVD navigator.
+ * @param AnglesAvailable Returns the number of available angles (1-9).
+ * (1 means normal, non multi-angle video)
+ * @param CurrentAngle Returns the current angle (1-9)
  *
  * @return If successful DVD_E_Ok is returned. Otherwise an error code
  * is returned.
@@ -799,7 +860,7 @@
 DVDResult_t DVDGetCurrentSubpicture(DVDNav_t *nav,
 				    int *const StreamsAvailable,
 				    DVDSubpictureStream_t *const CurrentStream,
-				    DVDBool_t *const Display)
+				    DVDSubpictureState_t *const State)
 {
   MsgEvent_t ev;
   int32_t serial;
@@ -825,7 +886,7 @@
        (ev.dvdctrl.cmd.type == DVDCtrlCurrentSubpicture)) {
       *StreamsAvailable = ev.dvdctrl.cmd.currentsubpicture.nrofstreams;
       *CurrentStream = ev.dvdctrl.cmd.currentsubpicture.currentstream;
-      *Display = ev.dvdctrl.cmd.currentsubpicture.display;
+      *State = ev.dvdctrl.cmd.currentsubpicture.display;
       return DVD_E_Ok;
     }
   } 
@@ -900,6 +961,7 @@
  *
  * @retval DVD_E_Ok Success.
  * @retval DVD_E_FailedToSend Failed to send the request. 
+ * @retval DVD_E_Invalid StreamNr is out of range (>= available streams). 
  */
 DVDResult_t DVDGetSubpictureAttributes(DVDNav_t *nav,
 				       DVDSubpictureStream_t StreamNr,
@@ -1156,8 +1218,44 @@
 
 /** @} end of dvdinfo */
 
+
+static void msgqinput_to_dvdinput(DVDEvent_t *ev, MsgEvent_t *mev)
+{
+  switch(mev->type) {
+  case MsgEventQInputButtonPress:
+    ev->type = DVDEventInputButtonPress;
+    break;
+  case MsgEventQInputButtonRelease:
+    ev->type = DVDEventInputButtonRelease;
+    break;
+  case MsgEventQInputPointerMotion:
+    ev->type = DVDEventInputPointerMotion;
+    break;
+  case MsgEventQInputKeyPress:
+    ev->type = DVDEventInputKeyPress;
+    break;
+  case MsgEventQInputKeyRelease:
+    ev->type = DVDEventInputKeyRelease;
+    break;
+  default:
+    break;
+  }
+
+  ev->input.serial = 0;
+  ev->input.x = mev->input.x;
+  ev->input.y = mev->input.y;
+  ev->input.x_root = mev->input.x_root;
+  ev->input.y_root = mev->input.y_root;
+  ev->input.mod_mask = mev->input.mod_mask;
+  ev->input.input = mev->input.input;
+  ev->input.time = mev->input.time;
+  ev->input.input_base = mev->input.input_base;
+  ev->input.input_keycode = mev->input.input_keycode;
+  
+}
+
 /** 
- * @todo Remove this function.
+ * @todo Something.
  *
  * @param nav Specifies the connection to the DVD navigator.
  * @param ev is the returned message in case DVD_E_Ok is returned.
@@ -1168,27 +1266,32 @@
  * @retval DVD_E_Ok Success.
  * @retval DVD_E_Unspecified. Failure.
  */
-DVDResult_t DVDNextEvent(DVDNav_t *nav, MsgEvent_t *ev)
+DVDResult_t DVDNextEvent(DVDNav_t *nav, DVDEvent_t *ev)
 {
-  
-  if(MsgNextEvent(nav->msgq, ev) == -1) {
+  MsgEvent_t mev;
+  if(MsgNextEvent(nav->msgq, &mev) == -1) {
     return DVD_E_Unspecified;
   }
-  
-  return DVD_E_Ok;  
-} 
 
-#if (defined(BSD) && (BSD >= 199306))
-DVDResult_t DVDNextEventNonBlocking(DVDNav_t *nav, MsgEvent_t *ev)
-{
-  
-  if(MsgNextEventNonBlocking(nav->msgq, ev) == -1) {
-    return DVD_E_Unspecified;
+  switch(mev.type) {
+  case MsgEventQDVDCtrl:
+    *ev = *(DVDEvent_t *)&mev.dvdctrl.cmd;
+    break;
+  case MsgEventQInputButtonPress:
+  case MsgEventQInputButtonRelease:
+  case MsgEventQInputPointerMotion:
+  case MsgEventQInputKeyPress:
+  case MsgEventQInputKeyRelease:
+    msgqinput_to_dvdinput(ev, &mev);
+    break;
+  default:
+    fprintf(stderr, "DVDNextEvent not a valid event %d\n", mev.type);
+    return DVD_E_Unspecified;  
+    break;
   }
-  
-  return DVD_E_Ok;
+  return DVD_E_Ok;  
 } 
-#endif
+
 
 DVDResult_t DVDRequestInput(DVDNav_t *nav, InputMask_t mask)
 {
@@ -2191,7 +2294,7 @@
  * @todo more return values.
  *
  * @param nav Specifies the connection to the DVD navigator.
- * @param StreamNr Specifies which audio stream to decode
+ * @param StreamNr Specifies which audio stream to decode (0-7)
  *
  * @return If successful DVD_E_Ok is returned. Otherwise an error code
  * is returned.
@@ -2265,6 +2368,7 @@
  * @todo Implement function
  *
  * @param nav Specifies the connection to the DVD navigator.
+ * @param AngleNr Specifies the angle to change to (1-9)
  *
  * @return If successful DVD_E_Ok is returned. Otherwise an error code
  * is returned.
@@ -2395,13 +2499,42 @@
  * @retval DVD_E_Ok Success.
  * @retval DVD_E_FailedToSend Failed to send the request.
  */
-DVDResult_t DVDSetSubpictureState(DVDNav_t *nav, DVDBool_t Display)
+DVDResult_t DVDSetSubpictureState(DVDNav_t *nav, DVDSubpictureState_t State)
 {
   MsgEvent_t ev;
   ev.type = MsgEventQDVDCtrl;
   DVD_SETSERIAL(nav, ev.dvdctrl.cmd);
   ev.dvdctrl.cmd.type = DVDCtrlSetSubpictureState;
-  ev.dvdctrl.cmd.subpicturestate.display = Display;
+  ev.dvdctrl.cmd.subpicturestate.display = State;
+
+  if(MsgSendEvent(nav->msgq, nav->client, &ev, 0) == -1) {
+    return DVD_E_FailedToSend;
+  }
+  
+  return DVD_E_Ok;
+}
+
+
+/**
+ * Set the display of video on or off.
+ * @todo more return values.
+ *
+ * @param nav Specifies the connection to the DVD navigator.
+ * @param Display Specifies wheter to disaply or hide video.
+ *
+ * @return If successful DVD_E_Ok is returned. Otherwise an error code
+ * is returned.
+ *
+ * @retval DVD_E_Ok Success.
+ * @retval DVD_E_FailedToSend Failed to send the request.
+ */
+DVDResult_t DVDSetVideoState(DVDNav_t *nav, DVDVideoState_t State)
+{
+  MsgEvent_t ev;
+  ev.type = MsgEventQDVDCtrl;
+  DVD_SETSERIAL(nav, ev.dvdctrl.cmd);
+  ev.dvdctrl.cmd.type = DVDCtrlSetVideoState;
+  ev.dvdctrl.cmd.videostate.display = State;
 
   if(MsgSendEvent(nav->msgq, nav->client, &ev, 0) == -1) {
     return DVD_E_FailedToSend;
diff -urN -x CVS -x .cvsignore ogle-0.9.2/ogle/dvdcontrol.h ogle/ogle/dvdcontrol.h
--- ogle-0.9.2/ogle/dvdcontrol.h	2003-08-10 23:15:07.000000000 +0200
+++ ogle/ogle/dvdcontrol.h	2004-08-21 10:11:28.000000000 +0200
@@ -19,17 +19,20 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#include <ogle/dvd.h>
-#include <ogle/msgevents.h> /* Only for the hack with DVDNextEvent !! */
-#include <ogle/dvdbookmarks.h>
+#include "dvd.h"
+#include "dvdevents.h"
+#include "dvdbookmarks.h"
 
 #include <sys/param.h>
 
 typedef struct DVDNav_s DVDNav_t;
 
-DVDResult_t DVDOpenNav(DVDNav_t **nav, int msgqid);
+
+DVDResult_t DVDOpenNav(DVDNav_t **nav, char* msgq_str);
+
 DVDResult_t DVDCloseNav(DVDNav_t *nav);
 
+const char *DVDStrerror(DVDResult_t ErrCode);
 void DVDPerror(const char *str, DVDResult_t ErrCode);
 
 /* info commands */
@@ -68,7 +71,7 @@
 DVDResult_t DVDGetCurrentSubpicture(DVDNav_t *nav,
 				    int *const StreamsAvailable,
 				    DVDSubpictureStream_t *const CurrentStream,
-				    DVDBool_t *const Enabled);
+				    DVDSubpictureState_t *const State);
 DVDResult_t DVDIsSubpictureStreamEnabled(DVDNav_t *nav,
 					 DVDSubpictureStream_t StreamNr,
 					 DVDBool_t *const Enabled);
@@ -92,11 +95,8 @@
 				    unsigned char *volsetid);
 /* end info commands */
 
-/* hack */
-#if (defined(BSD) && (BSD >= 199306))
-DVDResult_t DVDNextEventNonBlocking(DVDNav_t *nav, MsgEvent_t *ev);
-#endif
-DVDResult_t DVDNextEvent(DVDNav_t *nav, MsgEvent_t *ev);
+
+DVDResult_t DVDNextEvent(DVDNav_t *nav, DVDEvent_t *ev);
 DVDResult_t DVDRequestInput(DVDNav_t *nav, InputMask_t mask);
 
 /* control commands */
@@ -170,10 +170,11 @@
 
 DVDResult_t DVDSubpictureStreamChange(DVDNav_t *nav,
 				      DVDSubpictureStream_t SubpictureNr);
-DVDResult_t DVDSetSubpictureState(DVDNav_t *nav, DVDBool_t Display);
+DVDResult_t DVDSetSubpictureState(DVDNav_t *nav, DVDSubpictureState_t state);
 DVDResult_t DVDDefaultSubpictureLanguageSelect(DVDNav_t *nav,
 					       DVDLangID_t Lang);
 
+DVDResult_t DVDSetVideoState(DVDNav_t *nav, DVDVideoState_t State);
 DVDResult_t DVDParentalCountrySelect(DVDNav_t *nav, DVDCountryID_t country);
 DVDResult_t DVDParentalLevelSelect(DVDNav_t *nav, DVDParentalLevel_t level);
 
diff -urN -x CVS -x .cvsignore ogle-0.9.2/ogle/dvdevents.h ogle/ogle/dvdevents.h
--- ogle-0.9.2/ogle/dvdevents.h	2003-02-23 18:45:38.000000000 +0100
+++ ogle/ogle/dvdevents.h	2005-08-20 16:37:10.000000000 +0200
@@ -2,7 +2,7 @@
 #define DVDEVENTS_H_INCLUDED
 
 /* Ogle - A video player
- * Copyright (C) 2000, 2001 Björn Englund, Håkan Hjort
+ * Copyright (C) 2000, 2001, 2005 Björn Englund, Håkan Hjort
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -19,7 +19,7 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 #include <limits.h>
-#include <ogle/dvd.h>
+#include "dvd.h"
 
 typedef enum {
   DVDCtrlButtonMask = 0x01000000,
@@ -128,12 +128,14 @@
   
   DVDCtrlTimeSkip,
 
-  DVDCtrlRetVal
+  DVDCtrlRetVal,
+
+  DVDCtrlSetVideoState
 
 } DVDCtrlEventType_t;
 
 typedef enum {
-  DVDCtrlLongSetDVDRoot,
+  DVDCtrlLongSetDVDRoot = 0x10000000,
   DVDCtrlLongState,
   DVDCtrlLongSetState,
   DVDCtrlLongVolIds
@@ -327,15 +329,21 @@
 typedef struct {
   DVDCtrlEventType_t type;
   int32_t serial;
-  DVDBool_t display;
+  DVDSubpictureState_t display;
 } DVDCtrlSubpictureStateEvent_t;
 
 typedef struct {
   DVDCtrlEventType_t type;
   int32_t serial;
+  DVDVideoState_t display;
+} DVDCtrlVideoStateEvent_t;
+
+typedef struct {
+  DVDCtrlEventType_t type;
+  int32_t serial;
   int nrofstreams;
   DVDSubpictureStream_t currentstream;
-  DVDBool_t display;
+  DVDSubpictureState_t display;
 } DVDCtrlCurrentSubpictureEvent_t;
 
 typedef struct {
@@ -425,6 +433,8 @@
 
   DVDCtrlSubpictureStateEvent_t subpicturestate;
 
+  DVDCtrlVideoStateEvent_t videostate;
+
   DVDCtrlAngleChangeEvent_t anglechange;
   
   DVDCtrlTimeSkipEvent_t timeskip;
@@ -465,4 +475,38 @@
 } DVDCtrlLongEvent_t;
 
 
+
+typedef enum {
+  DVDEventCurrentUOPS = DVDCtrlCurrentUOPS,
+  DVDEventInputButtonPress,
+  DVDEventInputButtonRelease,
+  DVDEventInputPointerMotion,
+  DVDEventInputKeyPress,
+  DVDEventInputKeyRelease,
+} DVDEventType_t;
+
+typedef DVDCtrlAnyEvent_t    DVDEventAny_t;
+typedef DVDCtrlCurrentUOPS_t DVDEventUOPS_t;
+
+typedef struct {
+  DVDEventType_t type;
+  int32_t serial;
+  int x;
+  int y;
+  int x_root;
+  int y_root;
+  unsigned long mod_mask; /* X modifiers (keys/buttons)*/
+  unsigned long input;
+  unsigned long time; /* milliseconds */
+  unsigned long input_base;
+  unsigned int input_keycode;
+} DVDEventInput_t;
+		
+
+typedef union {
+  DVDEventType_t    type;
+  DVDEventUOPS_t    uops;
+  DVDEventInput_t   input;
+} DVDEvent_t;
+
 #endif /* DVDEVENTS_H_INCLUDED */
diff -urN -x CVS -x .cvsignore ogle-0.9.2/ogle/msgevents.c ogle/ogle/msgevents.c
--- ogle-0.9.2/ogle/msgevents.c	2003-08-10 23:15:07.000000000 +0200
+++ ogle/ogle/msgevents.c	2006-01-25 17:54:11.000000000 +0100
@@ -1,5 +1,5 @@
 /* Ogle - A video player
- * Copyright (C) 2000, 2001 Björn Englund, Håkan Hjort
+ * Copyright (C) 2000, 2001, 2005 Björn Englund, Håkan Hjort
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -20,23 +20,46 @@
 #include <stdlib.h>
 #include <string.h>
 #include <sys/types.h>
-#include <sys/ipc.h>
-#include <sys/msg.h>
+#include <unistd.h>
+
+
 #include <errno.h>
 
 #include "dvd.h"
 #include "dvdevents.h"
 #include "msgevents.h"
 
+#ifdef HAVE_SYSV_MSG
+#include <sys/ipc.h>
+#include <sys/msg.h>
+#endif
+
 #ifdef HAVE_SYS_PARAM_H
 #include <sys/param.h>
 #endif
 
-#if (defined(BSD) && (BSD >= 199306))
-#include <unistd.h>
+#ifdef HAVE_POLL
+
+#if defined(HAVE_POLL_H)
+#include <poll.h>
+#elif defined(HAVE_SYS_POLL_H)
+#include <sys/poll.h>
 #endif
 
+#else //HAVE_POLL
+
+#ifdef HAVE_SYS_SELECT
+#include <sys/select.h>
+#else
+#include <sys/time.h>
+#endif
+
+#endif //HAVE_POLL
+
+
 //#define DEBUG
+//#define XDEBUG
+
 #ifdef DEBUG
 
 static char *MsgEventType_str[] = {
@@ -56,8 +79,8 @@
   "MsgEventQReqBuf",
   "MsgEventQGntBuf",
   "MsgEventQCtrlData",
-  "MsgEventQReqPicBuf",
-  "MsgEventQGntPicBuf",
+  "MsgEventQReqPicQ",
+  "MsgEventQGntPicQ",
   "MsgEventQAttachQ",
   "MsgEventQSPUPalette",
   "MsgEventQSPUHighlight", // 20
@@ -87,6 +110,13 @@
   "MsgEventQDestroyQ",
   "MsgEventQDemuxStreamChange2",
   "MsgEventQSaveScreenshot",
+  "MsgEventQSPUState",
+  "MsgEventQReqPicBuf",
+  "MsgEventQGntPicBuf",
+  "MsgEventQDestroyBuf",
+  "MsgEventQDemuxStreamEnable",
+  "MsgEventQStop",
+  "MsgEventQSetDecodeVideoState",
   NULL
 };
 
@@ -103,15 +133,18 @@
   msg_t msg;
   MsgQInitReqEvent_t initreq;
   MsgQInitGntEvent_t initgnt;
-  
-  msg.mtype = CLIENT_RESOURCE_MANAGER; // the recipient of this message
-  initreq.type = MsgEventQInitReq;   // we want a handle
-  memcpy(msg.event_data, &initreq, sizeof(MsgQInitReqEvent_t));
-  
+  int r;
+
   switch(type) {
+#ifdef HAVE_SYSV_MSG
   case MsgEventQType_msgq:
     {
       int msqid = atoi(name);
+
+      msg.msgq.mtype = CLIENT_RESOURCE_MANAGER; //the recipient of this message
+      initreq.type = MsgEventQInitReq;   // we want a handle
+      memcpy(msg.msgq.event_data, &initreq, sizeof(MsgQInitReqEvent_t));
+  
       
       if(msgsnd(msqid, (void *)&msg, sizeof(MsgQInitReqEvent_t), 0) == -1) {
 	perror("MsgOpen, snd");
@@ -125,61 +158,130 @@
 	} else {
 	  ret = (MsgEventQ_t *)malloc(sizeof(MsgEventQ_t));
 	  
-	  ret->msg.type = MsgEventQType_msgq;
-	  ret->msq.msqid = msqid;       // which msq to wait for messages on
-	  memcpy(&initgnt, msg.event_data, sizeof(MsgQInitGntEvent_t));
-	  ret->msg.mtype = initgnt.newclientid; // mtype to wait for
+	  ret->msgq.type = MsgEventQType_msgq;
+	  ret->msgq.msqid = msqid;       // which msq to wait for messages on
+	  memcpy(&initgnt, msg.msgq.event_data, sizeof(MsgQInitGntEvent_t));
+	  ret->msgq.mtype = initgnt.newclientid; // mtype to wait for
 	  
 	}
       }
     }
     break;
+#endif
   case MsgEventQType_socket:
     {
       int sd;
       struct sockaddr_un unix_addr = { 0 };
+      struct sockaddr_un tmp_addr = { 0 };
+      struct sockaddr_un from_addr = { 0 };
+      int from_addr_len;
+      int n;
+      static unsigned int ser = 0;
+      long int tmp_clientid;
       
       if((sd = socket(PF_UNIX, SOCK_DGRAM, 0)) == -1) {
 	perror("socket");
 	return NULL;
       }
 
+      tmp_addr.sun_family = AF_UNIX;
+
+      //try 10 times then fail
+      for(n=0; n<10; n++) {
+	//create a name for the socket
+	tmp_clientid = getpid()*10+ser;
+	ser = (ser+1)%10;
+	snprintf(tmp_addr.sun_path, sizeof(tmp_addr.sun_path),
+		 "%s/%ld", name, tmp_clientid);
+
+	if(bind(sd, (struct sockaddr *)&tmp_addr, sizeof(tmp_addr)) == -1) {
+	  perror("bind()");
+	  //return NULL;
+	} else {
+	  break;
+	}
+      }
+      if(n==10) {
+	return NULL;
+      }
+
+      initreq.type = MsgEventQInitReq;   // we want a handle
+      initreq.client = tmp_clientid;
+      memcpy(msg.socket.event_data, &initreq, sizeof(MsgQInitReqEvent_t));
+
       unix_addr.sun_family = AF_UNIX;
       
       if(strlen(name) >= sizeof(unix_addr.sun_path)) {
 	return NULL;
-      }      
-      strcpy(unix_addr.sun_path, name);
+      }
+      snprintf(unix_addr.sun_path, sizeof(unix_addr.sun_path),
+	       "%s/%ld", name, CLIENT_RESOURCE_MANAGER);
       
+
+#if 0      
       if(connect(sd, (struct sockaddr *)&unix_addr, sizeof(unix_addr)) == -1) {
 	perror("connect");
 	return NULL;
       }
-      
-
+#endif      
 
+      //send init request
+      if((r = sendto(sd, &msg, sizeof(MsgQInitReqEvent_t), 0,
+		     (struct sockaddr *)&unix_addr,
+		     sizeof(unix_addr))) == -1) {
+	perror("MsgOpen, sendto");
+	return NULL;
+      }
 
-      if(msgsnd(msqid, (void *)&msg, sizeof(MsgQInitReqEvent_t), 0) == -1) {
-	perror("MsgOpen, snd");
+      //wait for response
+      from_addr_len = sizeof(from_addr);
+      if((r = recvfrom(sd, &msg, sizeof(msg), 0, 
+		       (struct sockaddr *)&from_addr,
+		       &from_addr_len)) == -1) {
+	perror("MsgOpen, recvfrom");
 	return NULL;
-	
-      } else {
-	if(msgrcv(msqid, (void *)&msg, sizeof(MsgEvent_t),
-		  CLIENT_UNINITIALIZED, 0) == -1) {
-	  perror("MsgOpen, rcv");
-	  return NULL;
-	} else {
-	  ret = (MsgEventQ_t *)malloc(sizeof(MsgEventQ_t));
-	  
-	  ret->msg.type = MsgEventQType_msgq;
-	  ret->msq.msqid = msqid;       // which msq to wait for messages on
-	  memcpy(&initgnt, msg.event_data, sizeof(MsgQInitGntEvent_t));
-	  ret->msg.mtype = initgnt.newclientid; // mtype to wait for
+      }
+      
+      ret = (MsgEventQ_t *)malloc(sizeof(MsgEventQ_t));
 	  
-	}
+      ret->socket.type = MsgEventQType_socket;
+      //ret->socket.server_addr = unix_addr; // resource manager addr
+      ret->socket.server_addr.sun_family = AF_UNIX;
+      snprintf(ret->socket.server_addr.sun_path, 
+	       sizeof(ret->socket.server_addr.sun_path),
+	       "%s", name);
+      
+      memcpy(&initgnt, msg.socket.event_data, sizeof(MsgQInitGntEvent_t));
+      
+      ret->socket.client_addr.sun_family = AF_UNIX;
+      snprintf(ret->socket.client_addr.sun_path, 
+	       sizeof(ret->socket.client_addr.sun_path),
+	       "%s/%d", name,  (int)initgnt.newclientid);
+      ret->socket.clientid = initgnt.newclientid;
+
+
+      if(unlink(tmp_addr.sun_path) == -1) {
+	perror("msgopen, unlink");
+	fprintf(stderr, "'%s'\n", tmp_addr.sun_path);
       }
       
+      close(sd);
+
+      if((sd = socket(PF_UNIX, SOCK_DGRAM, 0)) == -1) {
+	perror("socket");
+	return NULL;
+      }
       
+      if(bind(sd, (struct sockaddr *)&ret->socket.client_addr,
+	      sizeof(ret->socket.client_addr)) == -1) {
+	perror("msgopen bind()");
+	fprintf(stderr, "'%s' %d\n", 
+		ret->socket.client_addr.sun_path,
+		sizeof(ret->socket.client_addr));
+	return NULL;
+      }
+
+      ret->socket.sd = sd;
     }
     break;
   case MsgEventQType_pipe:
@@ -199,6 +301,7 @@
   
   msg.mtype = CLIENT_RESOURCE_MANAGER; // the recipient of this message
   initreq.type = MsgEventQInitReq;   // we want a handle
+  initreq.client = CLIENT_UNINITIALIZED;
   memcpy(msg.event_data, &initreq, sizeof(MsgQInitReqEvent_t));
   
 
@@ -227,7 +330,36 @@
 #endif
 
 
+#ifdef SOCKIPC
+void MsgClose(MsgEventQ_t *q)
+{
+  
+  switch(q->type) {
+#ifdef HAVE_SYSV_MSG
+  case MsgEventQType_msgq:  
+    fprintf(stderr, "msg close FIX\n");
+  
+    // just in case someone tries to access this pointer after close
+    q->msgq.msqid = 0;
+    q->msgq.mtype = 0;
+    break;
+#endif
+  case MsgEventQType_socket:
+    unlink(q->socket.client_addr.sun_path);
+    close(q->socket.sd);
+    memset(&q->socket.server_addr, 0, sizeof(q->socket.server_addr));
+    memset(&q->socket.client_addr, 0, sizeof(q->socket.client_addr));
+    q->socket.sd = 0;
+    break;
+  case MsgEventQType_pipe:
+    fprintf(stderr, "msg close FIX close pipe\n");
+    break;
+  }
 
+  free(q);
+  
+}
+#else
 /**
  * Close the message connection.
  * TODO: tell resource manager that there isn't anyone listening
@@ -246,7 +378,80 @@
   free(q);
   
 }
+#endif
 
+#ifdef SOCKIPC
+static int MsgNextEvent_internal(MsgEventQ_t *q, MsgEvent_t *event_return, int interruptible)
+{
+  msg_t msg;
+ 
+  switch(q->type) {
+#ifdef HAVE_SYSV_MSG
+  case MsgEventQType_msgq:
+    while(1) {
+      if(msgrcv(q->msgq.msqid, (void *)&msg, sizeof(MsgEvent_t),
+		q->msgq.mtype, 0) == -1) {
+	switch(errno) {
+	case EINTR:  // syscall interrupted 
+	  if(!interruptible) {
+	    continue;
+	  }
+	  break;
+	default:
+	  perror("MsgNextEvent");
+	  break;
+	}
+	return -1;
+      } else {
+	
+	memcpy(event_return, msg.msgq.event_data, sizeof(MsgEvent_t));
+	return 0;
+      }
+    }    
+    break;
+#endif
+  case MsgEventQType_socket:
+    while(1) {
+      struct sockaddr_un from_addr;
+      int from_addr_len;
+      int rlen;
+      
+      from_addr_len = sizeof(from_addr);
+      
+      if((rlen = recvfrom(q->socket.sd, (void *)&msg, sizeof(MsgEvent_t), 0,
+			  (struct sockaddr *)&from_addr,
+			  &from_addr_len)) == -1) {
+	switch(errno) {
+	case EINTR:  // syscall interrupted 
+	  if(!interruptible) {
+	    continue;
+	  }
+	  break;
+	default:
+	  perror("MsgNextEvent");
+	  break;
+	}
+	return -1;
+      } else {
+	
+	memcpy(event_return, msg.socket.event_data, rlen);
+
+#ifdef XDEBUG
+	fprintf(stderr, "MsgNextEvent: pid: %d got %s (%d B) from %d\n",
+		getpid(), MsgEventType_str[event_return->any.type],
+		rlen, event_return->any.client);
+#endif
+	return 0;
+      }
+    }    
+    break;
+  case MsgEventQType_pipe:
+    fprintf(stderr, "NOT IMPLEMENTED pipe\n");
+    break;
+  }
+  return -1;
+}
+#else
 static int MsgNextEvent_internal(MsgEventQ_t *q, MsgEvent_t *event_return, int interruptible)
 {
   msg_t msg;
@@ -273,16 +478,24 @@
   }    
 
 }
+#endif
 
 int MsgNextEvent(MsgEventQ_t *q, MsgEvent_t *event_return) {
+#ifdef XDEBUG
+  fprintf(stderr, "MsgNextEvent: pid: %d\n", getpid());
+#endif
   return MsgNextEvent_internal(q, event_return, 0);
 }
 
 int MsgNextEventInterruptible(MsgEventQ_t *q, MsgEvent_t *event_return) {
+#ifdef XDEBUG
+  fprintf(stderr, "MsgNextEventInter: pid: %d\n", getpid());
+#endif
   return MsgNextEvent_internal(q, event_return, 1);
 }
 
 
+#ifndef SOCKIPC
 #if (defined(BSD) && (BSD >= 199306))
 int MsgNextEventNonBlocking(MsgEventQ_t *q, MsgEvent_t *event_return)
 {
@@ -314,11 +527,169 @@
 
 }
 #endif
+#endif
 
 int MsgCheckEvent(MsgEventQ_t *q, MsgEvent_t *event_return)
 {
   msg_t msg;
-  
+#ifdef XDEBUG
+  fprintf(stderr, "MsgCheckEvent: pid: %d\n", getpid());
+#endif
+#ifdef SOCKIPC  
+  switch(q->type) {
+#ifdef HAVE_SYSV_MSG
+  case MsgEventQType_msgq:
+    while (1) {
+      if(msgrcv(q->msgq.msqid, (void *)&msg, sizeof(MsgEvent_t),
+		q->msgq.mtype, IPC_NOWAIT) == -1) {
+	switch(errno) {
+#ifdef ENOMSG
+	case ENOMSG:
+#endif
+	case EAGAIN:
+	  break;
+	case EINTR:     // interrupted by system call/signal, try again
+	  continue;
+	  break;
+	default:
+	  perror("MsgNextEvent");
+	  break;
+	}
+	return -1;
+      } else {
+	
+	memcpy(event_return, msg.msgq.event_data, sizeof(MsgEvent_t));
+	return 0;
+      }
+    }
+    break;
+#endif
+  case MsgEventQType_socket:
+#ifdef HAVE_POLL
+    while (1) {
+      struct sockaddr_un from_addr;
+      int from_addr_len;
+      struct pollfd fds[1];
+      int r;
+      int rlen;
+
+      fds[0].fd = q->socket.sd;
+      fds[0].events = POLLIN;
+      from_addr_len = sizeof(from_addr);
+
+      r = poll(fds, 1, 0);
+      if(r > 0) {
+	if(fds[0].revents & POLLIN) {
+	  if((rlen = recvfrom(q->socket.sd, (void *)&msg,
+			      sizeof(MsgEvent_t), 0,
+			      (struct sockaddr *)&from_addr,
+			      &from_addr_len)) == -1) {
+	    switch(errno) {
+	    case EAGAIN:
+	      break;
+	    case EINTR:     // interrupted by system call/signal, try again
+	      continue;
+	      break;
+	    default:
+	      perror("MsgNextEvent");
+	      break;
+	    }
+	    return -1;
+	  } else {
+	    
+	    memcpy(event_return, msg.socket.event_data, rlen);
+
+#ifdef XDEBUG
+	    fprintf(stderr, "MsgCheckEvent: pid: %d got %s (%d B), from: %d\n",
+		    getpid(), MsgEventType_str[event_return->any.type],
+		    rlen, event_return->any.client);
+#endif
+	    return 0;
+	  }
+	}
+      } else if(r == -1) {
+	switch(errno) {
+	case EAGAIN:
+	case EINTR:
+	  continue;
+	  break;
+	default:
+	  perror("MsgNextEvent, poll");
+	  return -1;
+	  break;
+	}
+      } else {
+	return -1;
+      }
+    }
+#else //HAVE_POLL
+    while (1) {
+      struct sockaddr_un from_addr;
+      int from_addr_len;
+      fd_set rfds;
+      struct timeval tv;
+      int r;
+      int rlen;
+      int nfds;
+
+      FD_ZERO(&rfds);
+      FD_SET(q->socket.sd, &rfds);
+      nfds = q->socket.sd + 1;
+      tv.tv_sec = 0;
+      tv.tv_usec = 0;
+
+      from_addr_len = sizeof(from_addr);
+
+      r = select(nfds, &rfds, NULL, NULL, &tv);
+      if(r > 0) {
+	if(FD_ISSET(q->socket.sd, &rfds)) {
+	  if((rlen = recvfrom(q->socket.sd, (void *)&msg,
+			      sizeof(MsgEvent_t), 0,
+			      (struct sockaddr *)&from_addr,
+			      &from_addr_len)) == -1) {
+	    switch(errno) {
+	    case EAGAIN:
+	      break;
+	    case EINTR:     // interrupted by system call/signal, try again
+	      continue;
+	      break;
+	    default:
+	      perror("MsgNextEvent");
+	      break;
+	    }
+	    return -1;
+	  } else {
+	    
+	    memcpy(event_return, msg.socket.event_data, rlen);
+
+#ifdef XDEBUG
+	    fprintf(stderr, "MsgCheckEvent: pid: %d got %s (%d B), from: %d\n",
+		    getpid(), MsgEventType_str[event_return->any.type],
+		    rlen, event_return->any.client);
+#endif
+	    return 0;
+	  }
+	}
+      } else if(r == -1) {
+	switch(errno) {
+	case EINTR:
+	  continue;
+	  break;
+	default:
+	  perror("MsgNextEvent, select");
+	  return -1;
+	  break;
+	}
+      } else {
+	return -1;
+      }
+    }
+#endif //HAVE_POLL
+    break;
+  case MsgEventQType_pipe:
+    break;
+  }
+#else
   while (1) {
     if(msgrcv(q->msqid, (void *)&msg, sizeof(MsgEvent_t),
 	      q->mtype, IPC_NOWAIT) == -1) {
@@ -342,7 +713,8 @@
       return 0;
     }
   }
-
+#endif
+  return -1;
 }
 
 int MsgSendEvent(MsgEventQ_t *q, MsgEventClient_t client,
@@ -350,9 +722,34 @@
 {
   msg_t msg;
   int size = 0;
+#ifdef SOCKIPC
+  struct sockaddr_un to_addr;
+  int to_addr_len = sizeof(to_addr);
+
+  switch(q->type) {
+#ifdef HAVE_SYSV_MSG
+  case MsgEventQType_msgq:
+    msg.msgq.mtype = client; // the recipient of this message
+    event_send->any.client = q->msgq.mtype; // the sender  
+    break;
+#endif
+  case MsgEventQType_socket:
+    event_send->any.client = q->socket.clientid; // the sender  
+    to_addr.sun_family = AF_UNIX;
+    snprintf(to_addr.sun_path, sizeof(to_addr.sun_path),
+	     "%s/%d", q->socket.server_addr.sun_path, (int)client);
+    break;
+  case MsgEventQType_pipe:
+    fprintf(stderr, "msgsendevent NOT IMP pipe\n");
+    break;
+  }
+#else
   msg.mtype = client; // the recipient of this message
   event_send->any.client = q->mtype; // the sender  
-
+#endif
+#ifdef XDEBUG
+  fprintf(stderr, "MsgSendEvent: pid: %d\n", getpid());
+#endif
   switch(event_send->type) {
   case MsgEventQInitReq:
     size = sizeof(MsgQInitReqEvent_t);
@@ -396,15 +793,24 @@
   case MsgEventQDestroyBuf:
     size = sizeof(MsgQDestroyBufEvent_t);
     break;
-  case MsgEventQCtrlData:
-    size = sizeof(MsgQCtrlDataEvent_t);
-    break;
   case MsgEventQReqPicBuf:
     size = sizeof(MsgQReqPicBufEvent_t);
     break;
   case MsgEventQGntPicBuf:
     size = sizeof(MsgQGntPicBufEvent_t);
     break;
+  case MsgEventQDestroyPicBuf:
+    size = sizeof(MsgQDestroyPicBufEvent_t);
+    break;
+  case MsgEventQCtrlData:
+    size = sizeof(MsgQCtrlDataEvent_t);
+    break;
+  case MsgEventQReqPicQ:
+    size = sizeof(MsgQReqPicQEvent_t);
+    break;
+  case MsgEventQGntPicQ:
+    size = sizeof(MsgQGntPicQEvent_t);
+    break;
   case MsgEventQAttachQ:
   case MsgEventQAppendQ:
     size = sizeof(MsgQAttachQEvent_t);
@@ -420,6 +826,12 @@
   case MsgEventQSPUHighlight:
     size = sizeof(MsgQSPUHighlightEvent_t);
     break;
+  case MsgEventQSPUState:
+    size = sizeof(MsgQSPUStateEvent_t);
+    break;
+  case MsgEventQSetDecodeVideoState:
+    size = sizeof(MsgQDecodeVideoStateEvent_t);
+    break;
   case MsgEventQSpeed:
     size = sizeof(MsgQSpeedEvent_t);
     break;
@@ -441,6 +853,9 @@
   case MsgEventQDemuxStreamChange2:
     size = sizeof(MsgQDemuxStreamChange2Event_t);
     break;
+  case MsgEventQDemuxStreamEnable:
+    size = sizeof(MsgQDemuxStreamEnableEvent_t);
+    break;
   case MsgEventQDemuxDefault:
     size = sizeof(MsgQDemuxDefaultEvent_t);
     break;
@@ -491,20 +906,91 @@
     size = sizeof(MsgQAnyEvent_t) + sizeof(ScreenshotMode_t) + 
       strlen(event_send->savescreenshot.formatstr)+1;
     break;
+  case MsgEventQStop:
+    size = sizeof(MsgQStopEvent_t);
+    break;
   default:
     fprintf(stderr, "MsgSendEvent: Unknown event: %d\n", event_send->type);
     return -1;
   }
 
+#ifdef SOCKIPC
+  switch(q->type) {
+#ifdef HAVE_SYSV_MSG
+  case MsgEventQType_msgq:
+    memcpy(msg.msgq.event_data, event_send, size);
+    break;
+#endif
+  case MsgEventQType_socket:
+    memcpy(msg.socket.event_data, event_send, size);
+
+    break;
+  case MsgEventQType_pipe:
+    break;
+  }
+#else
   memcpy(msg.event_data, event_send, size);
+#endif
 
 #ifdef DEBUG
   fprintf(stderr, "Sending '%s' from: %ld to: %ld\n",
-	  MsgEventType_str[msg.event.type],
-	  msg.event.any.client,
-	  msg.mtype);
+	  MsgEventType_str[event_send->any.type],
+	  event_send->any.client,
+	  client);
 #endif
   
+#ifdef SOCKIPC
+  switch(q->type) {
+#ifdef HAVE_SYSV_MSG
+  case MsgEventQType_msgq:
+    while(1) {
+      if(msgsnd(q->msgq.msqid, (void *)&msg, size, msgflg) == -1) {
+	switch(errno) {
+	case EINTR: //interrupted by syscall/signal, try again
+	  continue;
+	  break;
+	default:
+	  perror("MsgSendEvent: msgsnd");
+	break;
+	}
+	return -1;
+      } else {
+	return 0;
+      }
+    }
+    break;
+#endif
+  case MsgEventQType_socket:
+    while(1) {
+      int rlen;
+      if((rlen = sendto(q->socket.sd, (void *)&msg, size, 0,
+			(struct sockaddr *)&to_addr, to_addr_len)) == -1) {
+	switch(errno) {
+	case EINTR: //interrupted by syscall/signal, try again
+	  continue;
+	  break;
+	default:
+	  perror("MsgSendEvent: sendto");
+	  fprintf(stderr, "'%s'\n", to_addr.sun_path);
+	break;
+	}
+	return -1;
+      } else {
+#ifdef XDEBUG
+	fprintf(stderr, "Sending  %d (%d B) from: %ld to: %ld\n",
+		event_send->any.type,
+		rlen,
+		event_send->any.client,
+		client);
+#endif
+	return 0;
+      }
+    }
+    break;
+  case MsgEventQType_pipe:
+    break;
+  }
+#else
   while(1) {
     if(msgsnd(q->msqid, (void *)&msg, size, msgflg) == -1) {
       switch(errno) {
@@ -512,7 +998,9 @@
 	continue;
 	break;
       default:
-	perror("MsgSendEvent");
+	perror("MsgSendEvent: msgsnd");
+	fprintf(stderr, "msqid: %d, size: %d, mtype %d, msg: %08x\n",
+		q->msqid, size, q->mtype, &msg);
 	break;
       }
       return -1;
@@ -520,10 +1008,32 @@
       return 0;
     }
   }
-  
+#endif  
+  return -1;
 }
 
 
+#ifdef SOCKIPC
+int get_msgqtype(char *msgq_str, MsgEventQType_t *type, char **id)
+{
+
+  if(!strncmp(msgq_str, "socket:", strlen("socket:"))) {
+    *type = MsgEventQType_socket;
+    *id = strdup(&msgq_str[7]);
+#ifdef HAVE_SYSV_MSG
+  } else if(!strncmp(msgq_str, "msg:", strlen("msg:"))) {
+    *type = MsgEventQType_msgq;
+    *id = strdup(&msgq_str[4]);
+#endif
+  } else if(!strncmp(msgq_str, "pipe:", strlen("pipe:"))) {
+
+  } else {
+    return -1;
+  }
+
+  return 0;
+}
+#endif
   
 /*
   
diff -urN -x CVS -x .cvsignore ogle-0.9.2/ogle/msgevents.h ogle/ogle/msgevents.h
--- ogle-0.9.2/ogle/msgevents.h	2003-08-10 23:15:07.000000000 +0200
+++ ogle/ogle/msgevents.h	2006-01-25 17:54:11.000000000 +0100
@@ -2,7 +2,7 @@
 #define MSGEVENTS_H_INCLUDED
 
 /* Ogle - A video player
- * Copyright (C) 2000, 2001 Björn Englund, Håkan Hjort
+ * Copyright (C) 2000, 2001, 2005 Björn Englund, Håkan Hjort
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -19,14 +19,26 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
+#if 1
+#define SOCKIPC
+#else
+#define HAVE_SYSV_MSG
+#endif
+
 #include <limits.h>
 #include <inttypes.h>
 
-#include <ogle/dvd.h>
-#include <ogle/dvdevents.h>
+#include "dvd.h"
+#include "dvdevents.h"
 
 #include <sys/param.h>
 
+#ifdef SOCKIPC
+#include <sys/socket.h>
+#include <sys/un.h>
+#endif
+
+
 #if 0 /* One message queue for every listener */
 
 typedef struct {
@@ -50,6 +62,8 @@
 
 /* more general version */
 
+typedef long int MsgEventClient_t;
+#if 0
 typedef union {
   struct {
     long int mtype;
@@ -64,30 +78,33 @@
     long int type;
     int d;
   } pipe;
-
 } MsgEventClient_t;
+#endif
 
 typedef enum {
+#ifdef HAVE_SYSV_MSG
   MsgEventQType_msgq,
-  MsgEventQType_socket;
-  MsgEventQType_pipe;
+#endif
+  MsgEventQType_socket,
+  MsgEventQType_pipe
 } MsgEventQType_t;
 
 typedef union {
  
+  MsgEventQType_t type;
+#ifdef HAVE_SYSV_MSG  
   struct {
     MsgEventQType_t type;
-  } any;
-  
-  struct {
-    MsgEventQType_t type;
-    msqid;
+    int msqid;
     long int mtype;
   } msgq;
-  
+#endif  
   struct {
     MsgEventQType_t type;
-    int d;
+    long int clientid;
+    struct sockaddr_un server_addr;
+    int sd; /* local socket */
+    struct sockaddr_un client_addr;
   } socket;
   
   struct {
@@ -127,8 +144,8 @@
   MsgEventQReqBuf,
   MsgEventQGntBuf,
   MsgEventQCtrlData,
-  MsgEventQReqPicBuf,
-  MsgEventQGntPicBuf,
+  MsgEventQReqPicQ,
+  MsgEventQGntPicQ,
   MsgEventQAttachQ,
   MsgEventQSPUPalette,
   MsgEventQSPUHighlight,       /* 20 */
@@ -157,7 +174,14 @@
   MsgEventQQDetached,
   MsgEventQDestroyQ,
   MsgEventQDemuxStreamChange2,
-  MsgEventQSaveScreenshot
+  MsgEventQSaveScreenshot,
+  MsgEventQSPUState,
+  MsgEventQReqPicBuf,
+  MsgEventQGntPicBuf,
+  MsgEventQDestroyPicBuf,      /* 50 */
+  MsgEventQDemuxStreamEnable,
+  MsgEventQStop,
+  MsgEventQSetDecodeVideoState
 } MsgEventType_t;
 
 
@@ -181,6 +205,8 @@
   unsigned long mod_mask; /* X modifiers (keys/buttons)*/
   unsigned long input;
   unsigned long time; /* milliseconds */
+  unsigned long input_base;
+  unsigned int input_keycode;
 } MsgQInputEvent_t;
 
 
@@ -255,6 +281,7 @@
   int y_end;
   uint8_t color[4];
   uint8_t contrast[4];
+  int32_t nav_serial;
 } MsgQSPUHighlightEvent_t;
 
 typedef struct {
@@ -264,6 +291,20 @@
   uint32_t colors[16];
 } MsgQSPUPaletteEvent_t;
 
+typedef struct {
+  MsgEventType_t type;
+  MsgEventQ_t *q;
+  MsgEventClient_t client;
+  uint32_t state;
+} MsgQSPUStateEvent_t;
+
+typedef struct {
+  MsgEventType_t type;
+  MsgEventQ_t *q;
+  MsgEventClient_t client;
+  uint32_t state;
+} MsgQDecodeVideoStateEvent_t;
+
 
 typedef struct {
   MsgEventType_t type;
@@ -298,16 +339,38 @@
   MsgEventType_t type;
   MsgEventQ_t *q;
   MsgEventClient_t client;
+  int size;
+} MsgQReqPicBufEvent_t;
+
+typedef struct {
+  MsgEventType_t type;
+  MsgEventQ_t *q;
+  MsgEventClient_t client;
+  int shmid;
+} MsgQDestroyPicBufEvent_t;
+
+typedef struct {
+  MsgEventType_t type;
+  MsgEventQ_t *q;
+  MsgEventClient_t client;
+  int shmid;
+  int size;
+} MsgQGntPicBufEvent_t;
+
+typedef struct {
+  MsgEventType_t type;
+  MsgEventQ_t *q;
+  MsgEventClient_t client;
   int data_buf_shmid;
   int nr_of_elems;
-} MsgQReqPicBufEvent_t;
+} MsgQReqPicQEvent_t;
 
 typedef struct {
   MsgEventType_t type;
   MsgEventQ_t *q;
   MsgEventClient_t client;
   int q_shmid;
-} MsgQGntPicBufEvent_t;
+} MsgQGntPicQEvent_t;
 
 typedef struct {
   MsgEventType_t type;
@@ -361,6 +424,15 @@
   MsgEventClient_t client;
   uint8_t stream_id;
   int subtype;
+  int state; /* 0 - diabled, 1 - enabled */
+} MsgQDemuxStreamEnableEvent_t;
+
+typedef struct {
+  MsgEventType_t type;
+  MsgEventQ_t *q;
+  MsgEventClient_t client;
+  uint8_t stream_id;
+  int subtype;
 } MsgQDemuxStreamEvent_t;
 
 typedef struct {
@@ -385,6 +457,8 @@
   int block_offset;    /* blocks of 2048 bytes from start of title/file */
   int block_count;     /* nr of blocks to demux */
   FlowCtrl_t flowcmd;
+  int32_t serial;
+  int nav_search;      /* find next nav block */
 } MsgQDemuxDVDEvent_t;
 
 typedef struct {
@@ -416,6 +490,7 @@
   MsgEventQ_t *q;
   MsgEventClient_t client;
   int to_scrid;
+  int32_t to_navserial;
 } MsgQFlushDataEvent_t;
 
 typedef struct {
@@ -487,6 +562,13 @@
   MsgEventType_t type;
   MsgEventQ_t *q;
   MsgEventClient_t client;
+  uint32_t state;
+} MsgQStopEvent_t;
+
+typedef struct {
+  MsgEventType_t type;
+  MsgEventQ_t *q;
+  MsgEventClient_t client;
 } MsgQAnyEvent_t;
 
 typedef union {
@@ -506,9 +588,12 @@
   MsgQReqBufEvent_t reqbuf;
   MsgQGntBufEvent_t gntbuf;
   MsgQDestroyBufEvent_t destroybuf;
-  MsgQCtrlDataEvent_t ctrldata;
   MsgQReqPicBufEvent_t reqpicbuf;
   MsgQGntPicBufEvent_t gntpicbuf;
+  MsgQDestroyPicBufEvent_t destroypicbuf;
+  MsgQCtrlDataEvent_t ctrldata;
+  MsgQReqPicQEvent_t reqpicq;
+  MsgQGntPicQEvent_t gntpicq;
   MsgQAttachQEvent_t attachq;
   MsgQDetachQEvent_t detachq;
   MsgQSPUPaletteEvent_t spupalette;
@@ -520,6 +605,7 @@
   MsgQDemuxStreamEvent_t demuxstream;
   MsgQDemuxStreamChangeEvent_t demuxstreamchange;
   MsgQDemuxStreamChange2Event_t demuxstreamchange2;
+  MsgQDemuxStreamEnableEvent_t demuxstreamenable;
   MsgQDemuxDefaultEvent_t demuxdefault;
   MsgQDVDCtrlLongEvent_t dvdctrllong;
   MsgQDemuxDVDEvent_t demuxdvd;
@@ -530,23 +616,50 @@
   MsgQReqInputEvent_t reqinput;
   MsgQInputEvent_t input;
   MsgQSaveScreenshotEvent_t savescreenshot;
+  MsgQSPUStateEvent_t spustate;
+  MsgQStopEvent_t stop;
+  MsgQDecodeVideoStateEvent_t decodevideostate;
 } MsgEvent_t;
 
+#ifdef SOCKIPC
+typedef union {
+#ifdef HAVE_SYSV_MSG
+  struct {
+    long int mtype;
+    char event_data[sizeof(MsgEvent_t)];
+  } msgq;
+#endif  
+  struct{
+    char event_data[sizeof(MsgEvent_t)];
+  } socket;
+
+  struct {
+    char event_data[sizeof(MsgEvent_t)];
+  } pipe;
+} msg_t;
+#else
 typedef struct {
   long int mtype;
   char event_data[sizeof(MsgEvent_t)];
 } msg_t;
+#endif
 
+#ifdef SOCKIPC
+MsgEventQ_t *MsgOpen(MsgEventQType_t type, char *name, int namelen);
+#else
 MsgEventQ_t *MsgOpen(int msqid);
+#endif
 
 void MsgClose(MsgEventQ_t *q);
 
 int MsgNextEvent(MsgEventQ_t *q, MsgEvent_t *event_return);
 int MsgNextEventInterruptible(MsgEventQ_t *q, MsgEvent_t *event_return);
 
+#ifndef SOCKIPC
 #if (defined(BSD) && (BSD >= 199306))
 int MsgNextEventNonBlocking(MsgEventQ_t *q, MsgEvent_t *event_return);
 #endif
+#endif
 
 int MsgCheckEvent(MsgEventQ_t *q, MsgEvent_t *event_return);
 
@@ -579,4 +692,7 @@
 #define USER_INPUT         0x20000
 #define DECODE_LPCM_AUDIO  0x40000
 
+#ifdef SOCKIPC
+int get_msgqtype(char *msgq_str, MsgEventQType_t *type, char **id);
+#endif
 #endif /* MSGEVENTS_H_INCLUDED */
diff -urN -x CVS -x .cvsignore ogle-0.9.2/ogle-alsa.spec ogle/ogle-alsa.spec
--- ogle-0.9.2/ogle-alsa.spec	1970-01-01 01:00:00.000000000 +0100
+++ ogle/ogle-alsa.spec	2003-12-29 17:48:37.000000000 +0100
@@ -0,0 +1,134 @@
+Summary: A DVD player for linux that supports DVD menus.
+Name: ogle
+Version: 0.9.2
+Release: ogle1alsa
+Vendor: Ogle
+Packager: Ogle developer team
+URL: http://www.dtek.chalmers.se/~dvd/
+License: GPL
+Group: Applications/Multimedia
+Source: http://www.dtek.chalmers.se/~dvd/%{name}-%{version}.tar.gz
+BuildRoot: %{_tmppath}/%{name}-root
+Requires: libdvdread >= 0.9.4, libdvdcss, libjpeg, libxml2
+BuildRequires: libdvdread-devel >= 0.9.4, libjpeg-devel, a52dec-devel >= 0.7.3, libxml2-devel >= 2.4.19, libmad
+ExclusiveArch: i686 i586 x86_64 ppc sparc
+
+%description
+Ogle is a DVD player. It's features are: Supports DVD menus and navigation,
+reads encrypted and unencrypted DVDs using libdvdread/libdvdcss, normal X11
+and XFree86 Xvideo display support with subpicture overlay, audio and
+subpicture selection, advanced subpicture commands such as fade/scroll and
+wipe, detects and uses correct aspect for movie and menus, playing AC3/DTS via
+S/PDIF, fullscreen mode, screenshots with and without subpicture overlay...
+
+
+%package devel
+Summary: Header files and static libraries from the Ogle DVD player.
+Group: Development/Libraries
+Requires: %{name} = %{version}-%{release}
+
+%description devel
+These are the header files and static libraries from Ogle that are needed
+to build programs that use it (like GUIs).
+
+%prep
+%setup -q
+
+%build
+%configure --enable-alsa
+make
+
+%install
+test "${RPM_BUILD_ROOT}" != "/" && rm -rf ${RPM_BUILD_ROOT}
+# hack for library dependencies
+LIBRARY_PATH=%{buildroot}/usr/lib/ogle
+export LIBRARY_PATH
+#%makeinstall
+make DESTDIR=%{buildroot} install
+
+%clean
+test "${RPM_BUILD_ROOT}" != "/" && rm -rf ${RPM_BUILD_ROOT}
+
+%post -p /sbin/ldconfig
+
+%postun -p /sbin/ldconfig
+
+%files
+%defattr(-, root, root)
+%doc AUTHORS COPYING README
+%{_bindir}/*
+%dir %{_datadir}/ogle
+%config %{_datadir}/ogle/oglerc
+%{_datadir}/ogle/ogle_conf.dtd
+%dir %{_libdir}/ogle
+%{_libdir}/ogle/*.so.*
+%{_libdir}/ogle/ogle_*
+%{_mandir}/man*/*
+
+%files devel
+%defattr(-, root, root)
+%{_includedir}/*
+%{_libdir}/ogle/*.so
+%{_libdir}/ogle/*.la
+%{_libdir}/ogle/*.a
+
+%changelog
+* Mon Dec 29 2003 Håkan Hjort <d95hjort@dtek.chalmers.se>
+- Include x86_64 and sparc in ExclusiveArch's.
+
+* Thu Nov 6 2003 Björn Englund <d4bjorn@dtek.chalmers.se>
+- Updated version to 0.9.2
+
+* Tue Mar 11 2003 Björn Englund <d4bjorn@dtek.chalmers.se>
+- Updated to version 0.9.1
+
+* Sun Feb 23 2003 Björn Englund <d4bjorn@dtek.chalmers.se>
+- Updated to version 0.9.0, require >= libdvdread-0.9.4
+
+* Wed Aug 14 2002 Martin Norbäck <d95mback@dtek.chalmers.se>
++ ogle-0.8.5-ogle2alsa
+- Use --enable-alsa instead of --disable-alsa...
+
+* Mon Aug 5 2002 Björn Englund <d4bjorn@dtek.chalmers.se>
+- Updated version to 0.8.5
+- Updated the requirements to include libmad
+
+* Sun Jun 30 2002 Björn Englund <d4bjorn@dtek.chalmers.se>
+- Updated version to 0.8.4
+- Updated the requirements
+
+* Sun Jun 9 2002 Björn Englund <d4bjorn@dtek.chalmers.se>
+- Updated version to 0.8.3
+- Updated the requirements
+
+* Thu Feb 21 2002 Martin Norbäck <d95mback@dtek.chalmers.se>
+- Rebuild using a52dec-0.7.3
+
+* Fri Dec 7 2001 Martin Norbäck <d95mback@dtek.chalmers.se>
+- Updated version to 0.8.2
+- Incorporated into cvs
+- Removed ugly hack, it's not correct, the .la-file contains false
+  information
+
+* Sun Nov  4 2001 Matthias Saou <matthias.saou@est.une.marmotte.net>
+- Added an ugly hack to prevent the need to build the package twice to
+  have it work done correctly.
+
+* Wed Oct 31 2001 Matthias Saou <matthias.saou@est.une.marmotte.net>
+- Spec file cleanup and fixes.
+
+* Fri Oct 26 2001 Martin Norbäck <d95mback@dtek.chalmers.se>
+- Updated version to 0.8.1
+* Thu Oct 11 2001 Martin Norbäck <d95mback@dtek.chalmers.se>
+- Updated version to 0.8.0
+* Thu Sep 20 2001 Martin Norbäck <d95mback@dtek.chalmers.se>
+- Added missing .la files
+* Thu Sep 20 2001 Martin Norbäck <d95mback@dtek.chalmers.se>
+- Updated version to 0.7.5
+- Split into normal and devel package
+* Thu Sep 6 2001 Martin Norbäck <d95mback@dtek.chalmers.se>
+- Updated version to 0.7.4
+* Fri Aug 10 2001 Martin Norbäck <d95mback@dtek.chalmers.se>
+- Updated version to 0.7.2
+* Sun Jul 22 2001 Martin Norbäck <d95mback@dtek.chalmers.se>
+- initial version
diff -urN -x CVS -x .cvsignore ogle-0.9.2/ogle.spec ogle/ogle.spec
--- ogle-0.9.2/ogle.spec	1970-01-01 01:00:00.000000000 +0100
+++ ogle/ogle.spec	2003-12-29 17:48:37.000000000 +0100
@@ -0,0 +1,131 @@
+Summary: A DVD player for linux that supports DVD menus.
+Name: ogle
+Version: 0.9.2
+Release: ogle1
+Vendor: Ogle
+Packager: Ogle developer team
+URL: http://www.dtek.chalmers.se/~dvd/
+License: GPL
+Group: Applications/Multimedia
+Source: http://www.dtek.chalmers.se/~dvd/%{name}-%{version}.tar.gz
+BuildRoot: %{_tmppath}/%{name}-root
+Requires: libdvdread >= 0.9.4, libdvdcss, libjpeg, libxml2
+BuildRequires: libdvdread-devel >= 0.9.4, libjpeg-devel, a52dec-devel >= 0.7.3, libxml2-devel >= 2.4.19, libmad
+ExclusiveArch: i686 i586 x86_64 ppc sparc
+
+%description
+Ogle is a DVD player. It's features are: Supports DVD menus and navigation,
+reads encrypted and unencrypted DVDs using libdvdread/libdvdcss, normal X11
+and XFree86 Xvideo display support with subpicture overlay, audio and
+subpicture selection, advanced subpicture commands such as fade/scroll and
+wipe, detects and uses correct aspect for movie and menus, playing AC3/DTS via
+S/PDIF, fullscreen mode, screenshots with and without subpicture overlay...
+
+
+%package devel
+Summary: Header files and static libraries from the Ogle DVD player.
+Group: Development/Libraries
+Requires: %{name} = %{version}-%{release}
+
+%description devel
+These are the header files and static libraries from Ogle that are needed
+to build programs that use it (like GUIs).
+
+%prep
+%setup -q
+
+%build
+%configure --disable-alsa
+make
+
+%install
+test "${RPM_BUILD_ROOT}" != "/" && rm -rf ${RPM_BUILD_ROOT}
+# hack for library dependencies
+LIBRARY_PATH=%{buildroot}/usr/lib/ogle
+export LIBRARY_PATH
+#%makeinstall
+make DESTDIR=%{buildroot} install
+
+%clean
+test "${RPM_BUILD_ROOT}" != "/" && rm -rf ${RPM_BUILD_ROOT}
+
+%post -p /sbin/ldconfig
+
+%postun -p /sbin/ldconfig
+
+%files
+%defattr(-, root, root)
+%doc AUTHORS COPYING README
+%{_bindir}/*
+%dir %{_datadir}/ogle
+%config %{_datadir}/ogle/oglerc
+%{_datadir}/ogle/ogle_conf.dtd
+%dir %{_libdir}/ogle
+%{_libdir}/ogle/*.so.*
+%{_libdir}/ogle/ogle_*
+%{_mandir}/man*/*
+
+%files devel
+%defattr(-, root, root)
+%{_includedir}/*
+%{_libdir}/ogle/*.so
+%{_libdir}/ogle/*.la
+%{_libdir}/ogle/*.a
+
+%changelog
+* Mon Dec 29 2003 Håkan Hjort <d95hjort@dtek.chalmers.se>
+- Include x86_64 and sparc in ExclusiveArch's.
+
+* Thu Nov 6 2003 Björn Englund <d4bjorn@dtek.chalmers.se>
+- Updated version to 0.9.2
+
+* Tue Mar 11 2003 Björn Englund <d4bjorn@dtek.chalmers.se>
+- Updated version to 0.9.1
+
+* Sat Feb 22 2003 Björn Englund <d4bjorn@dtek.chalmers.se>
+- Updated version to 0.9.0
+- Updated the requirements to use >= libdvdread-0.9.4
+
+* Mon Aug 5 2002 Björn Englund <d4bjorn@dtek.chalmers.se>
+- Updated version to 0.8.5
+- Updated the requirements to include libmad
+
+* Sun Jun 30 2002 Björn Englund <d4bjorn@dtek.chalmers.se>
+- Updated version to 0.8.4
+- Updated the requirements
+
+* Sun Jun 9 2002 Björn Englund <d4bjorn@dtek.chalmers.se>
+- Updated version to 0.8.3
+- Updated the requirements
+
+* Thu Feb 21 2002 Martin Norbäck <d95mback@dtek.chalmers.se>
+- Rebuild using a52dec-0.7.3
+
+* Fri Dec 7 2001 Martin Norbäck <d95mback@dtek.chalmers.se>
+- Updated version to 0.8.2
+- Incorporated into cvs
+- Removed ugly hack, it's not correct, the .la-file contains false
+  information
+
+* Sun Nov  4 2001 Matthias Saou <matthias.saou@est.une.marmotte.net>
+- Added an ugly hack to prevent the need to build the package twice to
+  have it work done correctly.
+
+* Wed Oct 31 2001 Matthias Saou <matthias.saou@est.une.marmotte.net>
+- Spec file cleanup and fixes.
+
+* Fri Oct 26 2001 Martin Norbäck <d95mback@dtek.chalmers.se>
+- Updated version to 0.8.1
+* Thu Oct 11 2001 Martin Norbäck <d95mback@dtek.chalmers.se>
+- Updated version to 0.8.0
+* Thu Sep 20 2001 Martin Norbäck <d95mback@dtek.chalmers.se>
+- Added missing .la files
+* Thu Sep 20 2001 Martin Norbäck <d95mback@dtek.chalmers.se>
+- Updated version to 0.7.5
+- Split into normal and devel package
+* Thu Sep 6 2001 Martin Norbäck <d95mback@dtek.chalmers.se>
+- Updated version to 0.7.4
+* Fri Aug 10 2001 Martin Norbäck <d95mback@dtek.chalmers.se>
+- Updated version to 0.7.2
+* Sun Jul 22 2001 Martin Norbäck <d95mback@dtek.chalmers.se>
+- initial version
diff -urN -x CVS -x .cvsignore ogle-0.9.2/oglerc.in ogle/oglerc.in
--- ogle-0.9.2/oglerc.in	2003-09-19 09:47:38.000000000 +0200
+++ ogle/oglerc.in	2005-08-23 01:17:41.000000000 +0200
@@ -106,6 +106,12 @@
   	</b>
 	<b>	
 	  <action>Stop</action>
+<!--
+	  <key>
+	   <keysym>space</keysym>
+	   <modifier>Shift</modifier>
+ 	  </key>
+-->
   	</b>
 	<b>	
 	  <action>Faster</action>
@@ -177,6 +181,10 @@
 	  <key>s</key>
   	</b>
 	<b>	
+	  <action>VideoToggle</action>
+	  <key>v</key>
+  	</b>
+	<b>	
 	  <action>FullScreenToggle</action>
 	  <key>f</key>
 	  <key>F</key>
@@ -266,6 +274,15 @@
 	  <action>SaveScreenshotWithSPU</action>
 	  <key>I</key>
   	</b>
+	<b>	
+	  <action>AudioStreamChange</action>
+	  <key>z</key>
+  	</b>
+	<b>	
+	  <action>SubtitleStreamChange</action>
+	  <key>x</key>
+  	</b>
+	
     </bindings>
   </user_interface>
 </ogle_conf>
diff -urN -x CVS -x .cvsignore ogle-0.9.2/release_howto ogle/release_howto
--- ogle-0.9.2/release_howto	1970-01-01 01:00:00.000000000 +0100
+++ ogle/release_howto	2003-11-06 00:04:13.000000000 +0100
@@ -0,0 +1,58 @@
+
+
+1.  Check out a clean source tree from CVS
+
+2.  ./autogen.sh
+    ./configure ...
+    Do 'make dist' and
+    make sure the resulting tar.gz compiles and runs (on all platforms).
+
+3.  Update libtool versioning info in ogle/Makefile.am if changes
+    have been made to libdvdcontrol / libmsgevents.
+    Commit changes,
+
+4.  Update ogle version in configure.in
+    Commit changes
+
+5.  Do 'make dist'
+    Make sure the dist compiles and runs.
+
+6.  Make rpms
+
+6.1 update the version number (and package description)
+    and change log
+    in ogle.spec, ogle-alsa.spec
+
+6.2 chroot to your build environment if neccesary
+
+6.3 Copy the spec files to /usr/src/redhat/SPECS
+
+6.4 Copy the ogle-x.x.x.tar.gz to /usr/src/redhat/SOURCES
+
+6.6 Change the hostname if you don't want it set in the package information
+    with 'hostname <name>'
+
+6.6 rpmbuild -ba --target i586 ogle.spec
+    rpmbuild -ba --target i586 ogle-alsa.spec
+
+6.7 Change back your hostname
+
+6.8 Make sure the rpms can be installed and run.
+
+6.9 Copy the rpms in /usr/src/redhat/RPMS/i586 and /usr/src/redhat/SRPMS
+    to the web server.
+
+7.  Copy ogle-X.X.X.tar.gz to the web server.
+
+8.  Update the web (download links, news, features)
+    Make sure you can download everything (permissions/...)
+
+9.  Announce on ogle-user, ogle-devel mailinglists
+    Announce on freshmeat/...
+
+10. Tag all files in cvs with the release
+    'cvs tag ogle-X_X_X .'
+
+11. ???
+
+12. Profit.
diff -urN -x CVS -x .cvsignore ogle-0.9.2/scripts/ogle.in ogle/scripts/ogle.in
--- ogle-0.9.2/scripts/ogle.in	2003-10-05 23:46:04.000000000 +0200
+++ ogle/scripts/ogle.in	2005-10-02 02:21:11.000000000 +0200
@@ -1,18 +1,6 @@
 #!/bin/sh
 # @configure_input@
 
-create_pipe() { 
-    if [ ! -p $1 ]; then
-	rm -f $1;
-        # So any other user can start the program / rm the pipes
-        mkfifo $1; chmod 666 $1;
-    fi
-    # chgrp dvd $1;
-}
-
-create_pipe "/tmp/ac3"
-create_pipe "/tmp/audio"
-
 ostype=`uname`
 d_suf="_debug"
 debug="0"
@@ -28,54 +16,73 @@
 check="0"
 param=""
 
+
+while [ $# -gt 0 ]
+  do
+  case "$1" in
+      --debug)
+          debug="1"
+	  if [ -z "$OGLE_DLEVEL" ]; then
+	      OGLE_DLEVEL=5
+	  fi
+          DVDCSS_VERBOSE=2
+          export DVDCSS_VERBOSE
+	  DVDREAD_VERBOSE=2
+	  export DVDREAD_VERBOSE
+          ;;
+      --check)
+          debug="1"
+          check="1"
+          ;;
+      --debug-*)
+          case "$1" in
+              --debug-nav)
+                  nav_debug=$d_suf
+                  ;;
+              --debug-audio)
+                  audio_debug=$d_suf
+                  ;;
+              --debug-vout)
+                  vout_debug=$d_suf
+                  ;;
+              --debug-cli)
+                  cli_debug=$d_suf
+                  ;;
+              --debug-ctrl)
+                  ctrl_debug=$d_suf
+                  ;;
+              --debug-gui)
+                  gui_debug=$d_suf
+                  ;;
+              --debug-mpeg_ps)
+                  mpeg_ps_debug=$d_suf
+                  ;;
+              --debug-mpeg_vs)
+                  mpeg_vs_debug=$d_suf
+                  ;;
+              --debug-all)
+                  nav_debug=$d_suf
+                  audio_debug=$d_suf
+                  vout_debug=$d_suf
+                  cli_debug=$d_suf
+                  ctrl_debug=$d_suf
+                  gui_debug=$d_suf
+                  mpeg_ps_debug=$d_suf
+                  mpeg_vs_debug=$d_suf
+                  ;;
+          esac
+          ;;
+      *)
+          break
+          ;;
+  esac
+  shift
+done
+
 if [ -z "$OGLE_DLEVEL" ]; then
     OGLE_DLEVEL=3
 fi
 
-for p in $*; do
-    if [ $p = "--debug" ]; then
-	debug="1"
-        OGLE_DLEVEL=5
-	DVDCSS_VERBOSE=2
-	export DVDCSS_VERBOSE
-    elif [ $p = "--check" ]; then
-	debug="1"
-	check="1"
-    elif [ x`echo $p | grep -- "--debug-"` != x"" ]; then
-	if [ $p = --debug-nav ]; then
-	    nav_debug=$d_suf
-	elif [ $p = --debug-audio ]; then
-	    audio_debug=$d_suf
-	elif [ $p = --debug-vout ]; then
-	    vout_debug=$d_suf
-	elif [ $p = --debug-cli ]; then
-	    cli_debug=$d_suf
-	elif [ $p = --debug-ctrl ]; then
-	    ctrl_debug=$d_suf
-	elif [ $p = --debug-gui ]; then
-	    gui_debug=$d_suf
-	elif [ $p = --debug-mpeg_ps ]; then
-	    mpeg_ps_debug=$d_suf
-	elif [ $p = --debug-mpeg_vs ]; then
-	    mpeg_vs_debug=$d_suf
-	elif [ $p = --debug-all ]; then
-	    nav_debug=$d_suf
-	    audio_debug=$d_suf
-	    vout_debug=$d_suf
-	    cli_debug=$d_suf
-	    ctrl_debug=$d_suf
-	    gui_debug=$d_suf
-	    mpeg_ps_debug=$d_suf
-	    mpeg_vs_debug=$d_suf
-	else
-	    echo "$0: invalid option $p"
-	    exit
-	fi
-    else
-	param="$param $p"
-    fi
-done
-
 export OGLE_DLEVEL
 
 
@@ -86,6 +93,8 @@
  runtime="Runtime: `uname -m -r -s -v`"
  runtime="${runtime} `uname -p 2> /dev/null`"
  echo "$runtime"
+ # gcc options used at compile time
+ echo "@GCCINFO@"
 
  case $ostype in
      "Linux")
@@ -342,20 +351,31 @@
 export DVDP_LPCM
 DVDP_MPEGAUDIO=$DVDP_ROOT/ogle_audio$audio_debug
 export DVDP_MPEGAUDIO
-DVDP_DTSAUDIO=$DVDP_ROOT/ogle_audio$audio_debug
-export DVDP_DTSAUDIO
+DVDP_DTS=$DVDP_ROOT/ogle_audio$audio_debug
+export DVDP_DTS
 DVDP_VIDEO=$DVDP_ROOT/ogle_mpeg_vs$mpeg_vs_debug
 export DVDP_VIDEO
 DVDP_VMG=$DVDP_ROOT/ogle_nav$nav_debug
 #DVDP_VMG=RUNNING
 export DVDP_VMG
-#DVDP_SPU=$DVDP_ROOT/subpicture/spu_wrap
+if [ -z "$DVDP_SPU" -o ! -x "$DVDP_SPU" ]; then
+if [ -x $DVDP_ROOT/ogle_vout$vout_debug ]; then
 DVDP_SPU=$DVDP_ROOT/ogle_vout$vout_debug
+else
+DVDP_SPU=$exec_prefix/bin/ogle_vout$vout_debug
+fi
+fi
 export DVDP_SPU
+if [ -z "$DVDP_VIDEO_OUT" -o ! -x "$DVDP_VIDEO_OUT" ]; then
+if [ -x $DVDP_ROOT/ogle_vout$vout_debug ]; then
 DVDP_VIDEO_OUT=$DVDP_ROOT/ogle_vout$vout_debug
+else
+DVDP_VIDEO_OUT=$exec_prefix/bin/ogle_vout$vout_debug
+fi
+fi
 export DVDP_VIDEO_OUT
 if [ -x "$DVDP_UI" ]; then
-  $DVDP_CTRL -u gui $param;
+  $DVDP_CTRL -u gui "$@";
 else
-  $DVDP_CTRL -u cli $param;
+  $DVDP_CTRL -u cli "$@";
 fi;
diff -urN -x CVS -x .cvsignore ogle-0.9.2/subpicture/COPYING ogle/subpicture/COPYING
--- ogle-0.9.2/subpicture/COPYING	1970-01-01 01:00:00.000000000 +0100
+++ ogle/subpicture/COPYING	2000-02-29 03:34:25.000000000 +0100
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year  name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
diff -urN -x CVS -x .cvsignore ogle-0.9.2/subpicture/Makefile.am ogle/subpicture/Makefile.am
--- ogle-0.9.2/subpicture/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ ogle/subpicture/Makefile.am	2003-10-14 03:05:15.000000000 +0200
@@ -0,0 +1,25 @@
+# Ogle - A video player
+# Copyright (C) 2000, 2001 Björn Englund, Håkan Hjort, Martin Norbäck
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+pkglib_PROGRAMS = spu_wrap
+
+AM_CPPFLAGS = @TOP_INCLUDES@
+AM_CFLAGS = @O_CFLAGS@
+
+spu_wrap_SOURCES = spu_wrap.c
+spu_wrap_LDADD = $(top_builddir)/common/libcommon.a \
+	$(top_builddir)/common/libdvdcontrol.a 
diff -urN -x CVS -x .cvsignore ogle-0.9.2/subpicture/NOTES ogle/subpicture/NOTES
--- ogle-0.9.2/subpicture/NOTES	1970-01-01 01:00:00.000000000 +0100
+++ ogle/subpicture/NOTES	2000-02-29 03:34:26.000000000 +0100
@@ -0,0 +1,324 @@
+
+          DVD subtitles
+         ---------------
+
+
+  0. Introduction
+  1. Basics
+  2. The data structure
+  3. Reading the control header
+  4. Decoding the graphics
+  5. What I do not know yet / What I need
+  6. Thanks
+  7. Changes
+
+
+
+
+
+The latest version of this document can be found here:
+http://www.via.ecp.fr/~sam/doc/dvd/
+
+
+
+
+
+0. Introduction
+
+  One of the last things we missed in DVD decoding under my system was the
+decoding of subtitles. I found no information on the web or Usenet about them,
+apart from a few words on them being run-length encoded in the DVD FAQ.
+
+  So we decided to reverse-engineer their format (it's completely legal in
+France, since we did it on interoperability purposes), and managed to get
+almost all of it.
+
+
+
+
+
+1. Basics
+
+  DVD subtitles are hidden in private PS packets (0x000001ba), just like AC3
+streams are.
+
+  Within the PS packet, there are PES packets, and like AC3, the header for the
+ones containing subtitles have a 0x000001bd header.
+  As for AC3, where there's an ID like (0x80 + x), there's a subtitle ID equal
+to (0x20 + x), where x is the subtitle ID. Thus there seems to be only
+16 possible different subtitles on a DVD (my Taxi Driver copy has 16).
+
+  I'll suppose you know how to extract AC3 from a DVD, and jump to the
+interesting part of this documentation. Anyway you're unlikely to have
+understood what I said without already being familiar with MPEG2.
+
+
+
+
+
+2. The data structure
+
+A subtitle packet, after its parts have been collected and appended, looks
+like this :
+
+   +----------------------------------------------------------+    
+   |                                                          |
+   |   0    2                                         size    |
+   |   +----+------------------------+-----------------+      |
+   |   |size|       data packet      |     control     |      |
+   |   +----+------------------------+-----------------+      |
+   |                                                          |
+   |                     a subtitle packet                    |
+   |                                                          |
+   +----------------------------------------------------------+    
+
+size is a 2 bytes word, and data packet and control may have any size.
+
+
+Here is the structure of the data packet :
+
+   +----------------------------------------------------------+    
+   |                                                          |
+   |   2    4                                        S0+2     |
+   |   +----+------------------------------------------+      |
+   |   | S0 |                  data                    |      |
+   |   +----+------------------------------------------+      |
+   |                                                          |
+   |                      the data packet                     |
+   |                                                          |
+   +----------------------------------------------------------+    
+
+S0, the data packet size, is a 2 bytes word.
+
+
+Finally, here's the structure of the control packet :
+
+   +----------------------------------------------------------+    
+   |                                                          |
+   | S0+2  S0+4                                 S1       size |
+   |   +----+---------+---------+--+---------+--+---------+   |
+   |   | S1 |ctrl seq |ctrl seq |..|ctrl seq |ff| end seq |   |
+   |   +----+---------+---------+--+---------+--+---------+   |
+   |                                                          |
+   |                     the control packet                   |
+   |                                                          |
+   +----------------------------------------------------------+    
+
+To summarize :
+
+ - S1, at offset S0+2, the position of the end sequence
+ - several control sequences
+ - the 'ff' byte
+ - the end sequence
+
+
+
+
+
+3. Reading the control header
+
+The first thing to read is the control sequences. There are several
+types of them, and each type is determined by its first byte. As far
+as I know, each type has a fixed length.
+
+ * type 0x01 : '01' - 1 byte
+  it seems to be an empty control sequence.
+
+ * type 0x03 : '03wxyz' - 3 bytes
+  this one has the palette information ; it basically says 'encoded color 0
+ is the wth color of the palette, encoded color 1 is the xth color, aso.
+
+ * type 0x04 : '04wxyz' - 3 bytes
+  I *think* this is the alpha channel information ; I only saw values of 0 or f
+ for those nibbles, so I can't really be sure, but it seems plausable.
+
+ * type 0x05 : '05xxxXXXyyyYYY' - 7 bytes
+  the coordinates of the subtitle on the screen :
+   xxx is the first column of the subtitle
+   XXX is the last column of the subtitle
+   yyy is the first line of the subtitle
+   YYY is the last line of the subtitle
+  thus the subtitle's size is (XXX-xxx+1) x (YYY-yyy+1)
+
+ * type 0x06 : '06xxxxyyyy' - 5 bytes
+  xxxx is the position of the first graphic line, and yyyy is the position of
+ the second one (the graphics are interlaced, so it helps a lot :p)
+
+The end sequence has this structure:
+
+ xxxx yyyy 02 ff (ff)
+
+ it ends with 'ff' or 'ffff', to make the whole packet have an even length.
+
+FIXME: I absolutely don't know what xxxx is. I suppose it may be some date
+information since I found it nowhere else, but I can't be sure.
+
+ yyyy is equal to S1 (see picture).
+
+
+Example of a control header :
+----
+0A 0C 01 03 02 31 04 0F F0 05 00 02 CF 00 22 3E 06 00 06 04 E9 FF 00 93 0A 0C 02 FF
+----
+Let's decode it. First of all, S1 = 0x0a0c.
+
+The control sequences are :
+ 01
+   Nothing to say about this one
+ 03 02 31
+   Color 0 is 0, color 1 is 2, color 2 is 3, and color 3 is 1.
+ 04 0F F0
+   Colors 0 and 3 are transparent, and colors 2 and 3 are opaque (not sure of this one)
+ 05 00 02 CF 00 22 3E
+   The first column is 0x000, the last one is 0x2cf, the first line is 0x002, and
+   the last line is 0x23e. Thus the subtitle's size is 0x2d0 x 0x23d.
+ 06 00 06 04 E9
+   The first encoded image starts at offset 0x006, and the second one starts at 0x04e9.
+
+And the end sequence is :
+  00 93 0A 0C 02 FF
+   Which means... well, not many things now. We can at least verify that S1 (0x0a0c) is
+   there.
+
+
+
+
+
+4. Decoding the graphics
+
+   The graphics are rather easy to decode (at least, when you know how to do it - it
+  took us one whole week to figure out what the encoding was :p).
+
+   The picture is interlaced, for instance for a 40 lines picture :
+
+  line 0  ---------------#----------
+  line 2  ------#-------------------
+   ...
+  line 38 ------------#-------------
+  line 1  ------------------#-------
+  line 3  --------#-----------------
+   ...
+  line 39 -------------#------------
+
+   When decoding you should get:
+
+  line 0  ---------------#----------
+  line 1  ------------------#-------
+  line 2  ------#-------------------
+  line 3  --------#-----------------
+   ...
+  line 38 ------------#-------------
+  line 39 -------------#------------
+
+   Computers with weak processors could choose only to decode even lines
+  in order to gain some time, for instance.
+
+
+   The encoding is run-length encoded, with the following alphabet:
+
+   0xf
+   0xe
+   0xd
+   0xc
+   0xb
+   0xa
+   0x9
+   0x8
+   0x7
+   0x6
+   0x5
+   0x4
+   0x3-
+   0x2-
+   0x1-
+   0x0f-
+   0x0e-
+   0x0d-
+   0x0c-
+   0x0b-
+   0x0a-
+   0x09-
+   0x08-
+   0x07-
+   0x06-
+   0x05-
+   0x04-
+   0x03--
+   0x02--
+   0x01--
+   0x0000
+
+   '-' stands for any other nibble. Once a sequence X of this alphabet has
+  been read, the pixels can be displayed : (X >> 2) is the number of pixels
+  to display, and (X & 0x3) is the color of the pixel.
+
+   For instance, 0x23 means "8 pixels of color 3".
+
+   "0000" has a special meaning : it's a carriage return. The decoder should
+  do a carriage return when reaching the end of the line, or when encountering
+  this "0000" sequence. When doing a carriage return, the parser should be
+  reset to the next even position (it cannot be nibble-aligned at the start
+  of a line).
+
+   After a carriage return, the parser should read a line on the other
+  interlaced picture, and swap like this after each carriage return.
+
+   Perhaps I don't explain this very well, so you'd better have a look at
+  the enclosed source.
+
+
+
+
+
+5. What I do not know yet / What I need
+
+I don't know what's in the end sequence yet.
+
+Also, I don't know exactly when to display subtitles, and when to remove them.
+
+I don't know if there are other types of control sequences (in my programs I consider
+0xff as a control sequence type, as well as 0x02. I don't know if it's correct or not,
+so please comment on this).
+
+I don't know what the "official" color palette is.
+
+I don't know how to handle transparency information.
+
+I don't know if this document is generic enough.
+
+So what I need is you :
+
+ - if you can, patch this document or my programs to fix strange behaviour with your subtitles.
+
+ - send me your subtitles (there's a program to extract them enclosed) ; the first 10 KB
+  of subtitles in a VOB should be enough, but it would be cool if you sent me one subtitle
+  file per language.
+
+
+
+
+
+6. Thanks
+
+ Thanks to Michel Lespinasse <walken@via.ecp.fr> for his great help on understanding
+the RLE stuff, and for all the ideas he had.
+
+ Thanks to mass (David Waite) and taaz (David I. Lehn) from irc at
+openprojects.net for sending me their subtitles.
+
+
+
+
+
+7. Changes
+
+ 20000116: added the 'changes' section.
+ 20000116: added David Waite's and David I. Lehn's name.
+ 20000116: changed "x0" and "x1" to "S0" and "S1" to make it less confusing.
+
+
+
+
+-- 
+Paris, January 16th 2000
+Samuel Hocevar <sam@via.ecp.fr>
diff -urN -x CVS -x .cvsignore ogle-0.9.2/subpicture/README ogle/subpicture/README
--- ogle-0.9.2/subpicture/README	1970-01-01 01:00:00.000000000 +0100
+++ ogle/subpicture/README	2000-02-29 03:34:25.000000000 +0100
@@ -0,0 +1,53 @@
+DVD subtitles tools - by Samuel Hocevar <sam@via.ecp.fr>
+
+
+
+* extract_subtitles.c
+
+This program extracts valid subtitles from a .VOB file. The syntax
+basically is:
+
+ cat /mnt/dvd/VIDEO_TS/SOME_VOB | ./extract_subtitles 0 > subtitle0.raw
+
+The argument is the subtitle stream ID, it seems to go from 0 to 15.
+
+If your DVD is encrypted, you should use `css-cat -a' instead of `cat'.
+
+If you are planning to implement subtitle decoding in your DVD player,
+note that subtitles seem to be encapsulated in private PS data just like
+AC3 streams are. If you do not have an idea about PS or AC3, then you
+probably don't even want to use these programs.
+
+
+
+* subt2xpm.f
+
+This is just a sample Fortran program I did to learn Fortran and mess
+a bit with file i/o ... it does not have the flexibility of the next
+one, but it somewhat works, for the Leon and the Dune examples at
+least. Its purpose is to create a .xpm from the subtitle stream.
+
+Usage: ./subt2xpm infile.raw outfile.xpm
+
+
+
+* subt2xpm.c
+
+This is the most useful program ; it reads a subtitle and writes it to
+an XPM image ; there should be no problem using the same algorithm in
+a DVD player (actually I did it).
+
+Usage: ./subt2xpm infile.raw > outfile.xpm
+
+
+
+* sample_dune.raw
+* sample_leon.raw
+* sample_bladerunner.raw
+
+Those are sample files to test subt2xpm.
+
+
+Have fun,
+-- 
+Sam.
diff -urN -x CVS -x .cvsignore ogle-0.9.2/subpicture/TODO ogle/subpicture/TODO
--- ogle-0.9.2/subpicture/TODO	1970-01-01 01:00:00.000000000 +0100
+++ ogle/subpicture/TODO	2000-02-29 03:34:26.000000000 +0100
@@ -0,0 +1,5 @@
+
+* find out what the palette is
+
+* find out what the remaining bytes in the control field are.
+
diff -urN -x CVS -x .cvsignore ogle-0.9.2/subpicture/spu_decode.c ogle/subpicture/spu_decode.c
--- ogle-0.9.2/subpicture/spu_decode.c	1970-01-01 01:00:00.000000000 +0100
+++ ogle/subpicture/spu_decode.c	2001-02-24 17:24:45.000000000 +0100
@@ -0,0 +1,606 @@
+
+//#define DEBUG
+
+
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <inttypes.h>
+#include <assert.h>
+#include <stdio.h>
+#include <errno.h>
+#include <malloc.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+#include <fcntl.h>
+#include <string.h>
+#include <unistd.h>
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+#include <X11/extensions/shape.h>
+
+
+struct timeval tp1, tp2, tp3;
+
+int fd;
+int aligned;
+uint16_t fieldoffset[2];
+uint16_t field=0;
+
+uint8_t color[4];
+uint8_t contrast[4];
+uint8_t* buffer;
+
+
+
+uint16_t spu_size;
+
+		
+
+#ifdef DEBUG
+int debug;
+#endif
+
+#ifdef DEBUG
+#define DPRINTF(level, text...) \
+if(debug > level) \
+{ \
+    fprintf(stderr, ## text); \
+}
+#else
+#define DPRINTF(level, text...)
+#endif
+
+#ifdef DEBUG
+#define DPRINTBITS(level, bits, value) \
+{ \
+  int n; \
+  for(n = 0; n < bits; n++) { \
+    DPRINTF(level, "%u", (value>>(bits-n-1)) & 0x1); \
+  } \
+}
+#else
+#define DPRINTBITS(level, bits, value)
+#endif
+
+#ifdef DEBUG
+#define GETBYTES(a,b) getbytes(a,b)
+#else
+#define GETBYTES(a,b) getbytes(a)
+#endif
+
+static uint8_t *byte_pos;
+
+static inline void set_byte (uint8_t *byte) {
+  byte_pos = byte;
+  aligned = 1;
+}
+
+#ifdef DEBUG
+uint32_t getbytes(unsigned int num, char *func)
+#else
+static inline uint32_t getbytes(unsigned int num)
+#endif
+{
+#ifdef DEBUG
+  int tmpnum = num;
+#endif
+  uint32_t result = 0;
+
+  assert(num <= 4);
+
+  while(num > 0) {
+    result <<= 8;
+    result |= *byte_pos;
+    byte_pos++;
+    num--;
+  }
+
+  DPRINTF(5, "\n%s getbytes(%u): %i, 0x%0*x, ", 
+          func, tmpnum, result, tmpnum*2, result);
+  DPRINTBITS(5, tmpnum*8, result);
+  DPRINTF(5, "\n");
+  return result;
+}
+
+static inline uint8_t get_nibble (void)
+{
+  static uint8_t next = 0;
+  if (aligned) {
+    fieldoffset[field]++;
+    next = GETBYTES(1, "get_nibble (aligned)");
+    aligned = 0;
+    return next >> 4;
+  } else {
+    aligned = 1;
+    return next & 0xf;
+  }
+}
+
+
+
+
+char *program_name;
+
+
+
+
+
+int get_data(uint8_t *databuf, int bufsize)
+{
+  int r;
+  int spu_size;
+  int bytes_to_read;
+  
+  if(bufsize < 2) {
+    // databuf not big enough
+    fprintf(stderr, "buffer too small\n");
+    return -1;
+  }
+ 
+
+  // get first 2 bytes of spu (size of spu)
+  bytes_to_read = 2;
+  while(bytes_to_read > 0) {
+    r = read(fd, &databuf[2-bytes_to_read], bytes_to_read);
+    
+    if(r > 0) {
+      bytes_to_read -= r;
+    } else if(r < 0) {
+      perror("read");
+      return -1;
+    } else if(r == 0) {
+      fprintf(stderr, "EOF, %d bytes read\n", 2-bytes_to_read);
+      return 0;
+    }
+  }
+  
+  spu_size = (databuf[0]<<8) | databuf[1];
+  
+  if(spu_size > bufsize) {
+    // databuf not big enough
+    fprintf(stderr, "buffer too small\n");
+    return -1;
+  }
+  
+  // already read the first two bytes
+  bytes_to_read = spu_size - 2;
+  
+  // get the rest of the spu
+  while(bytes_to_read > 0) {
+    r = read(fd, &databuf[spu_size-bytes_to_read], bytes_to_read);
+    
+    if(r > 0) {
+      bytes_to_read -= r;
+    } else if(r < 0) {
+      perror("read");
+      return -1;
+    } else  {
+      fprintf(stderr, "premature EOF, %d of %d bytes read\n",
+	      spu_size-bytes_to_read, spu_size);
+      return 0;
+    }   
+  }
+
+  return spu_size;
+  
+}
+
+
+typedef struct {
+  int start_time;
+  int stop_time;
+  int width;
+  int height;
+  int x_start;
+  int x_end;
+  int y_start;
+  int y_end;
+  int display_start;
+  int display_end;
+  int menu;
+  uint8_t color[4];
+  uint8_t contrast[4];
+} spu_t;
+
+char *get_spu_buffer(int size)
+{
+  return malloc(sizeof(spu_t)+size);
+}
+
+  
+
+
+#define MAX_BUF_SIZE 65536
+
+void usage()
+{
+#ifdef DEBUG
+  fprintf(stderr, "Usage: %s [-d <level>] <infile>\n", program_name);
+#else
+  fprintf(stderr, "Usage: %s <infile>\n", program_name);
+#endif
+}
+
+
+
+int main (int argc, char *argv[]) {
+  uint32_t dummy;
+  int c;
+  uint8_t command;
+  uint16_t DCSQT_offset;
+  int next_DCSQ_offset;
+  unsigned int x;
+  unsigned int y;
+  int nr_vlc;
+  unsigned char *shm_buffer;
+  int shm_buf_pos = 0;
+  program_name = argv[0];
+
+  /* Parse command line options */
+#ifdef DEBUG
+  while ((c = getopt(argc, argv, "d:h?")) != EOF) {
+#else
+  while ((c = getopt(argc, argv, "h?")) != EOF) {
+#endif
+      
+    switch (c) {
+#ifdef DEBUG
+    case 'd':
+      debug = atoi(optarg);
+      break;
+#endif
+    case 'h':
+    case '?':
+      usage();
+      return 1;
+    }
+  }
+  
+  if(argc - optind != 1){
+    usage();
+    return 1;
+  }
+  
+  
+  fd = open (argv[optind], 0);
+  if(fd < 0) {
+    fprintf(stderr,"file not found\n");
+    exit(1);
+  }
+  
+  buffer = malloc(MAX_BUF_SIZE);
+  shm_buffer = malloc(65536*2);
+
+  while(1) {
+
+    int debug_multiple_start = 0;
+    spu_t spu_info = { 0 };
+    char *spu = NULL;
+    unsigned char *spu_data = NULL;
+    
+    gettimeofday(&tp1, NULL);
+    
+    if(get_data(buffer, MAX_BUF_SIZE) <= 0) {
+      fprintf(stderr, "Couldn't get spu\n");
+      exit(-1);
+    }
+    
+    // init start position
+    set_byte(buffer);
+    
+    spu_size = GETBYTES(2, "spu_size");
+    DPRINTF(3, "SPU size: 0x%04x\n", spu_size);
+    
+    DCSQT_offset = GETBYTES(2, "DCSQT_offset");
+    DPRINTF(3, "DCSQT offset: 0x%04x\n", DCSQT_offset);
+    
+    DPRINTF(3, "Display Control Sequence Table:\n");
+    
+    /* parse the DCSQT */
+    set_byte(buffer+DCSQT_offset);
+    
+    next_DCSQ_offset = DCSQT_offset;
+    
+    while(1) {
+      /* DCSQ */
+      int start_time;
+      int last_DCSQ = 0;
+      DPRINTF(3, "\tDisplay Control Sequence:\n");
+      
+      start_time = GETBYTES(2, "start_time");
+      DPRINTF(3, "\t\tStart time: 0x%04x\n", start_time);
+      last_DCSQ = next_DCSQ_offset;
+      next_DCSQ_offset = GETBYTES(2, "next_DCSQ_offset");
+      DPRINTF(3, "\t\tNext DCSQ offset: 0x%04x\n", next_DCSQ_offset);
+      
+      DPRINTF(3, "\t\tCommand Sequence Start:\n");
+      
+      while((command = GETBYTES(1, "command")) != 0xff) {
+	/* Command Sequence */
+	
+	DPRINTF(3, "\t\t\tDisplay Control Command: 0x%02x\n", command);
+	
+	switch (command) {
+	case 0x00: /* Menu */
+	  DPRINTF(3, "\t\t\t\tMenu...\n");
+	  spu_info.menu = 1;
+	  break;
+	case 0x01: /* display start */
+	  DPRINTF(3, "\t\t\t\tdisplay start\n");
+	  if(debug_multiple_start) {
+	    fprintf(stderr, "Multiple start in spu\n");
+	    exit(-1);
+	  }
+	  debug_multiple_start = 1;
+	  spu_info.start_time = start_time;
+	  break;
+	case 0x02: /* display stop */
+	  DPRINTF(3, "\t\t\t\tdisplay stop\n");
+	  spu_info.stop_time = start_time;
+	  break;
+	case 0x03: /* set colors */
+	  DPRINTF(3, "\t\t\t\tset colors");
+	  dummy = GETBYTES(2, "set_colors");
+	  spu_info.color[0] = dummy      & 0xf;
+	  spu_info.color[1] = (dummy>>4) & 0xf;
+	  spu_info.color[2] = (dummy>>8) & 0xf;
+	  spu_info.color[3] = (dummy>>12);
+	  DPRINTF(4, "0x%x 0x%x 0x%x 0x%x",
+		  spu_info.color[0], spu_info.color[1],
+		  spu_info.color[2], spu_info.color[3]);
+	  DPRINTF(3, "\n");
+	  break;
+	case 0x04: /* set contrast */
+	  DPRINTF(3, "\t\t\t\tset contrast");
+	  dummy = GETBYTES(2, "set_contrast");
+	  spu_info.contrast[0] = dummy      & 0xf;
+	  spu_info.contrast[1] = (dummy>>4) & 0xf;
+	  spu_info.contrast[2] = (dummy>>8) & 0xf;
+	  spu_info.contrast[3] = (dummy>>12);
+	  DPRINTF(4, "0x%x 0x%x 0x%x 0x%x",
+		  spu_info.contrast[0], spu_info.contrast[1],
+		  spu_info.contrast[2], spu_info.contrast[3]);
+	  DPRINTF(3, "\n");
+	  break;
+	case 0x05: /* set sp screen position */
+	  DPRINTF(3, "\t\t\t\tset sp screen position\n");
+	  dummy = GETBYTES(3, "x coordinates");
+	  spu_info.x_start = dummy>>12;
+	  spu_info.x_end   = dummy & 0xfff;
+	  dummy = GETBYTES(3, "y coordinates");
+	  spu_info.y_start = dummy>>12;
+	  spu_info.y_end   = dummy & 0xfff;
+	  spu_info.width  = spu_info.x_end - spu_info.x_start + 1;
+	  spu_info.height = spu_info.y_end - spu_info.y_start + 1;
+	  DPRINTF(4, "\t\t\t\t\tx_start=%i x_end=%i, y_start=%i, y_end=%i "
+		  "width=%i height=%i\n",
+		  spu_info.x_start, spu_info.x_end,
+		  spu_info.y_start, spu_info.y_end,
+		  spu_info.width, spu_info.height);
+	  break;
+	case 0x06: /* set start address in PXD */
+	  DPRINTF(3, "\t\t\t\tset start address in PXD\n");
+	  fieldoffset[0] = GETBYTES(2, "field 0 start");
+	  fieldoffset[1] = GETBYTES(2, "field 1 start");
+	  DPRINTF(4, "\t\t\t\t\tfield_0=%i field_1=%i\n",
+		  fieldoffset[0], fieldoffset[1]);
+	  break;
+	case 0x07: /* wipe */
+	  {
+	    uint16_t num;
+	    uint8_t color_left[4];
+	    uint8_t contrast_left[4];
+	    uint8_t color_right[4];
+	    uint8_t contrast_right[4];
+	    uint16_t y_start;
+	    uint16_t y_end;
+	    uint16_t x_pos;
+	    uint16_t u1, u2, u3; /* x_start, x_end, ? */
+	    int type;
+	    
+	    DPRINTF(3, "\t\t\t\twipe\n");
+	    
+	    num = GETBYTES(2,"cmd 7 length");
+	    
+	    y_start = GETBYTES(2, "wipe y_start");
+
+	    dummy = GETBYTES(2, "wipe y_end");
+	    type = (dummy >> 12) & 0xf;
+	    y_end = dummy & 0xfff;
+
+	    u1 = GETBYTES(2, "wipe unknown 1");
+
+	    dummy = GETBYTES(2, "wipe color_left");
+	    color_left[0] = dummy & 0xf;
+	    color_left[1] = (dummy >> 4) & 0xf;
+	    color_left[2] = (dummy >> 8) & 0xf;
+	    color_left[3] = (dummy >> 12) & 0xf;
+
+	    dummy = GETBYTES(2, "wipe contrast_left");
+	    contrast_left[0] = dummy & 0xf;
+	    contrast_left[1] = (dummy >> 4) & 0xf;
+	    contrast_left[2] = (dummy >> 8) & 0xf;
+	    contrast_left[3] = (dummy >> 12) & 0xf;
+
+	    if(type == 1) {
+
+	      u2 = GETBYTES(2, "wipe unknown 2");
+	      u3 = GETBYTES(2, "wipe unknown 2");
+
+	    } else if(type == 2) {
+	      
+	      x_pos = GETBYTES(2, "wipe x_pos");
+	      
+	      dummy = GETBYTES(2, "wipe color_right");
+	      color_right[0] = dummy & 0xf;
+	      color_right[1] = (dummy >> 4) & 0xf;
+	      color_right[2] = (dummy >> 8) & 0xf;
+	      color_right[3] = (dummy >> 12) & 0xf;
+	      
+	      dummy = GETBYTES(2, "wipe contrast_right");
+	      contrast_right[0] = dummy & 0xf;
+	      contrast_right[1] = (dummy >> 4) & 0xf;
+	      contrast_right[2] = (dummy >> 8) & 0xf;
+	      contrast_right[3] = (dummy >> 12) & 0xf;
+	      
+	      
+	      u2 = GETBYTES(2, "wipe unknown 2");
+	      u3 = GETBYTES(2, "wipe unknown 2");
+
+	    } else {
+	      fprintf(stderr, "unknown cmd 07 type\n");
+	      exit(-1);
+	    }
+
+	    if((u1 != 0) || (u2 != 0x0fff) || (u3 != 0xffff)) {
+	      fprintf(stderr, "unknown bits in cmd 7 used\n");
+	      exit(-1);
+	    }
+
+	    DPRINTF(4, "0x%x 0x%x 0x%x 0x%x",
+		    contrast_left[0], contrast_left[1],
+		    contrast_left[2], contrast_left[3]
+		    );
+	    DPRINTF(3, "\n");
+
+	    /*
+	      for(n = 0; n < num-2; n++) {
+	      DPRINTF(4, ":%02x ", (unsigned char) GETBYTES(1, "field 0 start"));
+	      }
+	    */
+	  }
+	  break;
+	default:
+	  fprintf(stderr,
+		  "\t\t\t\t*Unknown Display Control Command: %02x\n",
+		  command);
+	  //exit(1);
+	  break;
+	}
+      }
+      DPRINTF(3, "\t\tEnd of Command Sequence\n");
+      
+      
+      if(last_DCSQ == next_DCSQ_offset) {
+	DPRINTF(3, "End of Display Control Sequence Table\n");
+	break; // out of while loop
+      } else {
+	set_byte(buffer+next_DCSQ_offset);
+      }
+    }
+    if(spu == NULL) {
+      spu = get_spu_buffer(0);
+      // spu = get_spu_buffer(spu_info.width*spu_info.height);
+      (*(spu_t *)spu) = spu_info;
+      // spu_data = spu+sizeof(spu_t); 
+    }
+    
+    gettimeofday(&tp2, NULL);
+    
+    shm_buf_pos = 0;
+    
+    field=0;
+    aligned = 1;
+    set_byte(&buffer[fieldoffset[field]]);
+    
+    //    fprintf(stderr, "\nReading picture data\n");
+    
+    //    initialize(spu_info.width, spu_info.height);
+    x=0;
+    y=0;
+    nr_vlc = 0;
+    
+    DPRINTF(5, "vlc decoding\n");
+    while((fieldoffset[1] < DCSQT_offset) && (y < spu_info.height)) {
+      unsigned int vlc;
+      unsigned int length;
+      static unsigned int colorid;
+      unsigned char pixel_data;
+      
+      DPRINTF(6, "fieldoffset[0]: %d, fieldoffset[1]: %d, DCSQT_offset: %d\n",
+	      fieldoffset[0], fieldoffset[1], DCSQT_offset);
+
+
+      /*
+	llcc
+
+	01cc - 11cc
+	len: 1 - 3
+
+	00ll llcc
+
+	0001 00cc - 0011 11cc
+	len: 4 - 15
+
+	
+	0000 llll llcc
+	
+	0000 0100 00cc - 0000 1111 11cc
+	len: 16 - 63
+	
+
+	0000 00ll llll llcc
+
+	0000 0001 0000 00cc - 0000 0011 1111 11cc
+	len: 64 - 255, 0
+
+       */
+
+      vlc = get_nibble();
+      if(vlc < 0x4) {   //  vlc!= 0xN
+	vlc = (vlc << 4) | get_nibble();
+	if(vlc < 0x10) {  // vlc != 0xN-
+	  vlc = (vlc << 4) | get_nibble();
+	  if(vlc < 0x40) {  // vlc != 0xNN-
+	    vlc = (vlc << 4) | get_nibble();  // vlc != 0xNN--
+	  }
+	}
+      }
+      
+      nr_vlc++;
+      DPRINTF(4, "send_rle: %08x\n", vlc);
+      /* last two bits are colorid, the rest are run length */
+      length = vlc >> 2;
+      
+      colorid = vlc & 3;
+      pixel_data = (contrast[colorid] << 4) | (color[colorid] & 0x0f);
+      
+      if(length==0) { // new line
+	//   if (y >= height)
+	// return;
+	/* Fill current line with background color */
+	length = spu_info.width-x;
+      }
+      if(length+x > spu_info.width) {
+	fprintf(stderr, "tried to write past line-end\n");
+	length = spu_info.width-x;
+      }
+      
+      shm_buffer[shm_buf_pos++] = pixel_data;
+      shm_buffer[shm_buf_pos++] = length;
+      
+      x = x+length;
+      
+      if(x >= spu_info.width) {
+	x=0;
+	y++;
+	field = 1-field;
+	set_byte(&buffer[fieldoffset[field]]);
+      }
+      
+    }
+    gettimeofday(&tp3, NULL);
+    printf("%ld.%06ld %ld.%06ld %ld.%06ld\n",
+	   tp1.tv_sec, tp1.tv_usec,
+	   tp2.tv_sec, tp2.tv_usec,
+	   tp3.tv_sec, tp3.tv_usec);
+
+  }
+  free(buffer);
+  return 0;
+}
+  
+
+	
diff -urN -x CVS -x .cvsignore ogle-0.9.2/subpicture/spu_wrap.c ogle/subpicture/spu_wrap.c
--- ogle-0.9.2/subpicture/spu_wrap.c	1970-01-01 01:00:00.000000000 +0100
+++ ogle/subpicture/spu_wrap.c	2001-03-30 01:39:01.000000000 +0200
@@ -0,0 +1,296 @@
+#include <inttypes.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <signal.h>
+//#include <siginfo.h>
+#include <sys/mman.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/shm.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/msg.h>
+
+#include "common.h"
+#include "msgtypes.h"
+#include "queue.h"
+#include "ip_sem.h"
+
+#ifndef SHM_SHARE_MMU
+#define SHM_SHARE_MMU 0
+#endif
+
+int wait_for_msg(cmdtype_t cmdtype);
+int eval_msg(cmd_t *cmd);
+int attach_stream_buffer(uint8_t stream_id, uint8_t subtype, int shmid);
+int get_q();
+int attach_ctrl_shm(int shmid);
+
+
+char *program_name;
+
+int ctrl_data_shmid;
+ctrl_data_t *ctrl_data;
+ctrl_time_t *ctrl_time;
+
+int stream_shmid;
+char *stream_shmaddr;
+
+int data_buf_shmid;
+char *data_buf_shmaddr;
+
+int msgqid = -1;
+
+void usage()
+{
+  fprintf(stderr, "Usage: %s  [-m <msgid>]\n", 
+	  program_name);
+}
+
+int filefd;
+char *mmap_base;
+FILE *outfile;
+struct stat statbuf;
+int main(int argc, char *argv[])
+{
+  int c; 
+  program_name = argv[0];
+  
+  /* Parse command line options */
+  while ((c = getopt(argc, argv, "m:h?")) != EOF) {
+    switch (c) {
+    case 'm':
+      msgqid = atoi(optarg);
+      break;
+    case 'h':
+    case '?':
+      usage();
+      return 1;
+    }
+  }
+
+  if(msgqid == -1) {
+    if(argc - optind != 1){
+      usage();
+      return 1;
+    }
+  }
+
+  // test
+  outfile = fopen("/tmp/spu", "w");
+  
+
+  if(msgqid != -1) {
+    wait_for_msg(CMD_FILE_OPEN);
+    wait_for_msg(CMD_DECODE_STREAM_BUFFER);
+  } else {
+    fprintf(stderr, "what?\n");
+  }
+  
+  while(1) {
+    get_q();
+  }
+
+
+  return 0;
+}
+
+int file_open(char *infile)
+{
+  filefd = open(infile, O_RDONLY);
+  fstat(filefd, &statbuf);
+  mmap_base = (char *)mmap(NULL, statbuf.st_size, 
+			   PROT_READ, MAP_SHARED, filefd,0);
+  return 0;
+}
+
+
+int send_msg(msg_t *msg, int mtext_size)
+{
+  if(msgsnd(msgqid, msg, mtext_size, 0) == -1) {
+    perror("ctrl: msgsnd1");
+    return -1;
+  }
+  return 0;
+}
+
+
+int wait_for_msg(cmdtype_t cmdtype)
+{
+  msg_t msg;
+  cmd_t *cmd;
+  cmd = (cmd_t *)(msg.mtext);
+  cmd->cmdtype = CMD_NONE;
+  
+  while(cmd->cmdtype != cmdtype) {
+    if(msgrcv(msgqid, &msg, sizeof(msg.mtext),
+	      MTYPE_SPU_DECODE, 0) == -1) {
+      perror("msgrcv");
+      return -1;
+    } else {
+      fprintf(stderr, "spu_wrap: got msg\n");
+      eval_msg(cmd);
+    }
+    if(cmdtype == CMD_ALL) {
+      break;
+    }
+  }
+  return 0;
+}
+
+
+
+
+int eval_msg(cmd_t *cmd)
+{
+  msg_t sendmsg;
+  cmd_t *sendcmd;
+  
+  sendcmd = (cmd_t *)&sendmsg.mtext;
+  
+  switch(cmd->cmdtype) {
+  case CMD_FILE_OPEN:
+    file_open(cmd->cmd.file_open.file);
+    break;
+  case CMD_CTRL_DATA:
+    attach_ctrl_shm(cmd->cmd.ctrl_data.shmid);
+    break;
+  case CMD_DECODE_STREAM_BUFFER:
+    fprintf(stderr, "spu: got stream %x, %x buffer \n",
+	    cmd->cmd.stream_buffer.stream_id,
+	    cmd->cmd.stream_buffer.subtype);
+    attach_stream_buffer(cmd->cmd.stream_buffer.stream_id,
+			  cmd->cmd.stream_buffer.subtype,
+			  cmd->cmd.stream_buffer.q_shmid);
+
+
+    break;
+  default:
+    fprintf(stderr, "ctrl: unrecognized command cmdtype: %x\n",
+	    cmd->cmdtype);
+    return -1;
+    break;
+  }
+  
+  return 0;
+}
+
+
+int attach_stream_buffer(uint8_t stream_id, uint8_t subtype, int shmid)
+{
+  char *shmaddr;
+  q_head_t *q_head;
+  
+  fprintf(stderr, "spu: shmid: %d\n", shmid);
+  
+  if(shmid >= 0) {
+    if((shmaddr = shmat(shmid, NULL, SHM_SHARE_MMU)) == (void *)-1) {
+      perror("spu: attach_decoder_buffer(), shmat()");
+      return -1;
+    }
+    
+    stream_shmid = shmid;
+    stream_shmaddr = shmaddr;
+    
+  }    
+
+
+  q_head = (q_head_t *)stream_shmaddr;
+  shmid = q_head->data_buf_shmid;
+  
+  if(shmid >= 0) {
+    if((shmaddr = shmat(shmid, NULL, SHM_SHARE_MMU)) == (void *)-1) {
+      perror("spu: attach_data_buffer(), shmat()");
+      return -1;
+    }
+    
+    data_buf_shmid = shmid;
+    data_buf_shmaddr = shmaddr;
+    
+  }    
+  
+
+  return 0;
+  
+}
+
+int get_q()
+{
+  q_head_t *q_head;
+  q_elem_t *q_elems;
+  data_buf_head_t *data_head;
+  data_elem_t *data_elems;
+  data_elem_t *data_elem;
+  int elem;
+  
+  uint8_t PTS_DTS_flags;
+  uint64_t PTS;
+  uint64_t DTS;
+  int scr_nr;
+  int off;
+  int len;
+  static int prev_scr_nr = 0;
+  static int packnr = 0;
+  static struct timespec time_offset = { 0, 0 };
+  
+  q_head = (q_head_t *)stream_shmaddr;
+  q_elems = (q_elem_t *)(stream_shmaddr+sizeof(q_head_t));
+  elem = q_head->read_nr;
+  
+  if(ip_sem_wait(&q_head->queue, BUFS_FULL) == -1) {
+    perror("spu: get_q(), sem_wait()");
+    exit(1); // XXX 
+  }
+
+  data_head = (data_buf_head_t *)data_buf_shmaddr;
+  data_elems = (data_elem_t *)(data_buf_shmaddr+sizeof(data_buf_head_t));
+  
+  data_elem = &data_elems[q_elems[elem].data_elem_index];
+
+  PTS_DTS_flags = data_elem->PTS_DTS_flags;
+  PTS = data_elem->PTS;
+  DTS = data_elem->DTS;
+  scr_nr = data_elem->scr_nr;
+  off = data_elem->off;
+  len = data_elem->len;
+  
+  // Get time info...
+  
+  prev_scr_nr = scr_nr;
+  
+  q_head->read_nr = (q_head->read_nr+1)%q_head->nr_of_qelems;
+  
+  fwrite(mmap_base+off, len, 1, outfile);
+  fflush(outfile);
+  
+  
+  // release elem
+  data_elem->in_use = 0;
+  
+  if(ip_sem_post(&q_head->queue, BUFS_EMPTY) == -1) {
+    perror("spu: get_q(), sem_post()");
+    exit(1); // XXX 
+  }
+
+  return 0;
+}
+
+
+int attach_ctrl_shm(int shmid)
+{
+  char *shmaddr;
+  
+  if(shmid >= 0) {
+    if((shmaddr = shmat(shmid, NULL, SHM_SHARE_MMU)) == (void *)-1) {
+      perror("attach_ctrl_data(), shmat()");
+      return -1;
+    }
+    
+    ctrl_data_shmid = shmid;
+    ctrl_data = (ctrl_data_t*)shmaddr;
+    ctrl_time = (ctrl_time_t *)(shmaddr+sizeof(ctrl_data_t));
+
+  }    
+  return 0;
+  
+}
diff -urN -x CVS -x .cvsignore ogle-0.9.2/subpicture/subpicture.c ogle/subpicture/subpicture.c
--- ogle-0.9.2/subpicture/subpicture.c	1970-01-01 01:00:00.000000000 +0100
+++ ogle/subpicture/subpicture.c	2001-02-24 17:25:44.000000000 +0100
@@ -0,0 +1,656 @@
+/*
+ * subt2xpm.c - converts DVD subtitles to an XPM image
+ * Copyright (C) 2000   Samuel Hocevar <sam@via.ecp.fr>
+ *                       and Michel Lespinasse <walken@via.ecp.fr>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *                                                     
+ */
+
+
+#define DEBUG
+
+#ifndef NDEBUG
+#ifndef DEBUG
+#define NDEBUG
+#endif
+#endif
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <inttypes.h>
+#include <assert.h>
+#include <stdio.h>
+#include <errno.h>
+#include <malloc.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <string.h>
+#include <unistd.h>
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+#include <X11/extensions/shape.h>
+
+int fd;
+int aligned;
+uint16_t fieldoffset[2];
+uint16_t field=0;
+
+uint8_t color[4];
+uint8_t contrast[4];
+uint8_t* buffer;
+
+uint16_t x_start;
+uint16_t x_end;
+uint16_t y_start;
+uint16_t y_end;
+unsigned int width = 0;
+unsigned int height = 0;
+unsigned int x;
+unsigned int y;
+
+uint16_t spu_size;
+
+/* Variables pertaining to the x window */
+XImage *subpicture_image = NULL;
+XImage *subpicture_mask = NULL;
+uint8_t *data;
+uint8_t *mask_data;
+Visual* visual;
+unsigned int depth = 8;
+
+
+
+		
+Display *display;
+Window win;
+int screen_num;
+Colormap cmap;
+GC gc, gc1;
+Pixmap shape_pixmap;
+
+int InitWindow(int x, int y, int w, int h, char *display_name);
+void draw_subpicture(int x, int y, int w, int h);
+int create_shape(int w, int h);
+
+#ifdef DEBUG
+int debug;
+#endif
+
+#ifdef DEBUG
+#define DPRINTF(level, text...) \
+if(debug > level) \
+{ \
+    fprintf(stderr, ## text); \
+}
+#else
+#define DPRINTF(level, text...)
+#endif
+
+#ifdef DEBUG
+#define DPRINTBITS(level, bits, value) \
+{ \
+  int n; \
+  for(n = 0; n < bits; n++) { \
+    DPRINTF(level, "%u", (value>>(bits-n-1)) & 0x1); \
+  } \
+}
+#else
+#define DPRINTBITS(level, bits, value)
+#endif
+
+#ifdef DEBUG
+#define GETBYTES(a,b) getbytes(a,b)
+#else
+#define GETBYTES(a,b) getbytes(a)
+#endif
+
+static uint8_t *byte_pos;
+
+static inline void set_byte (uint8_t *byte) {
+  byte_pos = byte;
+}
+
+#ifdef DEBUG
+uint32_t getbytes(unsigned int num, char *func)
+#else
+static inline uint32_t getbytes(unsigned int num)
+#endif
+{
+#ifdef DEBUG
+  int tmpnum = num;
+#endif
+  uint32_t result = 0;
+
+  assert(num <= 4);
+
+  while(num > 0) {
+    result <<= 8;
+    result |= *byte_pos;
+    byte_pos++;
+    num--;
+  }
+
+  DPRINTF(5, "\n%s getbytes(%u): %i, 0x%0*x, ", 
+          func, tmpnum, result, tmpnum*2, result);
+  DPRINTBITS(5, tmpnum*8, result);
+  DPRINTF(5, "\n");
+  return result;
+}
+
+static inline uint8_t get_nibble (void)
+{
+  static uint8_t next = 0;
+  if (aligned) {
+    fieldoffset[field]++;
+    next = GETBYTES(1, "get_nibble (aligned)");
+    aligned = 0;
+    return next >> 4;
+  } else {
+    aligned = 1;
+    return next & 0xf;
+  }
+}
+
+
+/* Start of a new picture */
+void initialize() {
+  char *apa;
+  DPRINTF(5, "initialize()\n");
+  if (subpicture_image != NULL) {
+    XDestroyImage(subpicture_image);
+  } 
+
+  if (subpicture_mask != NULL) {
+    XDestroyImage(subpicture_mask);
+  } 
+ /* Create an XImage to draw in very 8-bitish */
+
+    
+  DPRINTF(1, "malloc() data\n");
+  apa = malloc(256);
+  DPRINTF(1, "size: %d\n", (width+7)/8*8*height);
+  data = malloc((width+7)/8*8*height);
+  free(apa);
+  DPRINTF(1, "malloc() mask_data\n");
+  mask_data = malloc((width+7)/8*8*height);
+
+  DPRINTF(5, "XCreateImage() subpicture_image\n");
+  subpicture_image = XCreateImage(display, visual, depth, XYPixmap, 0, data,
+                              width, height, 8, 0);
+  
+  DPRINTF(5, "XCreateImage() subpicture_mask\n");
+  subpicture_mask = XCreateImage(display, visual, 1, XYBitmap, 0, mask_data,
+                              width, height, 8, 0);
+
+}
+
+void send_rle (unsigned int vlc) {
+  unsigned int length;
+  static unsigned int colorid;
+  DPRINTF(4, "send_rle: %08x\n", vlc)
+  if(vlc==0) { // new line
+    if (y >= height)
+      return;
+    /* Fill current line with background color */
+    length = width-x;
+    colorid = 0; 
+  } else {  // data
+    /* last two bits are colorid, the rest are run length */
+    length = vlc >> 2;
+    colorid = vlc & 3;
+  }
+  assert(length != 0);
+  while (length-- && (x < width)) {
+    DPRINTF(6, "pos: %d, %d, col: %d\n", x, y, color[colorid]);
+    XPutPixel(subpicture_image, x, y, color[colorid]);
+    if(contrast[colorid]) {
+      XPutPixel(subpicture_mask, x, y, 0);
+    } else {
+      XPutPixel(subpicture_mask, x, y, 1);
+    }      
+    x++;
+  }
+
+  if(x>=width) {
+    x=0;
+    y++;
+    field = 1-field;
+    set_byte(&buffer[fieldoffset[field]]);
+    if(!aligned)
+      get_nibble();
+  }
+}
+char *program_name;
+
+void usage()
+{
+#ifdef DEBUG
+  fprintf(stderr, "Usage: %s [-d <level>] <infile>\n", program_name);
+#else
+  fprintf(stderr, "Usage: %s <infile>\n", program_name);
+#endif
+}
+int main (int argc, char *argv[]) {
+  uint32_t dummy;
+  int c;
+  uint8_t command;
+  uint16_t DCSQT_offset;
+
+  program_name = argv[0];
+
+  /* Parse command line options */
+#ifdef DEBUG
+  while ((c = getopt(argc, argv, "d:h?")) != EOF) {
+#else
+  while ((c = getopt(argc, argv, "h?")) != EOF) {
+#endif
+    
+    switch (c) {
+#ifdef DEBUG
+    case 'd':
+      debug = atoi(optarg);
+      break;
+#endif
+    case 'h':
+    case '?':
+      usage();
+      return 1;
+    }
+  }
+  
+  if(argc - optind != 1){
+    usage();
+    return 1;
+  }
+  
+
+  fd = open (argv[optind], 0);
+  if(fd < 0) {
+    fprintf(stderr,"file not found\n");
+    exit(1);
+  }
+
+  InitWindow(0,0,100,100,NULL);
+  
+  buffer = malloc(65536);
+
+  for(;;) {
+    
+    set_byte(buffer);
+    if(!read(fd, buffer, 2)) {
+      fprintf(stderr, "EOF\n");
+      exit(0);
+    }
+    spu_size = GETBYTES(2, "spu_size");
+    DPRINTF(3, "SPU size: 0x%04x\n", spu_size);
+    read(fd, &buffer[2], spu_size-2);
+    
+
+    DCSQT_offset = GETBYTES(2, "DCSQT_offset");
+    DPRINTF(3, "DCSQT offset: 0x%04x\n", DCSQT_offset);
+
+    DPRINTF(3, "Display Control Sequence Table:\n");
+
+    /* parse the DCSQT */
+    set_byte(buffer+DCSQT_offset);
+    while (1)
+      {
+	/* DCSQ */
+	int start_time;
+	static int next_DCSQ_offset = 0;
+	int last_DCSQ = 0;
+	DPRINTF(3, "\tDisplay Control Sequence:\n");
+	
+	start_time = GETBYTES(2, "start_time");
+	DPRINTF(3, "\t\tStart time: 0x%04x\n", start_time);
+	last_DCSQ = next_DCSQ_offset;
+	next_DCSQ_offset = GETBYTES(2, "next_DCSQ_offset");
+	DPRINTF(3, "\t\tNext DCSQ offset: 0x%04x\n", next_DCSQ_offset);
+	
+	DPRINTF(3, "\t\tCommand Sequence Start:\n");
+	
+	while((command = GETBYTES(1, "command")) != 0xff) {
+	  /* Command Sequence */
+	  
+	  DPRINTF(3, "\t\t\tDisplay Control Command: 0x%02x\n", command);
+	  
+	  switch (command) {
+            case 0x00: /* Menu */
+              DPRINTF(3, "\t\t\t\tMenu...\n");
+              break;
+	    case 0x01: /* display start */
+	      DPRINTF(3, "\t\t\t\tdisplay start\n");
+	      break;
+	    case 0x02: /* display stop */
+	      DPRINTF(3, "\t\t\t\tdisplay stop\n");
+	      break;
+	    case 0x03: /* set colors */
+	      DPRINTF(3, "\t\t\t\tset colors");
+              dummy = GETBYTES(2, "set_colors");
+	      color[0] = dummy      & 0xf;
+	      color[1] = (dummy>>4) & 0xf;
+	      color[2] = (dummy>>8) & 0xf;
+	      color[3] = (dummy>>12);
+              DPRINTF(4, "0x%x 0x%x 0x%x 0x%x",
+                      color[0], color[1], color[2], color[3]);
+              DPRINTF(3, "\n");
+	      break;
+	    case 0x04: /* set contrast */
+	      DPRINTF(3, "\t\t\t\tset contrast");
+              dummy = GETBYTES(2, "set_contrast");
+	      contrast[0] = dummy      & 0xf;
+	      contrast[1] = (dummy>>4) & 0xf;
+	      contrast[2] = (dummy>>8) & 0xf;
+	      contrast[3] = (dummy>>12);
+              DPRINTF(4, "0x%x 0x%x 0x%x 0x%x",
+                      contrast[0], contrast[1], contrast[2], contrast[3]);
+              DPRINTF(3, "\n");
+	      break;
+	    case 0x05: /* set sp screen position */
+	      DPRINTF(3, "\t\t\t\tset sp screen position\n");
+              dummy = GETBYTES(3, "x coordinates");
+              x_start = dummy>>12;
+              x_end   = dummy & 0xfff;
+              dummy = GETBYTES(3, "y coordinates");
+              y_start = dummy>>12;
+              y_end   = dummy & 0xfff;
+              width  = x_end - x_start + 1;
+              height = y_end - y_start + 1;
+              DPRINTF(4, "\t\t\t\t\tx_start=%i x_end=%i, y_start=%i, y_end=%i "
+                         "width=%i height=%i\n",
+                      x_start, x_end, y_start, y_end, width, height);
+              break;
+	    case 0x06: /* set start address in PXD */
+              DPRINTF(3, "\t\t\t\tset start address in PXD\n");
+              fieldoffset[0] = GETBYTES(2, "field 0 start");
+              fieldoffset[1] = GETBYTES(2, "field 1 start");
+              DPRINTF(4, "\t\t\t\t\tfield_0=%i field_1=%i\n",
+                  fieldoffset[0], fieldoffset[1]);
+              break;
+	    default:
+              fprintf(stderr,
+		      "\t\t\t\t*Unknown Display Control Command: %02x\n",
+		      command);
+	      exit(1);
+	      break;
+	    }
+	}
+	DPRINTF(3, "\t\tEnd of Command Sequence\n");
+	
+	if(last_DCSQ == next_DCSQ_offset) {
+	  DPRINTF(3, "End of Display Control Sequence Table\n");
+          break; // out of while loop
+	}
+	
+      }
+
+    field=0;
+    aligned = 1;
+    set_byte(&buffer[fieldoffset[field]]);
+
+    fprintf(stderr, "\nReading picture data\n");
+	 
+    initialize();
+    x=0;
+    y=0;
+    DPRINTF(5, "vlc decoding\n");
+    while((fieldoffset[1] < DCSQT_offset) && (y < height)) {
+      unsigned int vlc;
+      DPRINTF(6, "fieldoffset[0]: %d, fieldoffset[1]: %d, DCSQT_offset: %d\n",
+	      fieldoffset[0], fieldoffset[1], DCSQT_offset);
+      vlc = get_nibble();
+      if(vlc < 0x4) {   //  vlc!= 0xN
+        vlc = (vlc << 4) | get_nibble();
+        if(vlc < 0x10) {  // vlc != 0xN-
+          vlc = (vlc << 4) | get_nibble();
+          if(vlc < 0x40) {  // vlc != 0xNN-
+            vlc = (vlc << 4) | get_nibble();  // vlc != 0xNN--
+          }
+        }
+      }
+      send_rle(vlc);
+    }
+    while (y < height )  // fill
+      send_rle(0);
+    
+    draw_subpicture(x_start, y_start, width, height);
+  }
+  free(buffer);
+  return 0;
+}
+
+	
+void draw_subpicture(int x, int y, int w, int h)
+{
+  DPRINTF(3, "w,h: %d, %d\n", w, h);
+  XMoveResizeWindow(display, win, x, y, w, h);
+  XFlush(display);
+  XSync(display, False);
+  XPutImage(display, shape_pixmap, gc1, subpicture_mask, 0, 0, 0, 0, w, h);
+  XShapeCombineMask(display, win, ShapeBounding, 0, 0, shape_pixmap, ShapeSet);
+  XFlush(display);
+  XSync(display, False);
+  XPutImage(display, win, gc, subpicture_image, 0, 0, 0, 0, w, h);
+  XFlush(display);
+  XSync(display, False);
+  sleep(3);
+    
+}
+					
+		
+
+
+int InitWindow(int x, int y, int w, int h, char *display_name)
+{
+  XGCValues gcvalues;
+  unsigned long gcvaluemask;
+  XSetWindowAttributes attr;
+  XColor colarr[16] = {
+    {
+      0,
+      0, 0, 0,
+      (DoRed | DoGreen | DoBlue),
+      0
+    },
+
+    {
+      1,
+      0, 0, 0,
+      (DoRed | DoGreen | DoBlue),
+      0
+    },
+
+    {
+      2,
+      0, 65535, 0,
+      (DoRed | DoGreen | DoBlue),
+      0
+    },
+
+    {
+      3,
+      0, 0, 10000,
+      (DoRed | DoGreen | DoBlue),
+      0
+    },
+
+    {
+      4,
+      0, 6000, 0,
+      (DoRed | DoGreen | DoBlue),
+      0
+    },
+
+    {
+      5,
+      10000, 10000, 0,
+      (DoRed | DoGreen | DoBlue),
+      0
+    },
+
+    {
+      6,
+      3000, 25000, 5000,
+      (DoRed | DoGreen | DoBlue),
+      0
+    },
+
+    {
+      7,
+      30000, 0, 6000,
+      (DoRed | DoGreen | DoBlue),
+      0
+    },
+
+    {
+      8,
+      0, 30000, 14000,
+      (DoRed | DoGreen | DoBlue),
+      0
+    },
+
+    {
+      9,
+      55000, 55000, 55000,
+      (DoRed | DoGreen | DoBlue),
+      0
+    },
+
+    {
+      10,
+      6000, 600, 6000,
+      (DoRed | DoGreen | DoBlue),
+      0
+    },
+
+    {
+      11,
+      140, 14000, 140,
+      (DoRed | DoGreen | DoBlue),
+      0
+    },
+
+    {
+      12,
+      255, 255, 25500,
+      (DoRed | DoGreen | DoBlue),
+      0
+    },
+
+    {
+      13,
+      2505, 0, 6000,
+      (DoRed | DoGreen | DoBlue),
+      0
+    },
+
+    {
+      14,
+      2505, 4440, 140,
+      (DoRed | DoGreen | DoBlue),
+      0
+    },
+    {
+      15,
+      255, 65000, 255,
+      (DoRed | DoGreen | DoBlue),
+      0
+    },
+
+  };
+#if 0
+typedef struct {
+        unsigned long pixel;
+        unsigned short red, green, blue;
+        char flags;  /* do_red, do_green, do_blue */
+        char pad;
+} XColor;
+#endif
+ 
+ 
+  if ((display = XOpenDisplay(display_name)) == NULL) {
+    fprintf(stderr, "Couldn't open display\n");
+    exit(-1);
+  }
+  
+  screen_num = DefaultScreen(display);
+  
+
+  visual = DefaultVisual(display, screen_num);
+  XFlush(display);
+  XSync(display, False);
+  //    cmap = XCopyColormapAndFree(display, DefaultColormap(display, screen_num));
+  cmap = XCreateColormap(display, RootWindow(display, screen_num), visual, AllocAll);
+  XFlush(display);
+  XSync(display, False);
+  
+  XStoreColors(display, cmap, colarr, 16);
+  XInstallColormap(display, cmap);
+
+  XFlush(display);
+ 
+  
+  attr.colormap = cmap;
+  win = XCreateWindow(display,
+		      RootWindow(display, screen_num),
+		      x,y,w,h, 0, 8, InputOutput,
+		      visual,
+		      CWColormap,
+		      &attr);
+
+  gcvalues.foreground = 1;
+  gcvalues.background = 0;
+  gcvalues.function = GXcopy;
+  gcvaluemask = GCForeground | GCBackground |GCFunction;
+  gc = XCreateGC(display, win, gcvaluemask, &gcvalues);
+
+  
+  XMapWindow(display, win);
+  XSync(display,True);
+ XFlush(display);
+  sleep(1);
+ XFlush(display);
+  sleep(1);
+  
+  XDrawLine(display, win,gc, 0,0,100,100);
+  XFlush(display);
+  create_shape(720, 576);
+  gcvalues.foreground = 0;
+  gcvalues.background = 1;
+  gcvalues.function = GXcopy;
+  gcvaluemask = GCForeground | GCBackground |GCFunction;
+  gc1 = XCreateGC(display, shape_pixmap, gcvaluemask, &gcvalues);
+
+  XDrawLine(display, shape_pixmap, gc1, 0,0,100,100);
+  sleep(1);
+  return 0;
+
+}
+
+int create_shape(int w, int h)
+{
+  shape_pixmap = XCreatePixmap(display, win, w, h, 1);
+  XFlush(display);
+  return 0;
+}
+
+void free_shape()
+{
+  XFreePixmap(display, shape_pixmap);
+  return;
+}
+
diff -urN -x CVS -x .cvsignore ogle-0.9.2/ui/Makefile.am ogle/ui/Makefile.am
--- ogle-0.9.2/ui/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ ogle/ui/Makefile.am	2003-10-14 03:05:16.000000000 +0200
@@ -0,0 +1,26 @@
+# Ogle - A video player
+# Copyright (C) 2000, 2001 Björn Englund, Håkan Hjort, Martin Norbäck
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+pkglib_PROGRAMS = ui
+
+AM_CPPFLAGS = @TOP_INCLUDES@
+AM_CFLAGS = @O_CFLAGS@
+
+ui_SOURCES = ui.c
+
+ui_LDADD = $(top_builddir)/common/libcommon.a \
+	$(top_builddir)/ogle/libmsgevents.la
diff -urN -x CVS -x .cvsignore ogle-0.9.2/ui/ui.c ogle/ui/ui.c
--- ogle-0.9.2/ui/ui.c	1970-01-01 01:00:00.000000000 +0100
+++ ogle/ui/ui.c	2001-06-21 18:56:59.000000000 +0200
@@ -0,0 +1,412 @@
+/* Ogle - A video player
+ * Copyright (C) 2000, 2001 Björn Englund, Håkan Hjort
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <inttypes.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <signal.h>
+#include <sys/mman.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/shm.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/msg.h>
+#include <string.h>
+
+#include <ogle/msgevents.h>
+#include "common.h"
+#include "queue.h"
+
+int attach_stream_buffer(uint8_t stream_id, uint8_t subtype, int shmid);
+int get_q(void);
+int attach_ctrl_shm(int shmid);
+
+int input(void);
+
+
+char *program_name;
+
+int ctrl_data_shmid;
+ctrl_data_t *ctrl_data;
+ctrl_time_t *ctrl_time;
+
+int stream_shmid;
+char *stream_shmaddr;
+int msgqid = -1;
+
+static MsgEventQ_t *msgq;
+
+MsgEventClient_t demux_client;
+MsgEventClient_t spu_client;
+MsgEventClient_t nav_client;
+
+
+void usage(void)
+{
+  fprintf(stderr, "Usage: %s  [-m <msgid>]\n", 
+	  program_name);
+}
+
+int filefd;
+char *mmap_base;
+FILE *infile;
+struct stat statbuf;
+
+int main(int argc, char *argv[])
+{
+  int c; 
+  program_name = argv[0];
+  
+  /* Parse command line options */
+  while ((c = getopt(argc, argv, "m:h?")) != EOF) {
+    switch (c) {
+    case 'm':
+      msgqid = atoi(optarg);
+      break;
+    case 'h':
+    case '?':
+      usage();
+      return 1;
+    }
+  }
+
+  if(msgqid == -1) {
+    if(argc - optind != 1){
+      usage();
+      return 1;
+    }
+  }
+
+
+  
+
+  if((infile = fopen("/tmp/cmd", "r")) == NULL) {
+    fprintf(stderr, "******* file err\n");
+  }
+  
+  {
+    MsgEvent_t ev;
+
+    fprintf(stderr, "ui: opening msg q\n");
+    
+    // get a handle
+    if((msgq = MsgOpen(msgqid)) == NULL) {
+      fprintf(stderr, "ui: couldn't get message q\n");
+      exit(-1);
+    }
+    
+    fprintf(stderr, "ui: msg open q\n");
+    
+    // register with the resource manager and tell what we can do
+    ev.type = MsgEventQRegister;
+    ev.registercaps.capabilities = UI_DVD_CLI | UI_MPEG_CLI;
+    
+    if(MsgSendEvent(msgq, CLIENT_RESOURCE_MANAGER, &ev, 0) == -1) {
+      fprintf(stderr, "ui: couldn't register\n");
+    }
+
+    fprintf(stderr, "ui: registered q\n");
+    
+    ev.type = MsgEventQReqCapability;
+    ev.reqcapability.capability = DEMUX_MPEG2_PS | DEMUX_MPEG1;
+    if(MsgSendEvent(msgq, CLIENT_RESOURCE_MANAGER, &ev, 0) == -1) {
+      fprintf(stderr, "ui: didn't get cap\n");
+    }
+
+    fprintf(stderr, "ui: requested capability q\n");
+
+
+    while(!demux_client) {
+      MsgNextEvent(msgq, &ev);
+      switch(ev.type) {
+      case MsgEventQGntCapability:
+	if((ev.gntcapability.capability & (DEMUX_MPEG2_PS | DEMUX_MPEG1))
+	   == (DEMUX_MPEG2_PS | DEMUX_MPEG1)) {
+	  demux_client = ev.gntcapability.capclient;
+	} else {
+	  fprintf(stderr, "ui: capabilities not requested\n");
+	}
+	break;
+      default:
+	fprintf(stderr, "ui: event not wanted %d, from %ld\n",
+		ev.type, ev.any.client);
+	break;
+      }
+    }
+
+    if(demux_client) {
+      fprintf(stderr, "ui: got capability\n");
+    }
+    
+
+  }
+  input();
+  return 0;
+}
+
+
+
+
+
+int request_spu(void)
+{
+  MsgEvent_t ev;
+  ev.type = MsgEventQReqCapability;
+  ev.reqcapability.capability = DECODE_DVD_SPU;
+  if(MsgSendEvent(msgq, CLIENT_RESOURCE_MANAGER, &ev, 0) == -1) {
+    fprintf(stderr, "ui: didn't get cap\n");
+  }
+  
+  while(!spu_client) {
+    MsgNextEvent(msgq, &ev);
+    switch(ev.type) {
+    case MsgEventQGntCapability:
+      if((ev.gntcapability.capability & (DECODE_DVD_SPU))
+	 == (DECODE_DVD_SPU)) {
+	spu_client = ev.gntcapability.capclient;
+      } else {
+	fprintf(stderr, "ui: capabilities not requested\n");
+      }
+      break;
+    default:
+      fprintf(stderr, "ui: event not wanted %d, from %ld\n",
+	      ev.type, ev.any.client);
+      break;
+    }
+  }
+  return 0;
+}
+
+
+int request_nav(void)
+{
+  MsgEvent_t ev;
+  ev.type = MsgEventQReqCapability;
+  ev.reqcapability.capability = DECODE_DVD_NAV;
+  if(MsgSendEvent(msgq, CLIENT_RESOURCE_MANAGER, &ev, 0) == -1) {
+    fprintf(stderr, "ui: didn't get cap\n");
+  }
+  
+  while(!nav_client) {
+    MsgNextEvent(msgq, &ev);
+    switch(ev.type) {
+    case MsgEventQGntCapability:
+      if((ev.gntcapability.capability & (DECODE_DVD_NAV))
+	 == (DECODE_DVD_NAV)) {
+	nav_client = ev.gntcapability.capclient;
+      } else {
+	fprintf(stderr, "ui: capabilities not requested\n");
+      }
+      break;
+    default:
+      fprintf(stderr, "ui: event not wanted %d, from %ld\n",
+	      ev.type, ev.any.client);
+      break;
+    }
+  }
+  return 0;
+}
+
+
+
+
+#define CMDSTR_LEN 256
+int input(void) {
+  char cmdstr[CMDSTR_LEN];
+  char *tok;
+  MsgEventClient_t rcpt;
+  MsgEvent_t sendev;
+  
+
+  fprintf(stderr, "****input()\n");
+  while(!feof(infile)) {
+    rcpt = demux_client;
+    sendev.type = MsgEventQNone;
+    
+    fgets(cmdstr, CMDSTR_LEN, infile);
+    cmdstr[strlen(cmdstr)-1] = '\0';
+    
+    fprintf(stderr, "****input() got line\n");
+    
+    
+    fprintf(stderr, "string: .%s.\n", cmdstr);
+    tok = strtok(cmdstr, " ");
+    fprintf(stderr, "cmd: .%s.\n", tok);
+    if(strcmp(tok, "play") == 0) {
+      sendev.type = MsgEventQPlayCtrl;
+      sendev.playctrl.cmd = PlayCtrlCmdPlay;
+      fprintf(stderr, "****input() play\n");
+      
+    } else if(strcmp(tok, "play_from") == 0) {
+      sendev.type = MsgEventQPlayCtrl;
+      sendev.playctrl.cmd = PlayCtrlCmdPlayFrom;
+      tok = strtok(NULL, " ");
+      sendev.playctrl.from = strtol(tok, NULL, 0);
+
+    } else if(strcmp(tok, "play_to") == 0) {
+      sendev.type = MsgEventQPlayCtrl;
+      sendev.playctrl.cmd = PlayCtrlCmdPlayTo;
+      tok = strtok(NULL, " ");
+      sendev.playctrl.to = strtol(tok, NULL, 0);
+      
+    } else if(strcmp(tok, "play_from_to") == 0) {
+      sendev.type = MsgEventQPlayCtrl;
+      sendev.playctrl.cmd = PlayCtrlCmdPlayFromTo;
+      tok = strtok(NULL, " ");
+      sendev.playctrl.from = strtol(tok, NULL, 0);
+      tok = strtok(NULL, " ");
+      sendev.playctrl.to = strtol(tok, NULL, 0);
+      
+    } else if(strcmp(tok, "play_from_s") == 0) {
+      sendev.type = MsgEventQPlayCtrl;
+      sendev.playctrl.cmd = PlayCtrlCmdPlayFrom;
+      tok = strtok(NULL, " ");
+      sendev.playctrl.from = strtol(tok, NULL, 0)*2048;
+
+    } else if(strcmp(tok, "play_to_s") == 0) {
+      sendev.type = MsgEventQPlayCtrl;
+      sendev.playctrl.cmd = PlayCtrlCmdPlayTo;
+      tok = strtok(NULL, " ");
+      sendev.playctrl.to = (strtol(tok, NULL, 0)+1)*2048;
+      
+    } else if(strcmp(tok, "play_from_to_s") == 0) {
+      sendev.type = MsgEventQPlayCtrl;
+      sendev.playctrl.cmd = PlayCtrlCmdPlayFromTo;
+      tok = strtok(NULL, " ");
+      sendev.playctrl.from = strtol(tok, NULL, 0)*2048;
+      tok = strtok(NULL, " ");
+      sendev.playctrl.to = (strtol(tok, NULL, 0)+1)*2048;
+      
+    } else if(strcmp(tok, "stop") == 0) {
+      sendev.type = MsgEventQPlayCtrl;
+      sendev.playctrl.cmd = PlayCtrlCmdStop;
+      fprintf(stderr, "****input() stop\n");
+
+
+      /******** debug commands *********/
+
+    } else if(strcmp(tok, "palette") == 0) {
+      int n;
+      sendev.type = MsgEventQSPUPalette;
+      if(!spu_client) {
+	request_spu();
+      }
+      rcpt = spu_client;
+
+      for(n = 0; n < 16; n++) {
+	tok = strtok(NULL, " ");
+	sendev.spupalette.colors[n] = strtol(tok, NULL, 0);
+      }
+      
+    } else if(strcmp(tok, "highlight") == 0) {
+      int n;
+      sendev.type = MsgEventQSPUHighlight;
+      if(!spu_client) {
+	request_spu();
+      }
+      rcpt = spu_client;
+      
+      tok = strtok(NULL, " ");
+      sendev.spuhighlight.x_start = strtol(tok, NULL, 0);
+      tok = strtok(NULL, " ");
+      sendev.spuhighlight.y_start = strtol(tok, NULL, 0);
+      tok = strtok(NULL, " ");
+      sendev.spuhighlight.x_end = strtol(tok, NULL, 0);
+      tok = strtok(NULL, " ");
+      sendev.spuhighlight.y_end = strtol(tok, NULL, 0);
+      for(n = 0; n < 4; n++) {
+	tok = strtok(NULL, " ");
+	sendev.spuhighlight.color[n] =
+	  (unsigned char)strtol(tok, NULL, 0);
+      }
+      for(n = 0; n < 4; n++) {
+	tok = strtok(NULL, " ");
+	sendev.spuhighlight.contrast[n] =
+	  (unsigned char)strtol(tok, NULL, 0);
+      }
+      
+    } else if(strcmp(tok, "file") == 0) {
+      sendev.type = MsgEventQChangeFile;
+      
+      tok = strtok(NULL, "\n");
+
+      strncpy(sendev.changefile.filename, tok, PATH_MAX);
+      sendev.changefile.filename[PATH_MAX] = '\0';
+      
+    } else if(strcmp(tok, "btn") == 0) {
+      sendev.type = MsgEventQDVDCtrl;
+      if(!nav_client) {
+	request_nav();
+      }
+      rcpt = nav_client;
+      tok = strtok(NULL, " ");
+      if(strcmp(tok, "up") == 0) {
+	sendev.dvdctrl.cmd.type = DVDCtrlUpperButtonSelect;
+      } else if(strcmp(tok, "down") == 0) {
+	sendev.dvdctrl.cmd.type = DVDCtrlLowerButtonSelect;
+      } else if(strcmp(tok, "left") == 0) {
+	sendev.dvdctrl.cmd.type = DVDCtrlLeftButtonSelect;
+      } else if(strcmp(tok, "right") == 0) {
+	sendev.dvdctrl.cmd.type = DVDCtrlRightButtonSelect;
+      } else if(strcmp(tok, "activate") == 0) {
+	sendev.dvdctrl.cmd.type = DVDCtrlButtonActivate;
+      }
+    } else if(strcmp(tok, "btnnr") == 0) {
+      sendev.type = MsgEventQDVDCtrl;
+      if(!nav_client) {
+	request_nav();
+      }
+      rcpt = nav_client;
+      tok = strtok(NULL, " ");
+      if(strcmp(tok, "activate") == 0) {
+	sendev.dvdctrl.cmd.type = DVDCtrlButtonSelectAndActivate;
+      } else if(strcmp(tok, "select") == 0) {
+	sendev.dvdctrl.cmd.type = DVDCtrlButtonSelect;
+      }
+      tok = strtok(NULL, " ");
+      sendev.dvdctrl.cmd.button.nr = strtol(tok, NULL, 0);	
+
+    } else if(strcmp(tok, "speed") == 0) {
+      rcpt = CLIENT_RESOURCE_MANAGER;
+      sendev.type = MsgEventQSpeed;
+      tok = strtok(NULL, " ");
+      sscanf(tok, "%lf", &sendev.speed.speed);
+    }
+    
+
+    fprintf(stderr, "****input() tok end\n");
+
+    if(sendev.type != MsgEventQNone) {
+      if(MsgSendEvent(msgq, rcpt, &sendev, 0) == -1) {
+	fprintf(stderr, "ui: couldn't send user cmd\n");
+      }
+    }
+
+    fprintf(stderr, "****input() sent cmd\n");
+    
+    
+  }
+  
+  fprintf(stderr, "****input() exit\n");
+  
+  fclose(infile);
+  // send command quit
+
+  exit(0);
+}
diff -urN -x CVS -x .cvsignore ogle-0.9.2/vmg/BUGS ogle/vmg/BUGS
--- ogle-0.9.2/vmg/BUGS	1970-01-01 01:00:00.000000000 +0100
+++ ogle/vmg/BUGS	2001-06-19 23:24:50.000000000 +0200
@@ -0,0 +1,3 @@
+
+The Nav module does not have any perception of time. 
+Events (buttons/highlight/commands) happen at the wrong time (to early). 
diff -urN -x CVS -x .cvsignore ogle-0.9.2/vmg/IFO_STRUCTURE ogle/vmg/IFO_STRUCTURE
--- ogle-0.9.2/vmg/IFO_STRUCTURE	1970-01-01 01:00:00.000000000 +0100
+++ ogle/vmg/IFO_STRUCTURE	2001-03-12 00:20:08.000000000 +0100
@@ -0,0 +1,660 @@
+/*
+ * IFO structure information
+ *
+ * Copyright (C) 1999, 2000  Björn Englund <d4bjorn@dtek.chalmers.se>,
+ *                           Håkan Hjort <d95hjort@dtek.chalmers.se>
+ *
+ * Disclaimer:
+ * ----------
+ * All information herein was derived from publicly available
+ * sources such as USENET, World-Wide-Web sites, public emails and
+ * inspection of DVDs via hexadecimal dump.
+ *
+ * We have never looked at any part of the DVD standards.
+ * No information was obtained under non-disclosure agreement.
+ *
+ */
+
+
+Disc layout
+-------------------------------------------------------------------------------
+The files are stored in the following order on the DVD (increasing sector 
+number downwards). The entries in the ISO9660/UDF file sytems might list the 
+files in a different order, but this describes the physical sector layout on 
+the disc. All sectors that make up one file are are stored (in order) in one 
+continuous area. The offsets contained in VIDEO_TS.IFO for the VOBS (Start 
+sector of VMGM_VOBS) are counted from the start sector of VIDEO_TS.IFO itself.
+Likewise for the 'Last Sector of VMGI' and 'Last Sector of VMG'. The sectors 
+of VMG include all files that are named VIDEO_TS, these are ordered as 
+described below. The VOB part is optional.
+ 
+VIDEO_TS.IFO
+VIDEO_TS.VOB
+VIDEO_TS.BUP
+
+In the VMG_PTT_SRPT section of VIDEO_TS.IFO, the offsets to all VTS parts
+can be found. These are also made up of a collection of files, stored in
+the order shown below. Either one or both of the two VOB parts may be 
+present, (_0 is the menu VOBS and the others are the Title VOBS).
+
+VTS_01_0.IFO
+VTS_01_0.VOB
+VTS_01_1.VOB
+VTS_01_2.VOB
+...
+VTS_01_1.BUP
+VTS_02_0.IFO
+VTS_02_1.VOB
+...
+VTS_02_0.BUP
+
+All the VTS_XX_[1-].VOB files should realy be considered one large file. 
+There is however a file system limit on 1Gb, so for this reason there are
+multiple names. The layout of the 'one large file' is continuous, i.e. 
+doing reading from the start sector of VTS_XX_1.VOB for the total size
+of all the part will yield the entire VOBs and no extra data.
+
+
+File structure overview
+-------------------------------------------------------------------------------
+The following is a description of how the information in the IFO files are
+structured. It only 'names' the different values that are contained within
+them. Some have self explanatory names and others might not. 
+This description does not attempt do define the meaning or structure of 
+any of the values. For example 'Video attributes' are a two byte value 
+that really is a bit structure that describe several different properties 
+of the associated VOBS/MPEG-stream. 
+The sector offsets are almost always given from the beginning of the 
+containing structure. The ones in VMGI_MAT are for the beginning of VIDEO_TS
+data and the ones that are Cell start/last sector offsets are given relative
+the beginning of that VOBS.
+The '* start byte' offsets are likewise almost allays offsets form their
+containing structure. For example in a PCG the 'PGC Program Map start byte'
+is an offset given from the first byte of of that PGC structure.
+
+
+VIDEO_TS.IFO
+-------------------------------------------------------------------------------
+    VMGI_MAT:        Video Manager Information Management Table
+    VMGM_VOB:        Video Manager Menu VideoObjectSet
+    VMG_PTT_SRPTI:   Part of title search pointer table information
+    VMGM_PGCI_UT:    Video Manager Menu PGCI Unit Table
+    VMGM_LUI:        Video Manager Menu Language Unit Table
+    VMG_MAIT:        Parental Management Information Table
+    VMG_VTS_ATRT:    Video Title Set Attribute Table
+    VMG_TXTDT_MGI:   Text Data Manager information
+    VMGM_C_ADT:      VMGM Cell Address Table information
+    VMGM_VOBU_ADMAP: Video Title Set Menu VOBU Address Map
+
+
+VMG {
+    [0] VMGI_MAT: Video Manager Information Management Table {
+	[0-11]	     VMG Identifier ('DVDVIDEO-VMG')
+	[12-15]	     Last Sector of VMG
+	[16-27]	     --
+	[28-31]	     Last Sector of VMGI
+	[32]	     --
+	[33]	     Specification version number (bcd, 0x10 V1.0)
+	[34]	     VMG Category
+	[35]	     VMG Category, Regional Code mask Region (xx654321)
+	[36-37]	     VMG Category
+	[38-39]	     VMG Number of Volumes
+	[40-41]	     VMG This Volume
+	[42]	     Disc side
+	[43-61]	     --
+	[62-63]	     VMG Number of Title Sets
+	[64-95]	     Provider ID
+	[96-103]     VMG POS Code
+	[104-127]    --
+	[128-131]    End byte of VMGI_MAT
+	[132-135]    First Play PGC start byte (FP_PGC)
+	[136-191]    --
+	[192-195]    Start sector of VMGM_VOBS
+	[196-199]    Start sector of VMG_PTT_SRPT // wrong name?
+	[200-203]    Start sector of VMGM_PGCI_UT
+	[204-207]    Start sector of VMG_PTL_MAIT
+	[208-211]    Start sector of VMG_VTS_ATRT
+	[212-215]    Start sector of VMG_TXTDT_MGI
+	[216-219]    Start sector of VMGM_C_ADT
+	[220-223]    Start sector of VMGM_VOBU_ADMAP
+	[224-255]    --
+	[256-257]    Video attributes of VMGM_VOBS
+	[258]	     --
+	[259]	     Number of audio streams in VMGM_VOBS
+
+	for(n=0, m=260; n < nr audio streams in VMGM_VOBS; n++, m+=8) {
+	  [(m+0)-(m+7)]	    VMGM audio (n+1) attributes
+	}
+
+	[324-340]    --
+	[341]	     Number of Sub-picture streams in VTSM
+	for(n=0, m=342; n < nr subp streams in VMGM_VOBS; n++, m+=6) {
+	  [(m+0)-(m+5)]	    VMGM sub-picture stream (n+1) attributes
+	}
+
+
+	[First Play PGC start byte] PGC {
+	       [0-1]   --
+	       [2]     Number of Programs
+	       [3]     Number of Cells
+	       [4-7]   Playback time
+	       [8-11]  Prohibited user operations
+	       [12-13] Audio stream 1 status
+	       [14-15] Audio stream 2 status
+	       [16-17] Audio stream 3 status
+	       [18-19] Audio stream 4 status
+	       [20-21] Audio stream 5 status
+	       [22-23] Audio stream 6 status
+	       [24-25] Audio stream 7 status
+	       [26-27] Audio stream 8 status
+	       [28-31] Sub-picture stream 1 status
+	       [32-35] Sub-picture stream 2 status
+	       [36-39] Sub-picture stream 3 status
+	       [40-43] Sub-picture stream 4 status
+	       [44-47] Sub-picture stream 5 status
+	       [48-51] Sub-picture stream 6 status
+	       [52-55] Sub-picture stream 7 status
+	       [56-59] Sub-picture stream 8 status
+	       [60-63] Sub-picture stream 9 status
+	       [64-67] Sub-picture stream 10 status
+	       [68-71] Sub-picture stream 11 status
+	       [72-75] Sub-picture stream 12 status
+	       [76-79] Sub-picture stream 13 status
+	       [80-83] Sub-picture stream 14 status
+	       [84-87] Sub-picture stream 15 status
+	       [88-91] Sub-picture stream 16 status
+	       [92-95] Sub-picture stream 17 status
+	       [96-99] Sub-picture stream 18 status
+	       [100-103] Sub-picture stream 19 status
+	       [104-107] Sub-picture stream 20 status
+	       [108-111] Sub-picture stream 21 status
+	       [112-115] Sub-picture stream 22 status
+	       [116-119] Sub-picture stream 23 status
+	       [120-123] Sub-picture stream 24 status
+	       [124-127] Sub-picture stream 25 status
+	       [128-131] Sub-picture stream 26 status
+	       [132-135] Sub-picture stream 27 status
+	       [136-139] Sub-picture stream 28 status
+	       [140-143] Sub-picture stream 29 status
+	       [144-147] Sub-picture stream 30 status
+	       [148-151] Sub-picture stream 31 status
+	       [152-155] Sub-picture stream 32 status
+	       [156-157] Next PGC number
+	       [158-159] Previous PGC number
+	       [160-161] Go Up PGC number
+	       [162]	 Still time in seconds
+	       [163]	 PG Playback mode
+	       [164]	 --
+	       [165-167] Color 0 YCrCB
+	       [168]	 --
+	       [169-171] Color 1 YCrCB
+	       [172]	 --
+	       [173-175] Color 2 YCrCB
+	       [176]	 --
+	       [177-179] Color 3 YCrCB
+	       [180]	 --
+	       [181-183] Color 4 YCrCB
+	       [184]	 --
+	       [185-187] Color 5 YCrCB
+	       [188]	 --
+	       [189-191] Color 6 YCrCB
+	       [192]	 --
+	       [193-195] Color 7 YCrCB
+	       [196]	 --
+	       [197-199] Color 8 YCrCB
+	       [200]	 --
+	       [201-203] Color 9 YCrCB
+	       [204]	 --
+	       [205-207] Color 10 YCrCB
+	       [208]	 --
+	       [209-211] Color 11 YCrCB
+	       [212]	 --
+	       [213-215] Color 12 YCrCB
+	       [216]	 --
+	       [217-219] Color 13 YCrCB
+	       [220]	 --
+	       [221-223] Color 14 YCrCB
+	       [224]	 --
+	       [225-227] Color 15 YCrCB
+	       [228-229] PGC Command Table start byte 
+	       [230-231] PGC Program Map start byte
+	       [232-233] Cell Playback Information Table start byte
+	       [234-235] Cell Position Information Table start byte
+
+	       [PGC CT start byte] PGC Command Table {
+	         [0-1]	   Number of Pre Commands
+		 [2-3]	   Number of Post Commands
+		 [4-5]	   Number of Cell Commands
+		 [6-7]	   --
+		 [8-(8+nr_pre_cmd*8-1)] Pre Commands
+		 [(8+nr_pre_cmd*8)-(8+nr_pre_cmd*8+nr_post_cmd*8-1)] Post Commands
+		 [(8+nr_pre_cmd*8+nr_post_cmd*8)-(8+nr_pre_cmd*8+nr_post_cmd*8+nr_cell_cmd*8-1)] Cell Commands
+	       }
+
+	       [PGC PM start byte] PGC Program Map {
+	         for(n = 0; n < nr_of_programs; n++) {
+		  [n] Entry cell number for Program (n+1)
+		 }
+	       }
+
+	       [Cell Playback IT start byte] Cell Playback IT {
+	         for(n = 0, m = 0; n < nr_of_cells; n++, m+=24) {
+		  [(m+0)-(m+1)]   Cell (n+1) category
+		  [(m+2)]         Cell (n+1) still time (seconds, 0xff = Inf.)
+		  [(m+3)]         Cell (n+1) command Nr (0 = no command)
+		  [(m+4)-(m+7)]   Cell (n+1) playback time
+		  [(m+8)-(m+11)]  Cell (n+1) entry point sector
+		  [(m+12)-(m+15)] Cell (n+1) first ILVU VOBU end sector
+		  [(m+16)-(m+19)] Cell (n+1) start sector of last VOBU
+		  [(m+20)-(m+23)] Cell (n+1) last sector of this cell
+		 }
+	       }
+
+	       [Cell Position IT start byte] Cell Position IT {
+	         for(n = 0, m=0; n < nr_of_cells; n++, m+=4) {
+		   [(m+0)-(m+1)] Cell (n+1) has VOB ID %d
+		   [m+2]	 --
+		   [m+3]	 Cell (n+1) has Cell ID %d
+		 }
+	       }
+	}
+
+
+	// wrong name?
+	[Start sector of VMG_PTT_SRPT] PartOfTitle search pointer table info {
+	       [0-1]  Number of Title Unit Search Pointers TTUs in the VTS
+	       [2-3]  --
+	       [4-7]  End byte of PTT_SRPT table
+
+	       for(n=0, m=8; n< number of TTUs; n++, m+=12) Title set (n+1) {
+	         [(m+0)]	Title playback type
+		 [(m+1)]	Number of angles
+		 [(m+2)-(m+3)]	Number of PTTs (Chapters/ almost PGs)
+		 [(m+4)-(m+5)]	Parental ID field
+		 [(m+6)]	Title set number (VTS#)
+		 [(m+7)]	VTS_TTN (almost PGC)
+		 [(m+8)-(m+11)]	Title set starting sector number
+	       }
+	}
+
+
+
+	[Start sector of VMGM_PGCI_UT] Video Manager Menu PGCI Unit Table {
+	       [0-1]  Number of VMGM_PGCI_LUs
+	       [2-3]  --
+	       [4-7]  End byte of VMGM_PGCI_LUs table
+	       
+	       for(n=0, m=8; n < Number of VMGM_PGCI_LUs; n++, m+=8) {
+	        [(m+0)-(m+1)]	Video Manager Menu Language Code (ISO-??)
+	        [(m+2)]		--
+	        [(m+3)]		Video Manager Menu Existence mask
+				(VMGM Ayyy yyyy, A == Title menu(2))
+	        [(m+4)-(m+7)]	Video Manager Menu Language start byte
+	       }
+(Note 2)	       
+	       [VMGM LU start byte] Video Manager Menu Language Unit Table {
+	         [0-1]	      Number of VMGM_PGCI_SRP
+		 [2-3]	      --
+		 [4-7]	      End byte of VMGM_LU_EA table
+
+		 for(n=0, m=8; n < number of VMGM_PGCI_SRP; n++, m+=8) {
+		  [(m+0)]	 VMGM_PGC (n+1) Category Menu mask Xyyy yyyy
+				 (X==Menu, yyy yyyy==Menu type (see Existence))
+		  [(m+1)]	 VMGM_PGC (n+1) Category
+		  [(m+2)-(m+3)] VMGM_PGC (n+1) Category Parental ID mask
+		  [(m+4)-(m+7)] VMGM_PGCI start byte (n+1)
+		 }
+		 
+		 [VMG_PGCI start byte] PGC {
+		  see First Play PGC above
+		 }
+	       }
+	}
+
+
+
+	[Start sector of VMG_PTL_MAIT] Parental Management Information Table {
+	       [0-1]  Number of Countries
+	       [2-3]  Number of Video Title Sets
+	       [4-7]  End Byte of PTL_MAIT table
+	       for(n=0, m=8; n < number of countries; n++, m+=8) {
+	        [(m+0)-(m+1)]	Country code (ascii) (ISO-???) 
+		[(m+2)-(m+3)]	--
+		[(m+4)-(m+5)]	PTL_MAI start byte
+		[(m+6)-(m+7)]	--
+	       }
+
+	       [PTL_MAI start byte] Parental Management Information {
+		 for(n=1; n<=8; n++) {
+		   for(m=0; m<number of Video Title Sets + 1; m++) {
+		     [(m+0)-(m+1)] Parental mask for Parental Level n in VTS m
+				   (m == 0 is for the VMG)
+		   }
+		 }
+	       }
+	}
+
+
+
+	[Start sector of VMG_VTS_ATRT] Video Title Set Attribute Table {
+	       [0-1]   Number of Video Title Sets
+	       [2-3]   --
+	       [4-7]   End byte of VTS_ATR table
+	       for(n=0, m=8; n < number of video title sets; n++, m+=4) {
+	         [(m+0)-(m+3)] VTS (n+1) Attribute start byte
+	       }
+
+	       [VTS Attribute start byte] {
+	         [0-3]	VTS Attribute end byte
+		 [4-7]	VTS_CAT Application type
+		 [8-9]	Attributes of VTSM_VOBS  
+		 [10]	--
+		 [11]	Number of audio streams in VTSM_VOBS
+		 
+		 /* maybe only 1 loop allowed */
+		 for(n=0, m=12; n < number of audio streams; n++, m+=8) {
+		  [(m+0)-(m+7)]	 Audio (n+1) attributes
+		 }
+
+		 [92]	--
+		 [93]	Number of sub-picture streams
+		 
+		 /* maybe only 1 loop allowed */
+		 for(n=0, m=94; n < number of sub-picture streams; n++, m+=6) {
+		  [(m+0)-(m+5)]	 Sub-picture stream (n+1) attributes
+		 }
+
+		 [264-265]    Video Attributes of VTSTT_VOBS
+		 [266]	      --
+		 [267]	      Number of audio streams in VTSTT_VOBS
+		 
+		 for(n=0, m=268; n < nr of audio in VTSTT_VOBS; n++, m+=8) {
+		   [(m+0)-(m+8)] Audio (n+1) attributes
+		 }
+		 
+		 [348]	      --
+		 [349]	      Number of sub-picture streams in VTSTT_VOBS
+		 
+		 for(n=0, m=350; n < nr of subp in VTSTT_VOBS; n++, m+=6) {
+		   [(m+0)]	 Sub-picture stream (n+1) attributes
+		   [(m+1)-(m+5)] --
+		 }
+	       }
+	}
+
+
+
+	[Start sector of VMGM_C_ADT] VMGM Cell Address Table information {
+	       [0-1]  Number of VOBs in VMGM_VOBS
+	       [2-3]  --
+	       [4-7]  End byte of VMGM_C_ADT table
+	       
+	       for(n=0, m=8; m < end byte of VMGM_C_ADT; n++, m+=12) {
+	         // table entry (n+1)
+	         [(m+0)-(m+1)]	 VOB ID
+		 [(m+2)]	 Cell ID
+		 [(m+3)]	 --
+		 [(m+4)-(m+7)]	 Start sector
+		 [(m+8)-(m+11)]	 End sector
+	       }
+	}
+
+
+	
+	[Start sector of VMGM_VOBU_ADMAP] VMGM VOBU Address Map table {
+	       [0-3]  End byte of VMGM_VOBU_ADMAP
+
+	       for(n=0, m=4; m < end byte of VMGM_VOBU_ADMAP; n++, m+=4) {
+	        [(m+0)-(m+3)]	 VOBU (n+1) start sector
+	       }
+	}		 
+    }
+}
+
+
+
+
+VTS_XX_X.IFO
+-------------------------------------------------------------------------------
+    VTSI_MAT:        Video Title Set Information Management Table
+    VTSM_VOB:        Video Title Set Menu VideoObjectSet
+    VTS_VOB:         Video Title Set VideoObjectSet
+    PTT_SRPTI:       Part of Title Search Pointer Table 
+    VTS_PGCITI:      Video Title Set Program Chain Information Table
+    VTSM_PGCI_UT:    Video Title Set Menu PGCI Unit Table
+    VTSM_LUI:        Video Title Set Menu Language Unit Table
+    VTS_TMAPTI:      Video Title Set Time Map Table
+    VTSM_C_ADT:      Video Title Set Menu Cell Address Table
+    VTSM_VOBU_ADMAP: Video Title Set Menu VOBU Address Map Table
+    VTS_C_ADT:       Video Title Set Cell Address Table
+    VTS_VOBU_ADMAP:  Video Title Set Menu VOBU Address Map Table
+
+VTS {
+    [0] VTSI_MAT: Video Title Set Information Management Table {
+	[0-11]	     VTS Identifier
+	[12-15]	     Last Sector of VTS
+	[16-27]	     --
+	[28-31]	     Last Sector of VTSI
+	[32]	     --
+	[33]	     Specification version number
+	[34-37]	     VTS Category
+	[38-39]	     -- (VMG Number of Volumes)
+	[40-41]	     -- (VMG This Volume)
+	[42]	     -- (Disc side)	
+	[43-61]	     --
+	[62-63]	     -- (VMG Number of Title Sets)
+	[64-95]	     -- (Provider ID)
+	[96-103]     -- (VMG POS Code)
+	[104-127]    --
+	[128-131]    End byte of VTSI_MAT
+	[132-135]    -- (First Play PGC start byte)
+	[136-191]    --
+	[192-195]    Start sector of VTSM_VOBS		(VMGM_VOBS)
+	[196-199]    Start sector of VTSTT_VOBS		(VMG_PTT_SRPT)
+	[200-203]    Start sector of VTS_PTT_SRPT	(VMGM_PGCI_UT)
+	[204-207]    Start sector of VTS_PGCIT		(VMG_PTL_MAIT)
+	[208-211]    Start sector of VTSM_PGCI_UT	(VMG_VTS_ATRT)
+	[212-215]    Start sector of VTS_TMAPT		(VMG_TXTDT_MGI)
+	[216-219]    Start sector of VTSM_C_ADT		(VMGM_C_ADT)
+	[220-223]    Start sector of VTSM_VOBU_ADMAP	(VMGM_VOBU_ADMAP)
+	[224-227]    Start sector of VTS_C_ADT		(--)
+	[228-231]    Start sector of VTS_VOBU_ADMAP	(--)
+	[232-255]    --
+	[256-257]    Video attributes of VTSM_VOBS
+	[258]	     -
+	[259]	     Number of audio streams in VTSM_VOBS
+
+	for(n=0, m=260; n < nr audio streams in VTSM_VOBS; n++, m+=8) {
+	  [(m+0)-(m+7)]	    VTSM audio (n+1) attributes
+	}
+
+	[324-340]    --
+	[341]	     Number of Sub-picture streams in VTSM
+	for(n=0, m=342; n < nr subp streams in VTSM_VOBS; n++, m+=6) {
+	  [(m+0)-(m+5)]	    VTSM sub-picture stream (n+1) attributes
+	}
+
+	[510-511]    --
+	[512-513]    Video attributes of VTSTT_VOBS
+	[514]	     --
+	[515]	     Number of audio streams in VTSTT_VOBS
+
+	for(n=0, m=516; n < nr audio streams in VTSTT_VOBS; n++, m+=8) {
+	  [(m+0)-(m+7)]	    Audio (n+1) attributes
+	}
+
+	[596]	     --
+	[597]	     Number of sub-picture streams in VTSTT_VOBS
+	
+	for(n=0, m=598; n < nr subp streams in VTSTT_VOBS; n++, m+=6) {
+	  [(m+0)-(m+5)]	    Sub-picture stream (n+1) attributes
+	}
+
+	
+		
+	[Start sector of VTS_PTT_SRPT] PartOfTitle Search Pointer Table {
+	       [0-1]  Number of Title Unit Search Pointers TTUs in the VTS
+	       [2-3]  --
+	       [4-7]  End byte of PTT_SRPT table
+
+	       for(n=0, m=8; n < number of TTUs; n++, m+=4) {
+	         [(m+0)-(m+3)]	Starting byte of TTU (n+1)
+	       }
+
+	       [Starting byte of TTU] {
+#if variant
+	        for(m = start_byte_of_ttu;
+		    m < (start_next_ttu && end_ptt_SRPT);	
+		    m+=4) {
+#else
+	        for(n = 0, m = start_byte_of_ttu;
+		    n < Number of PTTs (from VMG_PTT_SRPTI in VIDEO_TS.IFO);
+		    n++, m+=4) {
+#endif	    
+		    [(m+0)-(m+1)]  Program Chain number PGCN
+		    [(m+2)-(m+3)]  Program number PGN
+		}
+	       }
+	}
+	
+
+
+	[Start sector of VTSM_PGCI_UT] Video Title Set Menu PGCI Unit Table {
+	       [0-1]  Number of VTSM_PGCI_LUs
+	       [2-3]  --
+	       [4-7]  End byte of VTSM_PGCI_LUs table
+	       
+	       for(n=0, m=8; n < Number of VTSM_PGCI_LUs; n++, m+=8) {
+	        [(m+0)-(m+1)]	Video Title Set Menu Language Code
+	        [(m+2)]		--
+	        [(m+3)]		Video Title Set Menu Existence mask
+				(VTSM ABCD Eyyy 
+				 A == Root menu(3) B == Sub-picture menu(4)
+				 C == Audio menu(5) D == Angle menu(6)
+				 E == PTT menu(7) )
+	        [(m+4)-(m+7)]	Video Title Set Menu Language start byte
+	       }
+(Note 2)	       
+	       [VTSM LU start byte] Video Title Set Menu Language Unit {
+	         [0-1]	      Number of VTSM_PGCI_SRP
+		 [2-3]	      --
+		 [4-7]	      End byte of VTSM_LU_EA table
+		 for(n=0, m=8; n < number of VTSM_PGCI_SRP; n++, m+=8) {
+		   [(m+0)]	 VTSM_PGC (n+1) Category Menu mask Xyyy yyyy
+				 (X==Menu, yyy yyyy==Menu type (see Existence))
+		   [(m+1)]	 VTSM_PGC (n+1) Category
+		   [(m+2)-(m+3)] VTSM_PGC (n+1) Category Parental ID mask
+		   [(m+4)-(m+7)] VTSM_PGCI start byte (n+1)
+		 }
+
+		 [VTSM_PGCI start byte] PGC {
+		  see First Play PGC above
+		 }
+	       }
+	}
+
+
+
+(Note 2)
+	[Start sector of VTS_PGCITI] Video Title Set Program Chain Info Table {
+	       [0-1]  Number of VTS_PGCI_SRP
+	       [2-3]  --
+	       [4-7]  End byte of VTS_PGCI table
+	       
+	       for(n=0,m=8; n< number of VTS_PGCI_SRP; n++,m+=8) {
+		   [(m+0)]	 VTS_PGC (n+1) Category mask Xyyy yyyy
+				 (X == ?, yyy yyyy == ?)
+		   [(m+1)]	 VTS_PGC (n+1) Category
+		   [(m+2)-(m+3)] VTS_PGC (n+1) Category Parental ID mask
+		   [(m+4)-(m+7)] VTS_PGCI start byte (n+1)
+	       }
+
+		 [VTS_PGCI start byte] PGC {
+		  see First Play PGC above
+		 }
+	       }
+	}
+
+
+
+	[Start sector of VTS_TMAPTI] Video Title Set Time Map Table {
+	       [0-1]  Number of VTS_TMAPS
+	       [2-3]  --
+	       [4-7]  End byte of VTS_TMAPS
+
+	       for(n=0, m=8; n < nr_vts_tmaps; n++, m+=4) {
+	        [(m+0)-(m+3)] Time map (n+1) start byte
+	       }
+
+	       [TMAP start byte] {
+	         [0]     time unit (in seconds)
+		 [1]     --	       
+		 [2-3]	 number of entries in time map
+		 
+		 for(n=0, m=4; n < nr_entries; n++, m+=4) {
+		  [(m+0)-(m+3)]	   Entry (n+1) at sector
+		    /* Discontinuity if msb set ex: 0x80023c61 */
+		    /*                                ^        */
+		 }
+	       }
+	}	 
+
+
+
+	[Start sector of VTSM_C_ADT] Video Title Set Menu Cell Address Table {
+	       [0-1]  Number of VOBs in VTSM_VOBS
+	       [2-3]  --
+	       [4-7]  End byte of VTSM_C_ADT table
+	       
+	       for(n=0, m=8; m < end byte of VTSM_C_ADT; n++, m+=12) {
+	         // table entry (n+1)
+	         [(m+0)-(m+1)]	VOB ID
+		 [(m+2)]	Cell ID
+		 [(m+3)]	--
+		 [(m+4)-(m+7)]	Start sector
+		 [(m+8)-(m+11)]	End sector
+	       }
+	}
+
+
+
+	[Start sector of VTSM_VOBU_ADMAP] Video Title Set Menu VOBU Address Map table {
+	       [0-3]  End byte of VTSM_VOBU_ADMAP
+
+	       for(n=0, m=4; m < end byte of VTSM_VOBU_ADMAP; n++, m+=4) {
+	        [(m+0)-(m+3)]	VOBU (n+1) start sector
+	       }
+	}
+
+
+
+	[Start sector of VTS_C_ADT] VTS Cell Address Table  {
+	       [0-1]  Number of VOBs in VTS_VOBS
+	       [2-3]  --
+	       [4-7]  End byte of VTS_C_ADT table
+	       
+	       for(n=0,m=8; m< end byte of VTS_C_ADT; n++,m+=12) {
+	         // table entry (n+1)
+	         [(m+0)-(m+1)]	VOB ID
+		 [(m+2)]	Cell ID
+		 [(m+3)]	--
+		 [(m+4)-(m+7)]	Start sector
+		 [(m+8)-(m+11)]	End sector
+	       }
+	}
+
+
+
+	[Start sector of VTS_VOBU_ADMAP] Video Title Set VOBU Address Map table {
+	       [0-3]  End byte of VTS_VOBU_ADMAP
+
+	       for(n=0, m=4; m < end byte of VTS_VOBU_ADMAP; n++, m+=4) {
+	        [(m+0)-(m+3)]	VOBU (n+1) start sector
+	       }
+	}		 
+    }
+}
+
+
+(Note 2)
+These are all in the same format..
diff -urN -x CVS -x .cvsignore ogle-0.9.2/vmg/INSTRUCTIONS ogle/vmg/INSTRUCTIONS
--- ogle-0.9.2/vmg/INSTRUCTIONS	1970-01-01 01:00:00.000000000 +0100
+++ ogle/vmg/INSTRUCTIONS	2002-11-09 22:31:23.000000000 +0100
@@ -0,0 +1,133 @@
+ SSSS      CCC            r[A]
+=======   =====      ===============
+0001  =   000        0000_XXXX  g[X]
+0010 <->  001 BC &   100X_XXXX  s[x]
+0011 +=   010 EQ ==
+0100 -=   011 NE !=
+0101 *=   100 GE >=
+0110 /=   101 GT >
+0111 %=   110 LE <=
+1000 rnd  111 LT <
+1001 &= 
+1010 |= 
+1011 ^= 
+
+000 -- Special commands
+=======================
+0000_0000 0CCC_**** ****_**** AAAA_AAAA ****_**** BBBB_BBBB ****_**** ****_**** -- if (r[A] `C` r[B]) then ...
+0000_0000 1CCC_**** ****_**** AAAA_AAAA DDDD_DDDD DDDD_DDDD ****_**** ****_**** -- if (r[A] `C` D) then ...
+
+0000_0000 ****_0000 ****_**** ****_**** ****_**** ****_**** ****_**** ****_**** -- NOP
+0000_0000 ****_0001 ****_**** ****_**** ****_**** ****_**** ****_**** LLLL_LLLL -- Goto L
+0000_0000 ****_0010 ****_**** ****_**** ****_**** ****_**** ****_**** ****_**** -- Break
+0000_0000 ****_0011 ****_**** ****_**** ****_**** ****_**** ****_PPPP LLLL_LLLL -- SetTmpPML P,L
+
+001(0) -- Link commands
+=========================
+0010_**** 0CCC_**** ****_**** AAAA_AAAA ****_**** BBBB_BBBB ****_**** ****_**** -- if (r[A] `C` r[B]) then ...
+0010_**** 1CCC_**** ****_**** AAAA_AAAA DDDD_DDDD DDDD_DDDD ****_**** ****_**** -- if (r[A] `C` D) then ...
+
+0010_0000 ****_0001 -- Link by Sub-Instruction
+0010_0000 ****_0001 ****_**** ****_**** ****_**** ****_**** BBBB_BB** ***0_0000 -- LinkNoLink
+0010_0000 ****_0001 ****_**** ****_**** ****_**** ****_**** BBBB_BB** ***0_0001 -- LinkTopC
+0010_0000 ****_0001 ****_**** ****_**** ****_**** ****_**** BBBB_BB** ***0_0010 -- LinkNextC
+0010_0000 ****_0001 ****_**** ****_**** ****_**** ****_**** BBBB_BB** ***0_0011 -- LinkPrevC
+0010_0000 ****_0001 ****_**** ****_**** ****_**** ****_**** BBBB_BB** ***0_0101 -- LinkTopPG
+0010_0000 ****_0001 ****_**** ****_**** ****_**** ****_**** BBBB_BB** ***0_0110 -- LinkNextPG
+0010_0000 ****_0001 ****_**** ****_**** ****_**** ****_**** BBBB_BB** ***0_0111 -- LinkPrevPG
+0010_0000 ****_0001 ****_**** ****_**** ****_**** ****_**** BBBB_BB** ***0_1001 -- LinkTopPGC
+0010_0000 ****_0001 ****_**** ****_**** ****_**** ****_**** BBBB_BB** ***0_1010 -- LinkNextPGC
+0010_0000 ****_0001 ****_**** ****_**** ****_**** ****_**** BBBB_BB** ***0_1011 -- LinkPrevPGC
+0010_0000 ****_0001 ****_**** ****_**** ****_**** ****_**** BBBB_BB** ***0_1100 -- LinkGoUpPGC
+0010_0000 ****_0001 ****_**** ****_**** ****_**** ****_**** BBBB_BB** ***0_1101 -- LinkTailPGC
+0010_0000 ****_0001 ****_**** ****_**** ****_**** ****_**** BBBB_BB** ***1_0000 -- RSM
+
+0010_0000 ****_0100 ****_**** ****_**** ****_**** ****_**** *NNN_NNNN NNNN_NNNN -- LinkPGCN ??
+0010_0000 ****_0101 ****_**** ****_**** ****_**** ****_**** BBBB_BBNN NNNN_NNNN -- LinkPTTN ??
+0010_0000 ****_0110 ****_**** ****_**** ****_**** ****_**** BBBB_BB** *NNN_NNNN -- LinkPGN ??
+0010_0000 ****_0111 ****_**** ****_**** ****_**** ****_**** BBBB_BB** NNNN_NNNN -- LinkCN ??
+
+
+001(1) -- Jump commands
+=========================
+0011_**** 0CCC_**** ****_**** ****_**** ****_**** ****_**** AAAA_AAAA BBBB_BBBB -- if (r[A] `C` r[B]) then ...
+0011_**** 1CCC_**** ****_**** ****_**** ****_**** ****_**** ****_**** ****_**** -- <not allowed>
+
+0011_0000 ****_0001 ****_**** ****_**** ****_**** ****_**** ****_**** ****_**** -- Exit
+0011_0000 ****_0010 ****_**** ****_**** ****_**** *TTT_TTTT ****_**** ****_**** -- JumpTT          (jump to title in vts title domain [from FP,VMGM])
+0011_0000 ****_0011 ****_**** ****_**** ****_**** *TTT_TTTT ****_**** ****_**** -- JumpVTS_TT      (jump to title in same vts title domain [from VTSM,VTS])
+0011_0000 ****_0101 ****_**PP PPPP_PPPP ****_**** *TTT_TTTT ****_**** ****_**** -- JumpVTS_PTT     (jump to ptt in the same vts)
+0011_0000 ****_0110 ****_**** ****_**** ****_**** 00**_**** ****_**** ****_**** -- JumpSS FP_DOM   (jump to FP)                      (from FP,VMGM,VTSM)
+0011_0000 ****_0110 ****_**** ****_**** ****_**** 01**_MMMM ****_**** ****_**** -- JumpSS VMGM_DOM (jump to menu in VMG)             (from FP,VTSM)
+0011_0000 ****_0110 ****_**** TTTT_TTTT VVVV_VVVV 10**_MMMM ****_**** ****_**** -- JumpSS VTSM_DOM (jump to menu,title,vts in VTSM)  (from FP,VMGM)
+0011_0000 ****_0110 *PPP_PPPP PPPP_PPPP ****_**** 11**_**** ****_**** ****_**** -- JumpSS VMGM_DOM (jump to pgc in VMG)              (from FP,VTSM)
+0011_0000 ****_1000 ****_**** ****_**** RRRR_RRRR 00**_**** ****_**** ****_**** -- CallSS FP_DOM   (jump to FP)                      (from VTS)
+0011_0000 ****_1000 ****_**** ****_**** RRRR_RRRR 01**_MMMM ****_**** ****_**** -- CallSS VMGM_DOM (jump to menu in VMG)             (from VTS) 
+0011_0000 ****_1000 ****_**** ****_**** RRRR_RRRR 10**_MMMM ****_**** ****_**** -- CallSS VTSM_DOM (jump to menu in VTSM [this vts]) (from VTS)
+0011_0000 ****_1000 *PPP_PPPP PPPP_PPPP RRRR_RRRR 11**_**** ****_**** ****_**** -- CallSS VMGM_DOM (jump to pgc in VMG)              (from VTS)
+
+
+010 -- Set System Parameters (Can be combined with Link commands)
+============================
+010*_**** 0CCC_**** ****_**** ****_**** ****_**** ****_**** AAAA_AAAA BBBB_BBBB -- if (r[A] `C` r[B]) then ...
+010*_**** 1CCC_**** ****_**** ****_**** ****_**** ****_**** ****_**** ****_**** -- <not allowed>
+
+0100_0001 ****_**** ****_**** A***_XXXX B***_YYYY C***_ZZZZ ****_**** ****_**** -- SetSTN A -> s[1]=g[X] B -> s[2]=g[Y] C-> s[3]=g[Z]
+0101_0001 ****_**** ****_**** AXXX_XXXX BYYY_YYYY CZZZ_ZZZZ ****_**** ****_**** -- SetSTN A -> s[1]=X    B -> s[2]=Y    C-> s[3]=Z
+
+0100_0010 ****_**** ****_**** BBBB_BBBB ****_**** *NNN_NNNN ****_**** ****_**** -- SetNVTMR s[9]=r[B] s[10]=N ??(size of N)
+0101_0010 ****_**** DDDD_DDDD DDDD_DDDD ****_**** *NNN_NNNN ****_**** ****_**** -- SetNVTMR s[9]=D    s[10]=N ??(size of N)
+
+0100_0011 ****_**** ****_**** BBBB_BBBB ****_**** 0***_AAAA ****_**** ****_**** -- SetGPRMMD register g[A] = r[B]
+0101_0011 ****_**** DDDD_DDDD DDDD_DDDD ****_**** 0***_AAAA ****_**** ****_**** -- SetGPRMMD register g[A] = D
+0100_0011 ****_**** ****_**** BBBB_BBBB ****_**** 1***_AAAA ****_**** ****_**** -- SetGPRMMD counter  g[A] = r[B]
+0101_0011 ****_**** DDDD_DDDD DDDD_DDDD ****_**** 1***_AAAA ****_**** ****_**** -- SetGPRMMD counter  g[A] = D
+
+0100_0110 ****_**** ****_**** ****_**** ****_**** ****_BBBB ****_**** ****_**** -- SetHL_BTNN s[8]=g[B]
+0101_0110 ****_**** ****_**** ****_**** DDDD_DDDD DDDD_DDDD ****_**** ****_**** -- SetHL_BTNN s[8]=D (button number are stored in the highest six bits)
+There should also be a SetAMXMD in this group.
+
+011 -- Set General Parameters (Can be combined with Link commands)
+=============================
+011*_**** 0CCC_**** AAAA_AAAA ****_**** ****_**** ****_**** ****_**** BBBB_BBBB -- if (r[A] `C` r[B]) ...
+011*_**** 1CCC_**** AAAA_AAAA ****_**** ****_**** ****_**** DDDD_DDDD DDDD_DDDD -- if (r[A] `C` D)    ...
+
+0110_SSSS ****_**** ****_**** AAAA_AAAA ****_**** BBBB_BBBB ****_**** ****_**** -- g[A] `S` r[B]
+0111_SSSS ****_**** ****_**** AAAA_AAAA DDDD_DDDD DDDD_DDDD ****_**** ****_**** -- g[A] `S` D
+
+
+
+100 -- Set, Compare -> Link Sub-Instruction
+=============================
+100*_**** 0CCC_AAAA ****_**** ****_**** ****_**** BBBB_BBBB ****_**** ****_**** -- ... if (g[A] `C` r[B]) ...
+100*_**** 1CCC_AAAA ****_**** ****_**** DDDD_DDDD DDDD_DDDD ****_**** ****_**** -- ... if (g[A] `C` D) ...
+1000_SSSS ****_AAAA ****_**** CCCC_CCCC ****_**** ****_**** ****_**** ****_**** -- ... g[A] `S` r[C] ...
+1001_SSSS ****_AAAA EEEE_EEEE EEEE_EEEE ****_**** ****_**** ****_**** ****_**** -- ... g[A] `S` E ...
+
+101 -- Compare -> (Set and Link Sub-Instruction)
+110 -- Compare -> Set, always Link Sub-Instruction
+=============================
+1QQ0_**** 0CCC_**** ****_**** LLLL_LLLL ****_**** BBBB_BBBB ****_**** ****_**** -- ... if (g[L] `C` r[B]) ...
+1QQ0_**** 1CCC_**** ****_**** LLLL_LLLL DDDD_DDDD DDDD_DDDD ****_**** ****_**** -- ... if (g[L] `C` D) ...
+
+1QQ1_**** 0CCC_**** ****_**** ****_**** LLLL_LLLL BBBB_BBBB ****_**** ****_**** -- ... if (g[L] `C` r[B]) ...
+1QQ1_**** 1CCC_**** ****_**** ****_**** ****_**** ****_**** ****_**** ****_**** -- ... -- not allowed --
+
+1QQ0_SSSS ****_AAAA CCCC_CCCC ****_**** ****_**** ****_**** ****_**** ****_**** -- ... g[A] `S` r[C] ...
+1QQ1_SSSS ****_AAAA DDDD_DDDD DDDD_DDDD ****_**** ****_**** ****_**** ****_**** -- ... g[A] `S` D ...
+
+1QQ*_**** ****_**** ****_**** ****_**** ****_**** ****_**** BBBB_BB** ***0_0000 -- ... LinkNoLink
+1QQ*_**** ****_**** ****_**** ****_**** ****_**** ****_**** BBBB_BB** ***0_0001 -- ... LinkTopC
+1QQ*_**** ****_**** ****_**** ****_**** ****_**** ****_**** BBBB_BB** ***0_0010 -- ... LinkNextC
+1QQ*_**** ****_**** ****_**** ****_**** ****_**** ****_**** BBBB_BB** ***0_0011 -- ... LinkPrevC
+1QQ*_**** ****_**** ****_**** ****_**** ****_**** ****_**** BBBB_BB** ***0_0101 -- ... LinkTopPG
+1QQ*_**** ****_**** ****_**** ****_**** ****_**** ****_**** BBBB_BB** ***0_0110 -- ... LinkNextPG
+1QQ*_**** ****_**** ****_**** ****_**** ****_**** ****_**** BBBB_BB** ***0_0111 -- ... LinkPrevPG
+1QQ*_**** ****_**** ****_**** ****_**** ****_**** ****_**** BBBB_BB** ***0_1001 -- ... LinkTopPGC
+1QQ*_**** ****_**** ****_**** ****_**** ****_**** ****_**** BBBB_BB** ***0_1010 -- ... LinkNextPGC
+1QQ*_**** ****_**** ****_**** ****_**** ****_**** ****_**** BBBB_BB** ***0_1011 -- ... LinkPrevPGC
+1QQ*_**** ****_**** ****_**** ****_**** ****_**** ****_**** BBBB_BB** ***0_1100 -- ... LinkGoUpPGC
+1QQ*_**** ****_**** ****_**** ****_**** ****_**** ****_**** BBBB_BB** ***0_1101 -- ... LinkTailPGC
+1QQ*_**** ****_**** ****_**** ****_**** ****_**** ****_**** BBBB_BB** ***1_0000 -- ... RSM
+
+111*_***  -- not allowed ? --
diff -urN -x CVS -x .cvsignore ogle-0.9.2/vmg/Makefile.am ogle/vmg/Makefile.am
--- ogle-0.9.2/vmg/Makefile.am	2003-10-14 18:58:13.000000000 +0200
+++ ogle/vmg/Makefile.am	2004-07-29 11:37:18.000000000 +0200
@@ -19,7 +19,7 @@
 bin_PROGRAMS = ifo_dump
 noinst_PROGRAMS =  vmg_dump dump
 
-AM_CPPFLAGS = @TOP_INCLUDES@ @DVDREAD_CPPFLAGS@ @XML_CFLAGS@
+AM_CPPFLAGS = @TOP_INCLUDES@ @DVDREAD_CPPFLAGS@ @XML_CPPFLAGS@
  
 AM_CFLAGS = @O_CFLAGS@
 
diff -urN -x CVS -x .cvsignore ogle-0.9.2/vmg/com.c ogle/vmg/com.c
--- ogle-0.9.2/vmg/com.c	2003-09-13 19:40:09.000000000 +0200
+++ ogle/vmg/com.c	2006-01-25 17:54:11.000000000 +0100
@@ -21,19 +21,13 @@
 #include <stdlib.h>
 #include <signal.h>
 #include <string.h>
-
 #include <sys/mman.h>
 #include <sys/types.h>
 #include <sys/stat.h>
-#include <sys/shm.h>
 #include <fcntl.h>
 #include <unistd.h>
-#include <sys/msg.h>
 #include <errno.h>
 
-#ifndef SHM_SHARE_MMU
-#define SHM_SHARE_MMU 0
-#endif
 
 #include <ogle/msgevents.h>
 #include "common.h"
@@ -41,14 +35,16 @@
 #include "timemath.h"
 //#include "sync.h"
 #include "debug_print.h"
+#include "shm.h"
 #include "vm.h"
 
 void handle_events(MsgEventQ_t *msgq, MsgEvent_t *ev);
 int wait_q(MsgEventQ_t *msgq, MsgEvent_t *ev);
-int get_q(MsgEventQ_t *msgq, unsigned char *buffer);
+int get_q(MsgEventQ_t *msgq, unsigned char *buffer, int32_t *serial);
 void wait_for_init(MsgEventQ_t *msgq);
 int send_demux(MsgEventQ_t *msgq, MsgEvent_t *ev);
 int send_spu(MsgEventQ_t *msgq, MsgEvent_t *ev);
+int send_videodecoder(MsgEventQ_t *msgq, MsgEvent_t *ev);
 
 static void change_file(char *new_filename);
 static int attach_ctrl_shm(int shmid);
@@ -68,6 +64,7 @@
 
 static MsgEventClient_t demux_client = 0;
 static MsgEventClient_t spu_client = 0;
+static MsgEventClient_t videodecoder_client = 0;
 static char *dvdroot = NULL;
 //MsgEventClient_t ui_client;
 
@@ -82,6 +79,32 @@
   return MsgSendEvent(msgq, spu_client, ev, 0);
 }
 
+int get_videodecoder(MsgEventQ_t *msgq)
+{
+  MsgEvent_t ev;
+  ev.type = MsgEventQReqCapability;
+  ev.reqcapability.capability = DECODE_MPEG2_VIDEO;
+  if(MsgSendEvent(msgq, CLIENT_RESOURCE_MANAGER, &ev, 0) == -1) {
+    FATAL("%s", "couldn't get video cap\n");
+    exit(1);
+  }
+  
+  while(!videodecoder_client) {
+    MsgEvent_t t_ev;
+    if(MsgNextEvent(msgq, &t_ev) != -1) {
+      handle_events(msgq, &t_ev);
+    }
+  }
+}
+
+int send_videodecoder(MsgEventQ_t *msgq, MsgEvent_t *ev) {
+  if(!videodecoder_client) {
+    get_videodecoder(msgq);
+    NOTE("%s", "got video decoder\n");
+  }
+  return MsgSendEvent(msgq, videodecoder_client, ev, 0);
+}
+
 char *get_dvdroot(void) {
   return dvdroot;
 }
@@ -123,6 +146,8 @@
       demux_client = ev->gntcapability.capclient;
     else if((ev->gntcapability.capability & DECODE_DVD_SPU) == DECODE_DVD_SPU)
       spu_client = ev->gntcapability.capclient;
+    else if((ev->gntcapability.capability & DECODE_MPEG2_VIDEO) == DECODE_MPEG2_VIDEO)
+      videodecoder_client = ev->gntcapability.capclient;
     else
       WARNING("capabilities not requested (%d)\n", 
 	      ev->gntcapability.capability);
@@ -287,29 +312,30 @@
 {
   char *shmaddr;
   
-  if(shmid >= 0) {
-    if((shmaddr = shmat(shmid, NULL, SHM_SHARE_MMU)) == (void *)-1) {
+  if(shmid != -1) {
+    if((shmaddr = ogle_shmat(shmid)) == (void *)-1) {
       perror("vmg: attach_ctrl_data(), shmat()");
       return -1;
     }
-    
+
     ctrl_data_shmid = shmid;
     ctrl_data = (ctrl_data_t*)shmaddr;
     ctrl_time = (ctrl_time_t *)(shmaddr+sizeof(ctrl_data_t));
   }    
   
   return 0;
+
 }
 
 static int attach_stream_buffer(uint8_t stream_id, uint8_t subtype, int shmid)
 {
   char *shmaddr;
   q_head_t *q_head;
-
+  
   //DNOTE("shmid: %d\n", shmid);
   
-  if(shmid >= 0) {
-    if((shmaddr = shmat(shmid, NULL, SHM_SHARE_MMU)) == (void *)-1) {
+  if(shmid != -1) {
+    if((shmaddr = ogle_shmat(shmid)) == (void *)-1) {
       perror("vmg: attach_decoder_buffer(), shmat()");
       return -1;
     }
@@ -317,12 +343,12 @@
     stream_shmid = shmid;
     stream_shmaddr = shmaddr;
   }    
-
+  
   q_head = (q_head_t *)stream_shmaddr;
   shmid = q_head->data_buf_shmid;
   
-  if(shmid >= 0) {
-    if((shmaddr = shmat(shmid, NULL, SHM_SHARE_MMU)) == (void *)-1) {
+  if(shmid != -1) {
+    if((shmaddr = ogle_shmat(shmid)) == (void *)-1) {
       perror("vmg: attach_data_buffer(), shmat()");
       return -1;
     }
@@ -330,8 +356,9 @@
     data_buf_shmid = shmid;
     data_buf_shmaddr = (unsigned char *)shmaddr;
   }    
-
+  
   return 0;
+
 }
 
 
@@ -339,7 +366,8 @@
   q_head_t *q_head;
   q_elem_t *q_elems;
   int elem;
-  
+  volatile int *in_use;
+
   if(stream_shmaddr == NULL) {
     while(MsgNextEvent(msgq, ev) == -1);
     return 0;
@@ -349,10 +377,11 @@
   q_elems = (q_elem_t *)(stream_shmaddr+sizeof(q_head_t));
   elem = q_head->read_nr;
   
-  if(!q_elems[elem].in_use) {
+  in_use = &(q_elems[elem].in_use);
+  if(!*in_use) {
     q_head->reader_requests_notification = 1;
     
-    while(!q_elems[elem].in_use) {
+    while(!*in_use) {
       //DPRINTF(1, "vmg: waiting for notification\n");
       if(MsgNextEvent(msgq, ev) != -1) {
 	if(ev->type == MsgEventQNotify) // Is this OK?
@@ -366,7 +395,7 @@
 }
 
 
-int get_q(MsgEventQ_t *msgq, unsigned char *buffer)
+int get_q(MsgEventQ_t *msgq, unsigned char *buffer, int32_t *serial)
 {
   q_head_t *q_head;
   q_elem_t *q_elems;
@@ -389,7 +418,10 @@
   //static int packnr = 0;
   //static clocktime_t time_offset = { 0, 0 };
   MsgEvent_t ev;
-  
+
+
+  volatile int *in_use;
+
   /* Should never hapen if you call wait_q first */
   while(stream_shmaddr == NULL) {
     MsgEvent_t t_ev;
@@ -402,11 +434,12 @@
   q_elems = (q_elem_t *)(stream_shmaddr+sizeof(q_head_t));
   elem = q_head->read_nr;
   
+  in_use = &(q_elems[elem].in_use);
   /* Should never hapen if you call wait_q first */
-  if(!q_elems[elem].in_use) {
+  if(!*in_use) {
     q_head->reader_requests_notification = 1;
     
-    while(!q_elems[elem].in_use) {
+    while(!*in_use) {
       //DPRINTF(1, "vmg: waiting for notification\n");
       if(MsgNextEvent(msgq, &ev) != -1) {
 	handle_events(msgq, &ev);
@@ -431,6 +464,8 @@
   //scr_nr = q_elems[elem].scr_nr;
   
   change_file(data_elem->filename);
+  
+  *serial = data_elem->serial;
 
   off = data_elem->packet_data_offset;
   len = data_elem->packet_data_len;
@@ -480,8 +515,10 @@
   
   
   // release elem
-  data_elem->in_use = 0;
-  q_elems[elem].in_use = 0;
+  in_use = &(data_elem->in_use);
+  *in_use = 0;
+  in_use = &(q_elems[elem].in_use);
+  *in_use = 0;
 
   q_head->read_nr = (q_head->read_nr+1)%q_head->nr_of_qelems;
 
diff -urN -x CVS -x .cvsignore ogle-0.9.2/vmg/nav.c ogle/vmg/nav.c
--- ogle-0.9.2/vmg/nav.c	2003-09-13 19:40:09.000000000 +0200
+++ ogle/vmg/nav.c	2006-11-25 17:05:46.000000000 +0100
@@ -1,5 +1,5 @@
 /* Ogle - A video player
- * Copyright (C) 2000, 2001 Håkan Hjort
+ * Copyright (C) 2000, 2001, 2005 Håkan Hjort, Björn Englund
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -23,6 +23,8 @@
 #include <string.h>
 #include <assert.h>
 #include <time.h>
+#include <sys/poll.h>
+#include <errno.h>
 
 #include <ogle/msgevents.h>
 #include <ogle/dvdevents.h>
@@ -33,14 +35,15 @@
 #include <dvdread/nav_print.h>
 #include "vm.h"
 #include "interpret_config.h"
-
+#include "queue.h"
 
 extern int wait_q(MsgEventQ_t *msgq, MsgEvent_t *ev); // com.c
-extern int get_q(MsgEventQ_t *msgq, unsigned char *buffer);
+extern int get_q(MsgEventQ_t *msgq, unsigned char *buffer, int32_t *serial);
 extern void wait_for_init(MsgEventQ_t *msgq);
 extern void handle_events(MsgEventQ_t *msgq, MsgEvent_t *ev);
 extern int send_demux(MsgEventQ_t *msgq, MsgEvent_t *ev);
 extern int send_spu(MsgEventQ_t *msgq, MsgEvent_t *ev);
+extern int send_videodecoder(MsgEventQ_t *msgq, MsgEvent_t *ev);
 extern char *get_dvdroot(void);
 extern void free_dvdroot(void);
 
@@ -50,10 +53,22 @@
 MsgEvent_t dvdroot_return_ev;
 MsgEventClient_t dvdroot_return_client;
 
-static void do_run(void);
-static int process_user_data(MsgEvent_t ev, pci_t *pci, dsi_t *dsi,
-			     cell_playback_t *cell, 
-			     int block, int *still_time);
+
+typedef struct {
+  int current_block; /* block offset from start of current cell 
+                  start of current cell = lbn for first vobu in cell */
+  int pending_lbn;   /* lbn (for next nav) that is requested from demux */
+  int pending_serial;   /* serial (for next nav) that is requested  */
+  cell_playback_t *cell;
+  int still_time;
+  pci_t pci;
+  dsi_t dsi;
+} nav_state_t;
+
+static void do_run(dvd_state_t *vmstate, nav_state_t *ns);
+static int process_user_data(MsgEvent_t ev, dvd_state_t *vmstate,
+			     nav_state_t *ns);
+static void reset_dvd(dvd_state_t *vmstate, nav_state_t *ns);
 
 static void time_convert(DVDTimecode_t *dest, dvd_time_t *source)
 {
@@ -63,31 +78,65 @@
   dest->Frames  = bcd2int(source->frame_u & 0x3f);
 }
 
+static DVDSubpictureState_t subpicture_state = DVD_SUBPICTURE_STATE_OFF;
 
 MsgEventQ_t *msgq;
 
 char *program_name;
 int dlevel;
 
+static int standalone = 1;
+
+
+static int32_t dvd_serial = 0;
+
+int32_t get_serial(void)
+{
+  return dvd_serial;
+}
+
+int32_t next_serial(void)
+{
+  dvd_serial++;
+  
+  return dvd_serial;
+}
+
 void usage(void)
 {
   fprintf(stderr, "Usage: %s  -m <msgqid>\n", 
           program_name);
 }
 
+
 int main(int argc, char *argv[])
 {
-  int msgqid = -1;
   int c; 
+#ifdef SOCKIPC
+  MsgEventQType_t msgq_type;
+  char *msgqid;
+#else
+  int msgqid = -1;
+#endif
+  dvd_state_t *vmstate;
+  nav_state_t *ns;
   
   program_name = argv[0];
   GET_DLEVEL();
-
+  
   /* Parse command line options */
   while ((c = getopt(argc, argv, "m:h?")) != EOF) {
     switch (c) {
     case 'm':
+#ifdef SOCKIPC
+      if(get_msgqtype(optarg, &msgq_type, &msgqid) == -1) {
+	fprintf(stderr, "unknown msgq type: %s\n", optarg);
+	return 1;
+      }
+#else
       msgqid = atoi(optarg);
+#endif
+      standalone = 0;
       break;
     case 'h':
     case '?':
@@ -96,7 +145,7 @@
     }
   }
   
-  if(msgqid == -1) {
+  if(standalone) {
     fprintf(stderr, "what?\n");
     exit(1);
   }
@@ -106,7 +155,7 @@
   {
     MsgEvent_t ev;
     
-    if((msgq = MsgOpen(msgqid)) == NULL) {
+    if((msgq = MsgOpen(msgq_type, msgqid, strlen(msgqid))) == NULL) {
       FATAL("%s", "couldn't get message q\n");
       exit(1);
     }
@@ -131,7 +180,10 @@
       FATAL("%s", "didn't get spu cap\n");
       exit(1);
     }
-    
+  
+    vmstate = &state;
+    ns = malloc(sizeof(nav_state_t));
+
     vm_reset();
 
     interpret_config();
@@ -197,22 +249,116 @@
   }
   
   //vm_reset(get_dvdroot());
-  do_run();
+  do_run(vmstate, ns);
+  
+  return 0;
+}
+
+
+static int video_state = 1;
+
+static int get_video_state(void)
+{
+  return video_state;
+}
+
+static void set_video_state(int state)
+{
+  video_state = state;
+}
+
+
+/**
+ * returns the spustate (a mask telling the spu which types of subpictures
+ * to show (forced / normal)
+ */
+static uint32_t get_spustate(dvd_state_t *vmstate)
+{
+  uint32_t spu_on = 0;
+  int subpN = vm_get_subp_active_stream();
+  
+  if(subpN != 62) {
+    if(vm_get_subp_display_flag()) {
+      spu_on = 1;
+    }
+  }
+
+  switch(subpicture_state) {
+  case DVD_SUBPICTURE_STATE_OFF:
+  case DVD_SUBPICTURE_STATE_ON:
+    if(spu_on) {
+      spu_on = 0x3;
+    } else {
+      spu_on = 0x1;
+    }
+    break;
+  case DVD_SUBPICTURE_STATE_FORCEDOFF:
+    if(vmstate->domain == VTS_DOMAIN) {
+      spu_on = 0x0;
+    } else {
+      spu_on = 0x1;
+    }
+    break;
+  case DVD_SUBPICTURE_STATE_DISABLED:
+    spu_on = 0x0;
+    break;
+  }
   
+  return spu_on;
+}
+
+/**
+ * Send spustate to the spu (only if it has changed)
+ */
+static int send_spustate(uint32_t spustate)
+{
+  MsgEvent_t ev;
+  static uint32_t prev_spustate = -1;
+
+  if(spustate != prev_spustate) {
+    prev_spustate = spustate;
+    
+    //send spu state to spumixer
+    //fprintf(stderr, "nav: spustate: %02x\n", spustate);
+    ev.type = MsgEventQSPUState;;
+    ev.spustate.state = spustate;
+    
+    if(send_spu(msgq, &ev) == -1) {
+      ERROR("%s", "faild sending highlight info\n");
+      return -1;
+    }
+  }
   return 0;
 }
 
+static int send_demux_flush(void)
+{
+  MsgEvent_t ev;
+
+  ev.type = MsgEventQDemuxDVD;
+  ev.demuxdvd.titlenum = 0;
+  ev.demuxdvd.domain = 0;
+  ev.demuxdvd.block_offset = 0;
+  ev.demuxdvd.block_count = 0;
+  ev.demuxdvd.flowcmd = FlowCtrlFlush;
+  ev.demuxdvd.serial = get_serial();
+  ev.demuxdvd.nav_search = 0;
+
+  if(send_demux(msgq, &ev) == -1) {
+    FATAL("%s", "failed to send demux dvd flush\n");
+    exit(1);
+  }
+}
 
 
 /**
  * Update any info the demuxer needs, and then tell the demuxer
  * what range of sectors to process.
  */
-static void send_demux_sectors(int start_sector, int nr_sectors, 
+static void send_demux_sectors(dvd_state_t *vmstate,
+			       int start_sector, int nr_sectors, 
 			       FlowCtrl_t flush) {
   static int video_aspect = -1;
-  //  static int audio_stream_id = -1;
-  static int subp_stream_id = -1;
   MsgEvent_t ev;
   
   /* Tell video out what aspect ratio this pice has */ 
@@ -240,47 +386,56 @@
   }
   /* Tell the demuxer which audio stream to demux */ 
   {
-    int sN = vm_get_audio_stream(state.AST_REG);
-    if(sN < 0 || sN > 7) sN = 7; // XXX == -1 for _no audio_
-    {
-      static uint8_t old_id = 0xbd;
-      static uint8_t old_subtype = 0x80;
-      uint8_t new_id;
-      uint8_t new_subtype;
+    static uint8_t old_id = 0xbd;
+    static uint8_t old_subtype = 0x80;
+    static int old_audio_enabled = -1;
+    uint8_t new_id;
+    uint8_t new_subtype;
+    int new_audio_enabled;
+    int audioN = vm_get_audio_active_stream();
+    
+    new_id = 0;
+    new_subtype = 0;
+    new_audio_enabled = 0;
+
+    if(audioN != 15) {
       audio_attr_t attr;
-      int audio_stream_id = sN;
-      
-      new_id = 0;
-      new_subtype = 0;
-      
-      attr = vm_get_audio_attr(sN);
-      
-      switch(attr.audio_format) {
-      case 0:
-	//af = DVD_AUDIO_FORMAT_AC3;
-	new_id = 0xbd; //private stream 1
-	new_subtype = 0x80 + audio_stream_id; // AC-3
-	break;
-      case 2:
-	//af = DVD_AUDIO_FORMAT_MPEG1;
-	new_id = 0xC0 + audio_stream_id; //mpeg audio
-      case 3:
-	//af = DVD_AUDIO_FORMAT_MPEG2;
-	new_id = 0xC0 + audio_stream_id; //mpeg audio
-	break;
-      case 4:
-	//af = DVD_AUDIO_FORMAT_LPCM;
-	new_id = 0xbd; //private stream 1
-	new_subtype = 0xA0 + audio_stream_id; // lpcm
-	break;
-      case 6:
-	//af = DVD_AUDIO_FORMAT_DTS;
+      int sN = vm_get_audio_stream_id(audioN);
+
+      if(vm_get_audio_attr(audioN, &attr)) {
+	
+	switch(attr.audio_format) {
+	case 0:
+	  //af = DVD_AUDIO_FORMAT_AC3;
+	  new_id = 0xbd; //private stream 1
+	  new_subtype = 0x80 + sN; // AC-3
+	  break;
+	case 2:
+	  //af = DVD_AUDIO_FORMAT_MPEG1;
+	  new_id = 0xC0 + sN; //mpeg audio
+	case 3:
+	  //af = DVD_AUDIO_FORMAT_MPEG2;
+	  new_id = 0xC0 + sN; //mpeg audio
+	  break;
+	case 4:
+	  //af = DVD_AUDIO_FORMAT_LPCM;
+	  new_id = 0xbd; //private stream 1
+	  new_subtype = 0xA0 + sN; // lpcm
+	  break;
+	case 6:
+	  //af = DVD_AUDIO_FORMAT_DTS;
+	  new_id = 0xbd; //private stream 1
+	  new_subtype = 0x88 + sN; // dts
+	  break;
+	default:
+	  NOTE("%s", "please send a bug report, unknown Audio format!");
+	  break;
+	}
+	
+      } else {
+	ERROR("send_demux: Audio stream out of range: %d\n", audioN);
 	new_id = 0xbd; //private stream 1
-	new_subtype = 0x88 + audio_stream_id; // dts
-	break;
-      default:
-	NOTE("%s", "please send a bug report, unknown Audio format!");
-	break;
+	new_subtype = 0x80 + sN; // AC-3
       }
       
       if(old_id != new_id || old_subtype != new_subtype) {
@@ -298,45 +453,174 @@
       }
       old_id = new_id;
       old_subtype = new_subtype;
+
+      new_audio_enabled = 1;
+    } else {
+      // no audio decoded
+      new_audio_enabled = 0;
     }
+    
+    if(old_audio_enabled != new_audio_enabled) {
+      DNOTE("sending audio demuxstream state %s\n", 
+	    (new_audio_enabled ? "enabled" : "disabled"));
+      DNOTE("id: %02x, st: %02x\n",
+	    old_id, old_subtype);
+      ev.type = MsgEventQDemuxStreamEnable;
+      ev.demuxstreamenable.state = new_audio_enabled;
+      ev.demuxstreamenable.stream_id = old_id;
+      ev.demuxstreamenable.subtype = old_subtype;
+      
+      if(send_demux(msgq, &ev) == -1) {
+	ERROR("%s", "failed to send audio demuxstreamenable\n");
+      }
+    }
+    old_audio_enabled = new_audio_enabled; 
+    
   }
 
   /* Tell the demuxer which subpicture stream to demux */ 
   {
-    int sN = vm_get_subp_active_stream();
-    if(sN < 0 || sN > 31) sN = 31; // XXX == -1 for _no audio_
-    if(sN != subp_stream_id) {
-      subp_stream_id = sN;
-      
-      DNOTE("sending subp demuxstream %d\n", sN);
-    
-      ev.type = MsgEventQDemuxStreamChange;
-      ev.demuxstreamchange.stream_id = 0xbd; // SPU
-      ev.demuxstreamchange.subtype = 0x20 | subp_stream_id;
+    static int old_subp_enabled = -1;
+    static int subp_stream_id = -1;
+    int new_subp_enabled = 0;
+    
+    int subpN = vm_get_subp_active_stream();
+    
+    if(subpN != 62) {
+      int sN = vm_get_subp_stream_id(subpN);
+      
+      if(sN != subp_stream_id) {
+	subp_stream_id = sN;
+	
+	DNOTE("sending subp demuxstream %d\n", sN);
+	
+	ev.type = MsgEventQDemuxStreamChange;
+	ev.demuxstreamchange.stream_id = 0xbd; // SPU
+	ev.demuxstreamchange.subtype = 0x20 | subp_stream_id;
+	if(send_demux(msgq, &ev) == -1) {
+	  ERROR("%s", "failed to send Subpicture demuxstream\n");
+	}
+      }
+    
+      new_subp_enabled = 1;
+    } else {
+      // no subpicture
+      new_subp_enabled = 0;
+    }
+
+    if((subp_stream_id != -1) && (old_subp_enabled != new_subp_enabled)) {
+      DNOTE("sending subp demuxstream state %s\n", 
+	    (new_subp_enabled ? "enabled" : "disabled"));
+      DNOTE("id: %02x, st: %02x\n",
+	    0xbd, 0x20 | subp_stream_id);
+      ev.type = MsgEventQDemuxStreamEnable;
+      ev.demuxstreamenable.state = new_subp_enabled;
+      ev.demuxstreamenable.stream_id = 0xbd;
+      ev.demuxstreamenable.subtype = 0x20 | subp_stream_id;
+      
       if(send_demux(msgq, &ev) == -1) {
-	ERROR("%s", "failed to send Subpicture demuxstream\n");
+	ERROR("%s", "failed to send audio demuxstreamenable\n");
       }
     }
+    old_subp_enabled = new_subp_enabled; 
+
+    send_spustate(get_spustate(vmstate));
+    
   }
 
+  {
+    static int old_video_enabled = 1;
+    int new_video_enabled = 0;
+    new_video_enabled = get_video_state();
+
+    if(old_video_enabled != new_video_enabled) {
+#if 0
+      DNOTE("sending video demuxstream state %s\n", 
+	    (new_video_enabled ? "enabled" : "disabled"));
+      ev.type = MsgEventQDemuxStreamEnable;
+      ev.demuxstreamenable.state = new_video_enabled;
+      ev.demuxstreamenable.stream_id = 0xe0;
+      ev.demuxstreamenable.subtype = 0;
+      
+      if(send_demux(msgq, &ev) == -1) {
+	ERROR("%s", "failed to send video demuxstreamenable\n");
+      }
+      if(!new_video_enabled) {
+	flush = FlowCtrlCompleteVideoUnit;
+      }
+#else
+      ev.type = MsgEventQSetDecodeVideoState;
+      ev.decodevideostate.state = new_video_enabled;
+
+      if(send_videodecoder(msgq, &ev) == -1) {
+	ERROR("%s", "failed to send video state\n");
+      }
+      
+#endif
+    }
+    old_video_enabled = new_video_enabled; 
+  }
+
+  
   /* Tell the demuxer what file and which sectors to demux. */
   ev.type = MsgEventQDemuxDVD;
-  if(state.domain == VMGM_DOMAIN || state.domain == FP_DOMAIN)
+  if(vmstate->domain == VMGM_DOMAIN || vmstate->domain == FP_DOMAIN) {
     ev.demuxdvd.titlenum = 0;
-  else
-    ev.demuxdvd.titlenum = state.vtsN;
-  if(state.domain == VTS_DOMAIN)
+  } else {
+    ev.demuxdvd.titlenum = vmstate->vtsN;
+  }
+  if(vmstate->domain == VTS_DOMAIN) {
     ev.demuxdvd.domain = DVD_READ_TITLE_VOBS;
-  else
+  } else {
     ev.demuxdvd.domain = DVD_READ_MENU_VOBS;
+  }
   ev.demuxdvd.block_offset = start_sector;
   ev.demuxdvd.block_count = nr_sectors;
   ev.demuxdvd.flowcmd = flush;
+  ev.demuxdvd.serial = get_serial();
+  ev.demuxdvd.nav_search = 0;
   if(send_demux(msgq, &ev) == -1) {
     FATAL("%s", "failed to send demux dvd block range\n");
     exit(1);
   }
-  //DNOTE("sent demux dvd block range (%d,%d)\n", start_sector, nr_sectors);
+  DNOTE("sent demux dvd block range (%d,%d)\n", start_sector, nr_sectors);
+}
+
+
+/**
+ * Update any info the demuxer needs, and then tell the demuxer
+ * what range of sectors to process for a nav pack.
+ */
+static uint32_t send_demux_nav(dvd_state_t *vmstate,
+			       int start_sector, int nr_sectors, 
+			       FlowCtrl_t flush) {
+  MsgEvent_t ev;
+  uint32_t serial;
+  /* Tell the demuxer what file and which sectors to demux. */
+  ev.type = MsgEventQDemuxDVD;
+  if(vmstate->domain == VMGM_DOMAIN || vmstate->domain == FP_DOMAIN) {
+    ev.demuxdvd.titlenum = 0;
+  } else {
+    ev.demuxdvd.titlenum = vmstate->vtsN;
+  }
+  if(vmstate->domain == VTS_DOMAIN) {
+    ev.demuxdvd.domain = DVD_READ_TITLE_VOBS;
+  } else {
+    ev.demuxdvd.domain = DVD_READ_MENU_VOBS;
+  }
+  ev.demuxdvd.block_offset = start_sector;
+  ev.demuxdvd.block_count = nr_sectors;
+  ev.demuxdvd.flowcmd = flush;
+  serial = get_serial();
+  ev.demuxdvd.serial = serial;
+  ev.demuxdvd.nav_search = 1;
+  if(send_demux(msgq, &ev) == -1) {
+    FATAL("%s", "failed to send demux dvd nav block range\n");
+    exit(1);
+  }
+  DNOTE("sent demux dvd nav block range (%d,%d)\n", start_sector, nr_sectors);
+  
+  return serial;
 }
 
 static void send_spu_palette(uint32_t palette[16]) {
@@ -361,6 +645,7 @@
   int i;
   
   ev.type = MsgEventQSPUHighlight;
+  ev.spuhighlight.nav_serial = get_serial();
   ev.spuhighlight.x_start = x_start;
   ev.spuhighlight.y_start = y_start;
   ev.spuhighlight.x_end = x_end;
@@ -371,7 +656,7 @@
     ev.spuhighlight.contrast[i] = 0xf & (btn_coli >> (4*i));
 
   if(send_spu(msgq, &ev) == -1) {
-    ERROR("%s", "faild sending highlight info\n");
+    ERROR("%s", "failed sending highlight info\n");
   }
 }
 
@@ -573,7 +858,8 @@
 }
 
 
-int process_seek(int seconds, dsi_t *dsi, cell_playback_t *cell)
+int process_seek(dvd_state_t *vmstate, int seconds, dsi_t *dsi,
+		 cell_playback_t *cell)
 {
   int res = 0;
   dvd_time_t current_time;
@@ -617,7 +903,7 @@
       if(idx < 19) {
 	// Fake this, as a jump with blockN as destination
 	// blockN is relative the start of the cell
-	state.blockN = dsi->dsi_gi.nv_pck_lbn +
+	vmstate->blockN = dsi->dsi_gi.nv_pck_lbn +
 	  (dsi->vobu_sri.fwda[idx] & 0x3fffffff) - cell->first_sector;
 	res = 1;
       } else
@@ -636,7 +922,7 @@
       }
       idx--; // Restore it to the one that got us the diff
       
-      // Make sure we have a VOBU that 'exicsts' (with in the cell)
+      // Make sure we have a VOBU that 'exists' (within the cell)
       // What about the 'top' two bits here?  If there is no video at the
       // seek destination?  Check with the menus in Coruptor.
       while(idx < 19 && !VALID_XWDA(dsi->vobu_sri.bwda[18-idx])) {
@@ -645,7 +931,7 @@
       if(idx < 19) {
 	// Fake this, as a jump with blockN as destination
 	// blockN is relative the start of the cell
-	state.blockN = dsi->dsi_gi.nv_pck_lbn -
+	vmstate->blockN = dsi->dsi_gi.nv_pck_lbn -
 	  (dsi->vobu_sri.bwda[18-idx] & 0x3fffffff) - cell->first_sector;
 	res = 1;
       } else
@@ -654,17 +940,92 @@
   }
   return res;
 }
+ 
+ 
+void set_dvderror(MsgEvent_t *ev, int32_t serial, DVDResult_t err)
+{
+  ev->dvdctrl.cmd.type = DVDCtrlRetVal;
+  ev->dvdctrl.cmd.retval.serial = serial;
+  ev->dvdctrl.cmd.retval.val = err;
+}
+
+
+static int n_still_time;
+static cell_playback_t *n_cell;
+
+static int n_pending_lbn;
+
+static int n_current_block; 
+
+
+//static nav_state_t nav_state;
+
+void set_pending_nav(nav_state_t *ns, uint32_t lbn, uint32_t serial)
+{
+ ns->pending_lbn = lbn;
+ ns->pending_serial = serial;
+}
+
+uint32_t get_pending_lbn(nav_state_t *ns)
+{
+  return ns->pending_lbn;
+}
+
+uint32_t get_pending_serial(nav_state_t *ns)
+{
+  return ns->pending_serial;
+}
+
+void set_current_block(nav_state_t *ns, uint32_t block)
+{
+  ns->current_block = block;
+}
+
+uint32_t get_current_block(nav_state_t *ns)
+{
+  return ns->current_block;
+}
 
+int nav_within_cell(cell_playback_t *cell, uint32_t block)
+{
+  return (cell->first_sector + block <= cell->last_vobu_start_sector);
+}
+
+int navlbn_within_cell(cell_playback_t *cell, uint32_t lbn)
+{
+  return ((cell->first_sector <= lbn) && 
+	  (lbn <= cell->last_vobu_start_sector));
+}
+
+
+uint32_t blk2lbn(cell_playback_t *cell, int32_t block)
+{
+  return cell->first_sector + block;
+}
+
+uint32_t cell_len(cell_playback_t *cell)
+{
+  return cell->last_sector - cell->first_sector + 1;
+}
+
+#define DVD_SERIAL(ev) ((ev)->dvdctrl.cmd.any.serial)
+
+static unsigned int stop_state = 1;
 
 /* Do user input processing. Like audio change, 
  * subpicture change and answer attribute query requests.
  * access menus, pause, play, jump forward/backward...
  */
-int process_user_data(MsgEvent_t ev, pci_t *pci, dsi_t *dsi, 
-		      cell_playback_t *cell, int block, int *still_time)
+int process_user_data(MsgEvent_t ev, dvd_state_t *vmstate, nav_state_t *ns)
 {
   int res = 0;
-      
+  // pci_t *a_pci = &ns->pci;
+  // dsi_t *a_dsi = &ns->dsi; 
+  // cell_playback_t *a_cell = ns->cell;
+  // int a_block = get_current_block(ns);
+  // int *a_still_time = &ns->still_time;
+
+
   //fprintf(stderr, "nav: User input, MsgEvent.type: %d\n", ev.type);
   
   switch(ev.dvdctrl.cmd.type) {
@@ -679,31 +1040,34 @@
   case DVDCtrlMouseActivate:
     
     // A button has already been activated, discard this event??
-    
-    if(cell->first_sector <= pci->pci_gi.nv_pck_lbn
-       && cell->last_vobu_start_sector >= pci->pci_gi.nv_pck_lbn) {
+    if(navlbn_within_cell(ns->cell, ns->pci.pci_gi.nv_pck_lbn)) {
       /* Update selected/activated button, send highlight info to spu */
       /* Returns true if a button is activated */
-      if(process_button(&ev.dvdctrl.cmd, pci, &state.HL_BTNN_REG)) {
-	int button_nr = state.HL_BTNN_REG >> 10;
-	res = vm_eval_cmd(&pci->hli.btnit[button_nr - 1].cmd);
+      if(process_button(&ev.dvdctrl.cmd, &ns->pci, &vmstate->HL_BTNN_REG)) {
+	int button_nr = vmstate->HL_BTNN_REG >> 10;
+	//if a button is activated in a cell still, end still?
+	if(ns->still_time > 0) {
+	  ns->still_time = 0;
+	}
+	res = vm_eval_cmd(&ns->pci.hli.btnit[button_nr - 1].cmd);
       }
     }
     break;
   
   case DVDCtrlTimeSkip:
-    if(dsi->dsi_gi.nv_pck_lbn == -1) { // we are waiting for a new nav block
+    if(ns->dsi.dsi_gi.nv_pck_lbn == -1) { // we are waiting for a new nav block
       res = 0;
       break;
     }
-    res = process_seek(ev.dvdctrl.cmd.timeskip.seconds, dsi, cell);
+    res = process_seek(vmstate, ev.dvdctrl.cmd.timeskip.seconds,
+		       &ns->dsi, ns->cell);
     if(res)
       NOTE("%s", "Doing time seek\n");
     break;  
   
   case DVDCtrlMenuCall:
     NOTE("Jumping to Menu %d\n", ev.dvdctrl.cmd.menucall.menuid);
-    res = vm_menu_call(ev.dvdctrl.cmd.menucall.menuid, block);
+    res = vm_menu_call(ev.dvdctrl.cmd.menucall.menuid, get_current_block(ns));
     if(!res)
       NOTE("%s", "No such menu!\n");
     break;
@@ -727,6 +1091,25 @@
     {
       MsgEvent_t send_ev;
       static double last_speed = 1.0;
+
+      if(stop_state == 2) {
+	res = 1;
+      }
+
+      if(stop_state != 1) {
+	stop_state = 1;
+	
+	DNOTE(" DVDCtrlEvent %d start stop, todo\n",
+	      ev.dvdctrl.cmd.type);
+	
+	send_ev.type = MsgEventQStop;
+	send_ev.stop.state = 1;
+	
+	MsgSendEvent(msgq, CLIENT_RESOURCE_MANAGER, &send_ev, 0);
+      }
+      
+      
+
       send_ev.type = MsgEventQSpeed;
       if(ev.dvdctrl.cmd.type == DVDCtrlForwardScan) {
 	send_ev.speed.speed = ev.dvdctrl.cmd.scan.speed;
@@ -739,9 +1122,9 @@
 	send_ev.speed.speed = last_speed;
 	    
       /* Hack to exit STILL_MODE if we're in it. */
-      if(cell->first_sector + block > cell->last_vobu_start_sector &&
-	 *still_time > 0) {
-	*still_time = 0;
+      if((!nav_within_cell(ns->cell, get_current_block(ns))) && 
+	 ns->still_time > 0) {
+	ns->still_time = 0;
       }
       MsgSendEvent(msgq, CLIENT_RESOURCE_MANAGER, &send_ev, 0);
     }
@@ -781,28 +1164,59 @@
 	  
 	  
   case DVDCtrlStop:
-    DNOTE("unknown (not handled) DVDCtrlEvent %d\n",
-	  ev.dvdctrl.cmd.type);
+    {
+      MsgEvent_t send_ev;
+
+      if(stop_state == 0) {
+	stop_state = 2;
+	reset_dvd(vmstate, ns);
+      } else if(stop_state == 1) {
+	stop_state = 0;
+	DNOTE(" DVDCtrlEvent %d stop, todo\n",
+	      ev.dvdctrl.cmd.type);
+	
+	send_ev.type = MsgEventQStop;
+	send_ev.stop.state = 0;
+	/* Hack to exit STILL_MODE if we're in it. */
+	if((!nav_within_cell(ns->cell, get_current_block(ns))) && 
+	   ns->still_time > 0) {
+	  ns->still_time = 0;
+	}
+	MsgSendEvent(msgq, CLIENT_RESOURCE_MANAGER, &send_ev, 0);
+      }
+    }
     break;
 	  
   case DVDCtrlAngleChange:
     /* FIXME $$$ need to actually change the playback angle too, no? */
-    state.AGL_REG = ev.dvdctrl.cmd.anglechange.anglenr;
+    vmstate->AGL_REG = ev.dvdctrl.cmd.anglechange.anglenr;
     break;
   case DVDCtrlAudioStreamChange: // FIXME $$$ Temorary hack
-    state.AST_REG = ev.dvdctrl.cmd.audiostreamchange.streamnr; // XXX
+    vmstate->AST_REG = ev.dvdctrl.cmd.audiostreamchange.streamnr; // XXX
     break;
   case DVDCtrlSubpictureStreamChange: // FIXME $$$ Temorary hack
-    state.SPST_REG &= 0x40; // Keep the on/off bit.
-    state.SPST_REG |= ev.dvdctrl.cmd.subpicturestreamchange.streamnr;
-    NOTE("DVDCtrlSubpictureStreamChange %x\n", state.SPST_REG);
+    vmstate->SPST_REG &= 0x40; // Keep the on/off bit.
+    vmstate->SPST_REG |= (ev.dvdctrl.cmd.subpicturestreamchange.streamnr & 0x3f);
+    NOTE("DVDCtrlSubpictureStreamChange %x\n", vmstate->SPST_REG);
     break;
   case DVDCtrlSetSubpictureState:
-    if(ev.dvdctrl.cmd.subpicturestate.display == DVDTrue)
-      state.SPST_REG |= 0x40; // Turn it on
-    else
-      state.SPST_REG &= ~0x40; // Turn it off
-    NOTE("DVDCtrlSetSubpictureState 0x%x\n", state.SPST_REG);
+    subpicture_state = ev.dvdctrl.cmd.subpicturestate.display;
+
+    switch(subpicture_state) {
+    case DVD_SUBPICTURE_STATE_ON:
+      vmstate->SPST_REG |= 0x40; // Turn it on
+      break;
+    case DVD_SUBPICTURE_STATE_OFF:
+    case DVD_SUBPICTURE_STATE_FORCEDOFF:
+    case DVD_SUBPICTURE_STATE_DISABLED:
+      vmstate->SPST_REG &= ~0x40; // Turn it off
+      break;
+    }
+    
+    send_spustate(get_spustate(vmstate));
+    break;
+  case DVDCtrlSetVideoState:
+    set_video_state(ev.dvdctrl.cmd.videostate.display);
     break;
   case DVDCtrlGetCurrentDomain:
     {
@@ -827,11 +1241,11 @@
       /* how to get current time for searches in menu/system space? */
       /* a bit of a hack */
       location = &send_ev.dvdctrl.cmd.location.location;
-      location->title = state.TTN_REG;
-      location->ptt = state.PTTN_REG;
+      location->title = vmstate->TTN_REG;
+      location->ptt = vmstate->PTTN_REG;
       vm_get_total_time(&total_time);
       time_convert(&location->title_total, &total_time);
-      vm_get_current_time(&current_time, &(pci->pci_gi.e_eltm));
+      vm_get_current_time(&current_time, &(ns->pci.pci_gi.e_eltm));
       time_convert(&location->title_current, &current_time);
       MsgSendEvent(msgq, ev.any.client, &send_ev, 0);
     }
@@ -894,7 +1308,7 @@
       send_ev.dvdctrl.cmd.type = DVDCtrlAudioStreamEnabled;
       send_ev.dvdctrl.cmd.audiostreamenabled.streamnr = streamN;
       send_ev.dvdctrl.cmd.audiostreamenabled.enabled =
-	(vm_get_audio_stream(streamN) != -1) ? DVDTrue : DVDFalse;
+	(vm_audio_stream_enabled(streamN)) ? DVDTrue : DVDFalse;
       MsgSendEvent(msgq, ev.any.client, &send_ev, 0);	    
     }
     break;
@@ -946,39 +1360,72 @@
       send_ev.dvdctrl.cmd.type = DVDCtrlAudioAttributes;
       send_ev.dvdctrl.cmd.audioattributes.streamnr = streamN;
       {
+	DVDAudioAttributes_t *a_attr =
+	  &send_ev.dvdctrl.cmd.audioattributes.attr;
 	DVDAudioFormat_t af = DVD_AUDIO_FORMAT_Other;
-	audio_attr_t attr = vm_get_audio_attr(streamN);
-	memset(&send_ev.dvdctrl.cmd.audioattributes.attr, 0, 
-	       sizeof(DVDAudioAttributes_t)); //TBD
-	switch(attr.audio_format) {
-	case 0:
-	  af = DVD_AUDIO_FORMAT_AC3;
-	  break;
-	case 2:
-	  af = DVD_AUDIO_FORMAT_MPEG1;
-	  break;
-	case 3:
-	  af = DVD_AUDIO_FORMAT_MPEG2;
-	  break;
-	case 4:
-	  af = DVD_AUDIO_FORMAT_LPCM;
-	  break;
-	case 6:
-	  af = DVD_AUDIO_FORMAT_DTS;
-	  break;
-	default:
-	  NOTE("please send a bug report, unknown Audio format %d!", 
-	       attr.audio_format);
-	  break;
+	audio_attr_t attr;
+
+	if(vm_get_audio_attr(streamN, &attr)) {
+	  
+	  memset(a_attr, 0, sizeof(DVDAudioAttributes_t));
+	  switch(attr.audio_format) {
+	  case 0:
+	    af = DVD_AUDIO_FORMAT_AC3;
+	    break;
+	  case 2:
+	    if(attr.quantization == 1) {
+	      af = DVD_AUDIO_FORMAT_MPEG1_DRC;
+	    } else {
+	      af = DVD_AUDIO_FORMAT_MPEG1;
+	    }
+	    break;
+	  case 3:
+	    if(attr.quantization == 1) {
+	      af = DVD_AUDIO_FORMAT_MPEG2_DRC;
+	    } else {
+	      af = DVD_AUDIO_FORMAT_MPEG2;
+	    }
+	    break;
+	  case 4:
+	    af = DVD_AUDIO_FORMAT_LPCM;
+	    switch(attr.quantization) {
+	    case 0:
+	      a_attr->SampleQuantization = 16;
+	      break;
+	    case 1:
+	      a_attr->SampleQuantization = 20;
+	      break;
+	    case 2:
+	      a_attr->SampleQuantization = 24;
+	      break;
+	    }
+	    break;
+	  case 6:
+	    af = DVD_AUDIO_FORMAT_DTS;
+	    break;
+	  default:
+	    WARNING("please send a bug report, unknown Audio format %d!", 
+		    attr.audio_format);
+	    break;
+	  }
+	  a_attr->AudioFormat = af;
+	  a_attr->AppMode = attr.application_mode;
+	  a_attr->LanguageExtension = attr.code_extension;
+	  a_attr->Language = attr.lang_code;
+	  a_attr->HasMultichannelInfo = attr.multichannel_extension;
+	  switch(attr.sample_frequency) {
+	  case 0:
+	    a_attr->SampleFrequency = 48000;
+	    break;
+	  case 1:
+	    a_attr->SampleFrequency = 96000;
+	    break;
+	  }
+	  a_attr->NumberOfChannels = attr.channels + 1;
+	  a_attr->AudioType = attr.lang_type;
+	} else {
+	  set_dvderror(&send_ev, DVD_SERIAL(&ev), DVD_E_Invalid);
 	}
-	send_ev.dvdctrl.cmd.audioattributes.attr.AudioFormat 
-	  = af;
-	send_ev.dvdctrl.cmd.audioattributes.attr.AppMode 
-	  = attr.application_mode;
-	send_ev.dvdctrl.cmd.audioattributes.attr.LanguageExtension
-	  = attr.lang_extension;
-	send_ev.dvdctrl.cmd.audioattributes.attr.Language 
-	  = attr.lang_code;
       }
       MsgSendEvent(msgq, ev.any.client, &send_ev, 0);	    
     }
@@ -992,8 +1439,16 @@
       send_ev.dvdctrl.cmd.type = DVDCtrlCurrentSubpicture;
       send_ev.dvdctrl.cmd.currentsubpicture.nrofstreams = nS;
       send_ev.dvdctrl.cmd.currentsubpicture.currentstream = cS & ~0x40;
-      send_ev.dvdctrl.cmd.currentsubpicture.display 
-	= (cS & 0x40) ? DVDTrue : DVDFalse;
+      switch(subpicture_state) {
+      case DVD_SUBPICTURE_STATE_FORCEDOFF:
+      case DVD_SUBPICTURE_STATE_DISABLED:
+	send_ev.dvdctrl.cmd.currentsubpicture.display = subpicture_state;
+	break;
+      default:
+	send_ev.dvdctrl.cmd.currentsubpicture.display 
+	  = (cS & 0x40) ? DVD_SUBPICTURE_STATE_ON : DVD_SUBPICTURE_STATE_OFF;
+	break;
+      }
       MsgSendEvent(msgq, ev.any.client, &send_ev, 0);
     }
     break;
@@ -1005,23 +1460,31 @@
       send_ev.dvdctrl.cmd.type = DVDCtrlSubpictureStreamEnabled;
       send_ev.dvdctrl.cmd.subpicturestreamenabled.streamnr = streamN;
       send_ev.dvdctrl.cmd.subpicturestreamenabled.enabled =
-	(vm_get_subp_stream(streamN) != -1) ? DVDTrue : DVDFalse;
+	(vm_subp_stream_enabled(streamN)) ? DVDTrue : DVDFalse;
       MsgSendEvent(msgq, ev.any.client, &send_ev, 0);	    
     }
     break;
   case DVDCtrlGetSubpictureAttributes: // FIXME XXX $$$ Not done
     {
       MsgEvent_t send_ev;
+      DVDSubpictureAttributes_t *s_attr;
       int streamN = ev.dvdctrl.cmd.subpictureattributes.streamnr;
       send_ev.type = MsgEventQDVDCtrl;
       send_ev.dvdctrl.cmd.type = DVDCtrlSubpictureAttributes;
       send_ev.dvdctrl.cmd.subpictureattributes.streamnr = streamN;
+      s_attr = &send_ev.dvdctrl.cmd.subpictureattributes.attr;
+
       {
-	subp_attr_t attr = vm_get_subp_attr(streamN);
-	memset(&send_ev.dvdctrl.cmd.subpictureattributes.attr, 0, 
-	       sizeof(DVDSubpictureAttributes_t)); //TBD
-	send_ev.dvdctrl.cmd.subpictureattributes.attr.Language 
-	  = attr.lang_code;
+	subp_attr_t attr;
+	if(vm_get_subp_attr(streamN, &attr)) {
+	  memset(s_attr, 0, sizeof(DVDSubpictureAttributes_t));
+	  s_attr->Type  = attr.type;
+	  s_attr->CodingMode  = attr.code_mode;
+	  s_attr->Language  = attr.lang_code;
+	  s_attr->LanguageExtension  = attr.code_extension;
+	} else {
+	  set_dvderror(&send_ev, DVD_SERIAL(&ev), DVD_E_Invalid);
+	}
       }
       MsgSendEvent(msgq, ev.any.client, &send_ev, 0);
     }	  
@@ -1043,7 +1506,7 @@
       MsgEvent_t send_ev;
       char *state_str;
       DVDCtrlLongStateEvent_t *state_ev;
-      state_str = vm_get_state_str(block);
+      state_str = vm_get_state_str(get_current_block(ns));
       
       send_ev.type = MsgEventQDVDCtrlLong;
       send_ev.dvdctrllong.cmd.type = DVDCtrlLongState;
@@ -1117,11 +1580,11 @@
   return res;
 }
 
-int process_long_user_data(MsgEvent_t ev, pci_t *pci, cell_playback_t *cell,
-			   int block, int *still_time)
+int process_long_user_data(MsgEvent_t ev, 
+			   dvd_state_t *vmstate, nav_state_t *ns)
 {
   int res = 0;
-      
+
   //fprintf(stderr, "nav: User input, MsgEvent.type: %d\n", ev.type);
   
   switch(ev.dvdctrllong.cmd.type) {
@@ -1138,60 +1601,254 @@
 
 
 
-static int block;
-static int still_time;
-static cell_playback_t *cell;
-
-static int pending_lbn;
 
 #define INF_STILL_TIME (10 * 0xff)
 
-static void do_init_cell(int flush) {
-  
-  cell = &state.pgc->cell_playback[state.cellN - 1];
-  still_time = 10 * cell->still_time;
-
-  block = state.blockN;
-  assert(cell->first_sector + block <= cell->last_vobu_start_sector);
+static void do_init_cell(dvd_state_t *vmstate, nav_state_t *ns, int flush) {
+  uint32_t lbn, blk;
+  uint32_t search_len;
+  uint32_t serial;
+  
+  next_serial();
+  ns->cell = &(vmstate->pgc->cell_playback[vmstate->cellN - 1]);
+  ns->still_time = 10 * ns->cell->still_time;
+  
+  set_current_block(ns, vmstate->blockN);
+  blk = get_current_block(ns);
+  //  block = state.blockN;
+  assert(nav_within_cell(ns->cell, blk));
+  //assert(cell->first_sector + block <= cell->last_vobu_start_sector);
 
   // FIXME XXX $$$ Only send when needed, and do send even if not playing
   // from start? (should we do pre_commands when jumping to say part 3?)
   /* Send the palette to the spu. */
-  send_spu_palette(state.pgc->palette);
-  
+  send_spu_palette(vmstate->pgc->palette);
+
+  lbn = blk2lbn(ns->cell, blk);
+  search_len = cell_len(ns->cell) - blk;
+
   /* Get the pci/dsi data */
-  if(flush)
-    send_demux_sectors(cell->first_sector + block, 1, FlowCtrlFlush);
-  else
-    send_demux_sectors(cell->first_sector + block, 1, FlowCtrlNone);
+  if(flush) {
+    serial = send_demux_nav(vmstate, lbn, search_len, FlowCtrlFlush);
+  } else {
+    serial = send_demux_nav(vmstate, lbn, search_len, FlowCtrlNone);
+  }
+#ifdef NAV_SEARCH_DEBUG
+  WARNING("send_demux_nav (cellinit) (%x, %x), serial %x\n", 
+	  lbn, search_len,  serial);  
+#endif
+  set_pending_nav(ns, lbn, serial);
+}
+
+static void reset_dvd(dvd_state_t *vmstate, nav_state_t *ns)
+{
+  fprintf(stderr, "\n*********** reset dvd ***************************\n");
+  next_serial();
+  send_demux_flush();
+  fprintf(stderr, "\n*********** vm reset ***************************\n");
+  vm_reset();
+
+  interpret_config();
+  
+  vm_start(); // see hack in main
+  do_init_cell(vmstate, ns, 0);
   
-  pending_lbn = cell->first_sector + block;
 }
 
+#if 0
 
-static void do_run(void) {
-  pci_t pci;
-  dsi_t dsi;
+#else
+
+/*
+ * wait for events (nav_pack || userop || timer)
+ */
+
+
+
+static int wait_for_msg(MsgEventQ_t *msgq, int timeout)
+{
+  int ret;
+  struct pollfd fds[1];
+  unsigned int nfds;
+  fds[0].fd = msgq->socket.sd;
+  fds[0].events = POLLIN;
+  nfds = 1;
+  
+  // only check for messages
+  ret = poll(fds, nfds, timeout);
+  if(ret == -1) {
+    ERROR("poll(): %s\n", strerror(errno));
+    ret = -1;
+  } else if(ret == 0) {
+    //timeout
+    ret = 0;
+  } else {
+    if((fds[0].revents & POLLIN) == POLLIN) {
+      ret = 1;
+    } else {
+      ERROR("poll(): revents: %0x\n", fds[0].revents);
+      ret = -1;
+    }
+  } 
+
+  return ret;
+}
+
+#if 0
+static int wait_msgq(MsgEventQ_t *msgq, int wait_for_nav, int timeout)
+{
+  q_head_t *q_head;
+  q_elem_t *q_elems;
+  int elem;
+  volatile int *in_use;
+  int ret;
+  int rval;
+
+  if(msgq->type != MsgEventQType_socket) {
+    FATAL("%s", "socket needed, NI\n");
+  }
+  
+  if(!wait_for_nav) {
+    return wait_for_msg(msgq, timeout);
+  }
+  
+  q_head = (q_head_t *)stream_shmaddr;
+  q_elems = (q_elem_t *)(stream_shmaddr+sizeof(q_head_t));
+  elem = q_head->read_nr;
+  
+  in_use = &(q_elems[elem].in_use);
+  if(!*in_use) {
+    q_head->reader_requests_notification = 1;
+    
+    if(!*in_use) {
+      return wait_for_msg(msgq, timeout);
+    }
+  }
+  
+  // nav pack available, check if there is a message also
+  rval = 2;
+  ret = wait_for_msg(msgq, 0);
+  if(ret == 1) { 
+    rval = 3;
+  }
+  
   
+  return rval;
+}
+
+#endif
+#if 0
+int wait_for_events(MsgEventQ_t *msgq)
+{
+  int timer_timeout = next_timer();
+  int still_time_timeout = still_time_left();
+  int timeout = -1;
+  int wait_for_nav;
+  int r;
+  
+  timer_timeout = next_timer();
+  still_time_timeout = still_time_left();
+  timeout = -1;
+
+  if(still_time_timeout) {
+    timeout = still_time_left;
+    wait_for_nav = 0;
+  } else {
+    //process navpacks only when not in still
+    wait_for_nav = 1;    
+  }
+  if(timer_timeout < still_time_timeout) {
+    timeout = timer_timeout;
+  }
+  
+  r = wait_msgq(msgq, wait_for_nav, timeout);
+
+  
+  /*  process_timeout(timeout)
+      if(cur_time > timer_end) {
+       inc_counter_regs();
+       dec_navtimer();
+       timer_end = timer_end+1.0s;
+       timer_start = cur_time;
+      }
+      if(still_time_start != 0) {
+       if(cur_time > still_time_end) {
+        still_time_start = 0;
+	next_cell(vm);
+	init_cell(vm);
+       }
+      }
+  */
+  if(userdata) {
+    process_userdata();
+  }
+  if(navblovk) {
+    nb = get_navblock();
+    
+    if(flush_in_progress()) {
+      if(nav.serial == serial && nav.lbn == lbn) {
+	//flush completed
+	flush_done();	
+      } else {
+	// drop packet
+	continue;
+      }
+    }
+    process_nav(nb) {
+      if dsi ...;
+      if pci ...;
+    }
+  }
+}
+
+#endif
+
+uint32_t next_vobu_offs(nav_state_t *ns) 
+{
+  return ns->dsi.vobu_sri.next_vobu & 0x3fffffff;
+}
+
+uint32_t nav_lbn(nav_state_t *ns)
+{
+  return ns->dsi.dsi_gi.nv_pck_lbn;
+}
+
+static void do_run(dvd_state_t *vmstate, nav_state_t *ns) {
+  int32_t packet_serial;
+
   vm_start(); // see hack in main
-  do_init_cell(0);
-  pci.pci_gi.nv_pck_lbn = -1;
-  dsi.dsi_gi.nv_pck_lbn = -1;
+  do_init_cell(vmstate, ns, 0);
+  ns->pci.pci_gi.nv_pck_lbn = -1;
+  ns->dsi.dsi_gi.nv_pck_lbn = -1;
   
   while(1) {
     MsgEvent_t ev;
     int got_data;
-    
+    uint32_t blk;
+    static int last_pending = -1;
+    static int last_serial = -1;
+
     // For now.. later use the time instead..
     /* Have we read the last dsi packet we asked for? Then request the next. */
-    if(pending_lbn == dsi.dsi_gi.nv_pck_lbn
-       && cell->first_sector + block <= cell->last_vobu_start_sector) {
-      int complete_video;
+    blk = get_current_block(ns);
+    if(last_serial != packet_serial) {
+      last_serial = packet_serial;
+      last_pending = -1;
+    }
+    if((nav_lbn(ns) != -1) && (nav_lbn(ns) != last_pending)
+       && (get_pending_serial(ns) == packet_serial)
+       && nav_within_cell(ns->cell, blk)) {
       
+      int complete_video;
+      last_pending = nav_lbn(ns);
+#ifdef NAV_SEARCH_DEBUG
+      WARNING("got pending block(ser) %x(%x), serial (%x)\n",
+	      get_pending_lbn(ns), get_pending_serial(ns), packet_serial); 
+#endif
       /* If there is video data in this vobu, but not in the next. Then this 
 	 data must be a complete image, so let the decoder know this. */
-      if((dsi.vobu_sri.next_vobu & 0x80000000) == 0 
-	 && dsi.dsi_gi.vobu_1stref_ea != 0 /* there is video in this */) {
+      if((ns->dsi.vobu_sri.next_vobu & 0x80000000) == 0 
+	 && ns->dsi.dsi_gi.vobu_1stref_ea != 0 /* there is video in this */) {
 	complete_video = FlowCtrlCompleteVideoUnit;
 	//DNOTE("FlowCtrlCompleteVideoUnit = 1;\n");
       } else {
@@ -1199,9 +1856,9 @@
       }
       
       /* Demux/play the content of this vobu. */
-      if(dsi.dsi_gi.vobu_ea != 0) {
-	send_demux_sectors(cell->first_sector + block + 1, 
-			   dsi.dsi_gi.vobu_ea, complete_video);
+      if(ns->dsi.dsi_gi.vobu_ea != 0) {
+	send_demux_sectors(vmstate, blk2lbn(ns->cell, blk) + 1, 
+			   ns->dsi.dsi_gi.vobu_ea, complete_video);
       }
       
       /* VOBU still ? */
@@ -1219,24 +1876,47 @@
 	*/
 	;
       } else {
+	uint32_t next_nav;
+	uint32_t blk = get_current_block(ns);
 	/* .. top two bits are flags */  
-	block += dsi.vobu_sri.next_vobu & 0x3fffffff;
+	//block += dsi.vobu_sri.next_vobu & 0x3fffffff;
+#ifdef NAV_SEARCH_DEBUG
+	WARNING("block %x, next_vobu %x (%x)\n",
+		blk, next_vobu_offs(ns),
+		blk + next_vobu_offs(ns));
+#endif
+	next_nav = nav_lbn(ns) + next_vobu_offs(ns) - ns->cell->first_sector;
+	set_current_block(ns, next_nav);
+	
+#ifdef NAV_SEARCH_DEBUG
+	WARNING("nv_lbn %x, first %x next %x, (%x)\n",
+		nav_lbn(ns),
+		ns->cell->first_sector, next_nav,
+		ns->cell->first_sector + next_nav);
+#endif
       }
-      
-      
+
+      blk = get_current_block(ns);
       /* TODO XXX $$$ Test earlier and merge the requests if posible? */
       /* If there is more data in this cell to demux, then get the
        * next nav pack. */
-      if(cell->first_sector + block <= cell->last_vobu_start_sector) {
-	send_demux_sectors(cell->first_sector + block, 1, FlowCtrlNone);
-	pending_lbn = cell->first_sector + block;
+      if(nav_within_cell(ns->cell, blk)) {
+	uint32_t lbn, search_len, serial;
+	lbn = blk2lbn(ns->cell, blk);
+	search_len = cell_len(ns->cell)-blk;
+#ifdef NAV_SEARCH_DEBUG
+	WARNING("send_demux_nav (%x, len %x), serial %x\n",
+		lbn, search_len, get_serial());
+#endif
+	serial = send_demux_nav(vmstate, lbn, search_len, FlowCtrlNone);
+	set_pending_nav(ns, lbn, serial);
       } else {
 	//DNOTE("end of cell\n");
 	; // end of cell!
-	if(still_time == INF_STILL_TIME) // Inf. still time
+	if(ns->still_time == INF_STILL_TIME) // Inf. still time
 	  NOTE("%s", "Still picture select an item to continue.\n");
-	else if(still_time != 0)
-	  NOTE("Pause for %d seconds,\n", still_time/10);
+	else if(ns->still_time != 0)
+	  NOTE("Pause for %d seconds,\n", ns->still_time/10);
 #if 0 
 	/* TODO XXX $$$ This should only be done at the correct time */
 	/* Handle forced activate button here */
@@ -1252,39 +1932,46 @@
 	  state.HL_BTNN_REG = button_nr << 10;
 	  
 	  if(vm_eval_cmd(&pci.hli.btnit[button_nr - 1].cmd)) {
-	    do_init_cell(/* ?? */ 0);
+	    do_init_cell(vmstate, ns, /* ?? */ 0);
 	    dsi.dsi_gi.nv_pck_lbn = -1;
 	  }
 	}
 #endif
       }
+    } else {
+#ifdef NAV_SEARCH_DEBUG
+      WARNING("nav: pending %x(%x), got %x(%x)\n",
+	      get_pending_lbn(ns), get_pending_serial(ns),
+	      nav_lbn(ns), packet_serial);      
+#endif
     }
     
     
     // Wait for data/input or for cell still time to end
     {
-      if(cell->first_sector + block <= cell->last_vobu_start_sector) {
+      if(nav_within_cell(ns->cell, get_current_block(ns))) {
 	got_data = wait_q(msgq, &ev); // Wait for a data packet or a message
-      
       } else { 
 	/* Handle cell still time here */
 	got_data = 0;
-	if(still_time == INF_STILL_TIME) // Inf. still time
+	if(ns->still_time == INF_STILL_TIME) { // Inf. still time
 	  MsgNextEvent(msgq, &ev);
-	else
-	  while(still_time && MsgCheckEvent(msgq, &ev)) {
+	} else {
+	  while(ns->still_time && MsgCheckEvent(msgq, &ev)) {
 	    struct timespec req = {0, 100000000}; // 0.1s 
 	    nanosleep(&req, NULL);
-	    still_time--;
+	    ns->still_time--;
 	  }
+	}
 	
-	if(!still_time) // No more still time (or there never was any..)
+	if(!ns->still_time) { // No more still time (or there never was any..)
 	  if(MsgCheckEvent(msgq, &ev)) { // and no more messages
 	    // Let the vm run and give us a new cell to play
 	    vm_get_next_cell();
-	    do_init_cell(/* No jump */ 0);
-	    dsi.dsi_gi.nv_pck_lbn = -1;
+	    do_init_cell(vmstate, ns,  /* No jump */ 0);
+	    ns->dsi.dsi_gi.nv_pck_lbn = -1;
 	  }
+	}
       }
     }
     /* If we are here we either have a message or an available data packet */ 
@@ -1301,13 +1988,12 @@
 	 * access menus, pause, play, jump forward/backward...
 	 */
 
-	res = process_user_data(ev, &pci, &dsi, cell, block, &still_time);
+	res = process_user_data(ev, vmstate, ns);
 	break;
       case MsgEventQDVDCtrlLong:
-
-	res = process_long_user_data(ev, &pci, cell, block, &still_time);
+	res = process_long_user_data(ev, vmstate, ns);
 	break;
-	
+
       default:
 	handle_events(msgq, &ev);
 	/* If( new dvdroot ) {
@@ -1318,24 +2004,31 @@
 	*/
       }      
       if(res != 0) {/* a jump has occured */
-	do_init_cell(/* Flush streams */1);
-	dsi.dsi_gi.nv_pck_lbn = -1;
+	do_init_cell(vmstate, ns,/* Flush streams */1);
+	ns->dsi.dsi_gi.nv_pck_lbn = -1;
       }
       
     } else { // We got a data to read.
       unsigned char buffer[2048];
       int len;
       
-      len = get_q(msgq, &buffer[0]);
-      
+      len = get_q(msgq, &buffer[0], &packet_serial);
+#ifdef NAV_SEARCH_DEBUG
+      WARNING("nav: pending_serial %x ,packet_serial: %x",
+	      get_pending_serial(ns), packet_serial);
+#endif
       if(buffer[0] == PS2_PCI_SUBSTREAM_ID) {
-	navRead_PCI(&pci, &buffer[1]);
+	navRead_PCI(&ns->pci, &buffer[1]);
 	/* Is this the packet we are waiting for? */
-	if(pci.pci_gi.nv_pck_lbn != pending_lbn) {
-	  //fprintf(stdout, "nav: Droped PCI packet\n");
-	  pci.pci_gi.nv_pck_lbn = -1;
+	//	if(pci.pci_gi.nv_pck_lbn != pending_lbn) {
+	if(get_pending_serial(ns) != packet_serial) {
+	  WARNING("nav: Dropped PCI packet, pending %x(%x), got %x(%x)\n",
+		  get_pending_lbn(ns), get_pending_serial(ns),
+		  ns->pci.pci_gi.nv_pck_lbn, packet_serial);
+	  ns->pci.pci_gi.nv_pck_lbn = -1;
 	  continue;
 	}
+	//navPrint_PCI(&ns->pci);
 	//fprintf(stdout, "nav: Got PCI packet\n");
 	/*
 	if(pci.hli.hl_gi.hli_ss & 0x03) {
@@ -1344,17 +2037,21 @@
 	}
 	*/
 	/* Evaluate and Instantiate the new pci packet */
-	process_pci(&pci, &state.HL_BTNN_REG);
+	process_pci(&ns->pci, &vmstate->HL_BTNN_REG);
         
       } else if(buffer[0] == PS2_DSI_SUBSTREAM_ID) {
-	navRead_DSI(&dsi, &buffer[1]);
-	if(dsi.dsi_gi.nv_pck_lbn != pending_lbn) {
+	navRead_DSI(&ns->dsi, &buffer[1]);
+	//	if(dsi.dsi_gi.nv_pck_lbn != pending_lbn) {
+	if(get_pending_serial(ns) != packet_serial) {
+	  WARNING("nav: Dropped DSI packet, pending %x(%x), got %x(%x)\n",
+		  get_pending_lbn(ns), get_pending_serial(ns),
+		  ns->dsi.dsi_gi.nv_pck_lbn, packet_serial);
 	  //fprintf(stdout, "nav: Droped DSI packet\n");
-	  dsi.dsi_gi.nv_pck_lbn = -1;
+	  ns->dsi.dsi_gi.nv_pck_lbn = -1;
 	  continue;
 	}
 	//fprintf(stdout, "nav: Got DSI packet\n");
-	//navPrint_DSI(&dsi);
+	//navPrint_DSI(&ns->dsi);
 
       } else {
 	int i;
@@ -1367,3 +2064,4 @@
   }
 }
 
+#endif
diff -urN -x CVS -x .cvsignore ogle-0.9.2/vmg/nav.h ogle/vmg/nav.h
--- ogle-0.9.2/vmg/nav.h	1970-01-01 01:00:00.000000000 +0100
+++ ogle/vmg/nav.h	2001-06-21 18:57:00.000000000 +0200
@@ -0,0 +1,255 @@
+#ifndef NAV_H_INCLUDED
+#define NAV_H_INCLUDED
+
+/* 
+ * Copyright (C) 2000, 2001 Håkan Hjort <d95hjort@dtek.chalmers.se>
+ *
+ * The data structures in this file should represent the layout of the 
+ * pci and dsi packets as they are stored in the stream. 
+ * Information found by reading the source to VOBDUMP is the base for 
+ * the structure and names of these data types.
+ *
+ * VOBDUMP: a program for examining DVD .VOB filse
+ *
+ * Copyright 1998, 1999 Eric Smith <eric@brouhaha.com>
+ *
+ * VOBDUMP is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.  Note that I am not
+ * granting permission to redistribute or modify VOBDUMP under the
+ * terms of any later version of the General Public License.
+ *
+ * This program is distributed in the hope that it will be useful (or
+ * at least amusing), but WITHOUT ANY WARRANTY; without even the
+ * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+ * PURPOSE.  See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <inttypes.h>
+#include "ifo.h" // vm_cmd_t
+
+
+#define PCI_BYTES 0x3d4
+#define DSI_BYTES 0x3fa
+
+#define PS2_PCI_SUBSTREAM_ID 0x00
+#define PS2_DSI_SUBSTREAM_ID 0x01
+
+
+typedef struct { /* PCI General Information */
+  uint32_t nv_pck_lbn;
+  uint16_t vobu_cat;
+  uint16_t zero1;
+  uint32_t vobu_uop_ctl;
+  uint32_t vobu_s_ptm;
+  uint32_t vobu_e_ptm;
+  uint32_t vobu_se_e_ptm;
+  uint32_t e_eltm;
+  char vobu_isrc[32];
+} __attribute__ ((packed)) pci_gi_t;
+
+
+typedef struct { /* Angle Information for _non_ seamless playback */
+  uint32_t nsml_agl_dsta[9];
+} __attribute__ ((packed)) nsml_agli_t;
+
+
+typedef struct {
+  uint16_t hli_ss; // only low 2 bits
+  uint32_t hli_s_ptm;
+  uint32_t hli_e_ptm;
+  uint32_t btn_se_e_ptm;
+#ifdef WORDS_BIGENDIAN
+  unsigned int zero1 : 2;
+  unsigned int btngr_ns : 2;
+  unsigned int zero2 : 1;
+  unsigned int btngr1_dsp_ty : 3;
+  unsigned int zero3 : 1;
+  unsigned int btngr2_dsp_ty : 3;
+  unsigned int zero4 : 1;
+  unsigned int btngr3_dsp_ty : 3;
+#else
+  unsigned int btngr1_dsp_ty : 3;
+  unsigned int zero2 : 1;
+  unsigned int btngr_ns : 2;
+  unsigned int zero1 : 2;
+  unsigned int btngr3_dsp_ty : 3;
+  unsigned int zero4 : 1;
+  unsigned int btngr2_dsp_ty : 3;
+  unsigned int zero3 : 1;
+#endif
+  uint8_t btn_ofn;
+  uint8_t btn_ns;     // only low 6 bits
+  uint8_t nsl_btn_ns; // only low 6 bits
+  uint8_t zero5;
+  uint8_t fosl_btnn;  // only low 6 bits
+  uint8_t foac_btnn;  // only low 6 bits
+} __attribute__ ((packed)) hl_gi_t;
+
+typedef struct {
+  uint32_t btn_coli[3][2];
+} __attribute__ ((packed)) btn_colit_t;
+
+typedef struct {
+#ifdef WORDS_BIGENDIAN
+  unsigned int btn_coln : 2;
+  unsigned int x_start : 10;
+  unsigned int zero1 : 2;
+  unsigned int x_end : 10;
+  unsigned int auto_action_mode : 2;
+  unsigned int y_start : 10;
+  unsigned int zero2 : 2;
+  unsigned int y_end : 10;
+
+  unsigned int zero3 : 2;
+  unsigned int up : 6;
+  unsigned int zero4 : 2;
+  unsigned int down : 6;
+  unsigned int zero5 : 2;
+  unsigned int left : 6;
+  unsigned int zero6 : 2;
+  unsigned int right : 6;
+#else
+  unsigned int x_end : 10;
+  unsigned int zero1 : 2;
+  unsigned int x_start : 10;
+  unsigned int btn_coln : 2;
+  unsigned int y_end : 10;
+  unsigned int zero2 : 2;
+  unsigned int y_start : 10;
+  unsigned int auto_action_mode : 2;
+
+  unsigned int up : 6;
+  unsigned int zero3 : 2;
+  unsigned int down : 6;
+  unsigned int zero4 : 2;
+  unsigned int left : 6;
+  unsigned int zero5 : 2;
+  unsigned int right : 6;
+  unsigned int zero6 : 2;
+#endif
+  vm_cmd_t cmd;
+} __attribute__ ((packed)) btni_t;
+
+typedef struct {
+  hl_gi_t     hl_gi;
+  btn_colit_t btn_colit;
+  btni_t      btnit[36];
+} __attribute__ ((packed)) hli_t;
+
+typedef struct {
+  pci_gi_t    pci_gi;
+  nsml_agli_t nsml_agli;
+  hli_t       hli;
+  uint8_t     zero1[189];
+} __attribute__ ((packed)) pci_t;
+
+
+
+
+
+
+typedef struct { /* DSI General Information */
+  uint32_t nv_pck_scr;
+  uint32_t nv_pck_lbn;
+  uint32_t vobu_ea;
+  uint32_t vobu_1stref_ea;
+  uint32_t vobu_2ndref_ea;
+  uint32_t vobu_3rdref_ea;
+  uint16_t vobu_vob_idn;
+  uint8_t  zero1;
+  uint8_t  vobu_c_idn;
+  uint32_t c_eltm;
+} __attribute__ ((packed)) dsi_gi_t;
+
+typedef struct { /* Seamless Playback Information */ 
+  uint16_t category; // category of seamless VOBU
+  /* Xyyy yyyy PREU flag        1b: VOBU is in preunit 
+   *                            0b: VOBU is not in preunit
+   * yXyy yyyy ILVU flag        1b: VOBU is in ILVU
+   *                            0b: VOBU is not in ILVU described
+   * yyXy yyyy Unit Start flag  1b: VOBU at the beginning of ILVU described
+   *                            0b: VOBU not at the beginning
+   * yyyX yyyy Unit End flag    1b: VOBU at end of PREU of ILVU described
+   *                            0b: not at the end
+   */
+  uint32_t ilvu_ea;  // end address of interleaved Unit (sectors)
+  uint32_t ilvu_sa;  // start address of next interleaved unit (sectors)
+  uint16_t size;     // size of next interleaved unit (sectors)
+  uint32_t unknown_s_ptm; // ?? first pts in cell/ pts of first object 
+  uint32_t unknown_e_ptm; // ?? last pts in cell/ pts of last object
+ 
+  uint8_t unknown[128];
+} __attribute__ ((packed)) sml_pbi_t;
+
+typedef struct { /* Angle Information for seamless playback */
+  // Address and size of destination ILVU in AGL_X
+  struct {
+    uint32_t address; // Sector offset to next ILVU, high bit is before/after
+    uint16_t size;    // Byte size of the ILVU pointed to by address.
+  } __attribute__ ((packed)) dsta[9];
+} __attribute__ ((packed)) sml_agli_t;
+
+typedef struct { /* VOBUnit Search Information */
+  /*
+    bit 0: V_FWD_Exist1  0b: *Video data* does not exist in the address
+                         1b: *video data* exists in the VOBU on the address
+    bit 1: V_FWD_Exist2  indicates whether theres *video data* between 
+			 current vobu and last vobu.
+    if address = 3fff ffff -> vobu does not exist
+  */
+  
+  /* 1     FWDI Video     VOBU start address with video data
+     n = 0.5 seconds after presentationtime of current VOBU
+     2 n=240
+     3 120
+     4 60
+     5 20
+     6 15
+     7 14
+     ..
+     20 1
+     21 Next VOBU start addres
+     22 previous VOBU start address
+     23 - end backwards
+     23   n = 1
+     24 n = 2
+     ..
+     37 n = 15
+     38  20
+     39 60
+     40 120
+     41 240
+     42 .....
+  */
+  uint32_t next_video;   // Next (nv_pck_lbn+this value -> next vobu lbn)
+  uint32_t FWDA[19]; // Forwards, time
+  uint32_t next;
+  uint32_t prev;
+  uint32_t BWDA[19]; // Backwars, time
+  uint32_t prev_video; // Previous (nv_pck_lbn-this value -> prev. vobu lbn)
+} __attribute__ ((packed)) vobu_sri_t;
+
+typedef struct { /* Synchronous Information */ 
+  uint16_t unknown_offset;      //  Highbit == signbit
+  uint16_t unknown1[7];
+  uint32_t start_of_cell_offset1; //?? 7f ff ff ff == at start
+  uint32_t start_of_cell_offset2; //??  
+  uint8_t unknown2[120];
+} __attribute__ ((packed)) synci_t;
+
+typedef struct {
+  dsi_gi_t   dsi_gi;
+  sml_pbi_t  sml_pbi;
+  sml_agli_t sml_agli;
+  vobu_sri_t vobu_sri;
+  synci_t    synci;
+  uint8_t    zero1[471];
+} __attribute__ ((packed)) dsi_t;
+
+
+#endif /* NAV_H_INCLUDED */
diff -urN -x CVS -x .cvsignore ogle-0.9.2/vmg/vm.c ogle/vmg/vm.c
--- ogle-0.9.2/vmg/vm.c	2003-08-06 19:29:30.000000000 +0200
+++ ogle/vmg/vm.c	2006-12-12 21:13:53.000000000 +0100
@@ -22,6 +22,7 @@
 #include <unistd.h>
 #include <inttypes.h>
 #include <assert.h>
+#include <errno.h>
 
 #include "ogle/dvd.h"
 #include "ogle/dvdevents.h"
@@ -181,7 +182,8 @@
 {
   dvd = DVDOpen(dvdroot);
   if(!dvd) {
-    ERROR("%s", "faild to open/read the DVD\n");
+    ERROR("failed to open/read the DVD at %s: (%d) %s\n",
+    	  dvdroot, errno, strerror(errno));
     return -1;
   }
 
@@ -191,7 +193,8 @@
   
   vmgi = ifoOpenVMGI(dvd);
   if(!vmgi) {
-    ERROR("%s", "faild to read VIDEO_TS.IFO\n");
+    ERROR("failed to read VIDEO_TS.IFO: (%d) %s\n",
+	  errno, strerror(errno));
     return -1;
   }
   if(!ifoRead_FP_PGC(vmgi)) {
@@ -488,11 +491,24 @@
 }
 
 
+int vm_audio_stream_enabled(int audioN)
+{
+  
+  if(audioN >= 0 && audioN < 8) {
+    if(state.pgc->audio_control[audioN] & (1<<15)) {
+      return 1;
+    }
+  }
+  
+  return 0;
+}
+
 /**
- * Return the substream id for 'logical' audio stream audioN.
+ * Return the stream id for 'logical' audio stream audioN.
  *  0 <= audioN < 8
+ * returns -1 if the stream is not enabled
  */
-int vm_get_audio_stream(int audioN)
+int vm_get_audio_stream_id(int audioN)
 {
   int streamN = -1;
   
@@ -503,27 +519,59 @@
   }
   
   if(audioN < 8) {
-    /* Is there any contol info for this logical stream */ 
-    if(state.pgc->audio_control[audioN] & (1<<15)) {
+    /* Is there any control info for this logical stream */ 
+    if(vm_audio_stream_enabled(audioN)) {
       streamN = (state.pgc->audio_control[audioN] >> 8) & 0x07;  
     }
   }
   
-  if(state.domain == VTSM_DOMAIN 
-     || state.domain == VMGM_DOMAIN
-     || state.domain == FP_DOMAIN) {
-    if(streamN == -1)
-      streamN = 0;
+  return streamN;
+}
+
+
+/**
+ * Return the current active audio stream. 0-7 or 15 (0xf) if none
+ *
+ */
+int vm_get_audio_active_stream(void)
+{
+  int audioN = state.AST_REG;
+
+  if(!vm_audio_stream_enabled(audioN)) {
+    int n;
+    audioN = 0xf; // none
+    
+    for(n = 0; n < 8; n++) {
+      if(vm_audio_stream_enabled(n)) {
+	audioN = n;
+	break;
+      }
+    }
   }
   
-  return streamN;
+  return audioN;
+}
+
+
+int vm_subp_stream_enabled(int subpN)
+{
+
+  if(subpN >= 0 && subpN < 32) { /* a valid logical stream */
+    /* Is this logical stream present */ 
+    if(state.pgc->subp_control[subpN] >> 31) {
+      return 1;
+    }
+  }
+
+  return 0;
 }
 
+
 /**
- * Return the substream id for 'logical' subpicture stream subpN.
+ * Return the stream id for 'logical' subpicture stream subpN.
  * 0 <= subpN < 32
  */
-int vm_get_subp_stream(int subpN)
+int vm_get_subp_stream_id(int subpN)
 {
   int streamN = -1;
   int source_aspect = get_video_aspect();
@@ -534,47 +582,39 @@
     subpN = 0;
   }
   
-  if(subpN < 32) { /* a valid logical stream */
-    /* Is this logical stream present */ 
-    if(state.pgc->subp_control[subpN] >> 31) {
-      if(source_aspect == 0) /* 4:3 */	     
-	streamN = (state.pgc->subp_control[subpN] >> 24) & 0x1f;  
-      if(source_aspect == 3) /* 16:9 */
-	streamN = (state.pgc->subp_control[subpN] >> 16) & 0x1f;
+  if(vm_subp_stream_enabled(subpN)) {
+    if(source_aspect == 0) { /* 4:3 */
+      streamN = (state.pgc->subp_control[subpN] >> 24) & 0x1f;  
+    } else if(source_aspect == 3) { /* 16:9 */
+      streamN = (state.pgc->subp_control[subpN] >> 16) & 0x1f;
     }
   }
   
-  /* Paranoia.. if no stream select 0 anyway */
-  if(state.domain == VTSM_DOMAIN 
-     || state.domain == VMGM_DOMAIN
-     || state.domain == FP_DOMAIN) {
-    if(streamN == -1)
-      streamN = 0;
-  }
-
   return streamN;
 }
 
 int vm_get_subp_active_stream(void)
 {
-  int subpN = state.SPST_REG & ~0x40;
-  int streamN = vm_get_subp_stream(subpN);
+  int subpN = state.SPST_REG & 0x3f;
   
-  /* If no such stream, then select the first one that exists. */
-  if(streamN == -1)
-    for(subpN = 0; subpN < 32; subpN++)
-      if(state.pgc->subp_control[subpN] >> 31) {
-	streamN = vm_get_subp_stream(subpN);
+  if(!vm_subp_stream_enabled(subpN)) {
+    int n;
+    subpN = 62; //none
+    
+    for(n = 0; n < 32; n++) {
+      if(vm_subp_stream_enabled(n)) {
+	subpN = n;
 	break;
       }
-  
-  /* We should instead send the on/off status to the spudecoder / mixer */
-  /* If we are in the title domain see if the spu mixing is on */
-  if(state.domain == VTS_DOMAIN && !(state.SPST_REG & 0x40)) { 
-    return -1;
-  } else {
-    return streamN;
+    }
   }
+  
+  return subpN;
+}
+
+int vm_get_subp_display_flag(void)
+{
+  return state.SPST_REG & 0x40;
 }
 
 void vm_get_angle_info(int *num_avail, int *current)
@@ -605,11 +645,11 @@
     *num_avail = vtsi->vtsi_mat->nr_of_vts_audio_streams;
     *current = state.AST_REG;
   } else if(state.domain == VTSM_DOMAIN) {
-    *num_avail = vtsi->vtsi_mat->nr_of_vtsm_audio_streams; // 1
-    *current = 1;
+    *num_avail = vtsi->vtsi_mat->nr_of_vtsm_audio_streams; // 0 or 1
+    *current = 0;
   } else if(state.domain == VMGM_DOMAIN || state.domain == FP_DOMAIN) {
-    *num_avail = vmgi->vmgi_mat->nr_of_vmgm_audio_streams; // 1
-    *current = 1;
+    *num_avail = vmgi->vmgi_mat->nr_of_vmgm_audio_streams; // 0 or 1
+    *current = 0;
   }
 }
 
@@ -619,11 +659,11 @@
     *num_avail = vtsi->vtsi_mat->nr_of_vts_subp_streams;
     *current = state.SPST_REG;
   } else if(state.domain == VTSM_DOMAIN) {
-    *num_avail = vtsi->vtsi_mat->nr_of_vtsm_subp_streams; // 1
-    *current = 0x41;
+    *num_avail = vtsi->vtsi_mat->nr_of_vtsm_subp_streams; // 0 or 1
+    *current = 0x40;
   } else if(state.domain == VMGM_DOMAIN || state.domain == FP_DOMAIN) {
-    *num_avail = vmgi->vmgi_mat->nr_of_vmgm_subp_streams; // 1
-    *current = 0x41;
+    *num_avail = vmgi->vmgi_mat->nr_of_vmgm_subp_streams; // 0 or 1
+    *current = 0x40;
   }
 }
 
@@ -662,18 +702,29 @@
  return ptts;
 }
 
-subp_attr_t vm_get_subp_attr(int streamN)
+int vm_get_subp_attr(int streamN, subp_attr_t *attr)
 {
-  subp_attr_t attr;
   
   if(state.domain == VTS_DOMAIN) {
-    attr = vtsi->vtsi_mat->vts_subp_attr[streamN];
+    if((streamN >= 0) && (streamN < vtsi->vtsi_mat->nr_of_vts_subp_streams)) {
+      *attr = vtsi->vtsi_mat->vts_subp_attr[streamN];
+    } else {
+      return 0;
+    }
   } else if(state.domain == VTSM_DOMAIN) {
-    attr = vtsi->vtsi_mat->vtsm_subp_attr;
+    if(vtsi->vtsi_mat->nr_of_vtsm_subp_streams > 0) {
+      *attr = vtsi->vtsi_mat->vtsm_subp_attr;
+    } else {
+      return 0;
+    }
   } else if(state.domain == VMGM_DOMAIN || state.domain == FP_DOMAIN) {
-    attr = vmgi->vmgi_mat->vmgm_subp_attr;
+    if(vmgi->vmgi_mat->nr_of_vmgm_subp_streams > 0) {
+      *attr = vmgi->vmgi_mat->vmgm_subp_attr;
+    } else {
+      return 0;
+    }
   }
-  return attr;
+  return 1;
 }
 
 user_ops_t vm_get_uops(void)
@@ -681,18 +732,32 @@
   return state.pgc->prohibited_ops;
 }
 
-audio_attr_t vm_get_audio_attr(int streamN)
+/**
+ * Returns the audio attributes for 'logical' audio stream audioN
+ */
+int vm_get_audio_attr(int audioN, audio_attr_t *attr)
 {
-  audio_attr_t attr;
-
+  
   if(state.domain == VTS_DOMAIN) {
-    attr = vtsi->vtsi_mat->vts_audio_attr[streamN];
+    if((audioN >= 0) && (audioN < vtsi->vtsi_mat->nr_of_vts_audio_streams)) {
+      *attr = vtsi->vtsi_mat->vts_audio_attr[audioN];
+    } else {
+      return 0;
+    }
   } else if(state.domain == VTSM_DOMAIN) {
-    attr = vtsi->vtsi_mat->vtsm_audio_attr;
+    if(vtsi->vtsi_mat->nr_of_vtsm_audio_streams > 0) {
+      *attr = vtsi->vtsi_mat->vtsm_audio_attr;
+    } else {
+      return 0;
+    }
   } else if(state.domain == VMGM_DOMAIN || state.domain == FP_DOMAIN) {
-    attr = vmgi->vmgi_mat->vmgm_audio_attr;
+    if(vmgi->vmgi_mat->nr_of_vmgm_audio_streams > 0) {
+      *attr = vmgi->vmgi_mat->vmgm_audio_attr;
+    } else {
+      return 0;
+    }
   }
-  return attr;
+  return 1;
 }
 
 video_attr_t vm_get_video_attr(void)
@@ -1274,7 +1339,7 @@
   if(seconds < 0)
     seconds = 0;
   
-  fprintf(stderr, "Time Play/Skipp to offset %dseconds\n", seconds);
+  DNOTE("Time Play/Skip to offset %d seconds\n", seconds);
   
   pgcN = get_PGCN();
   // Is there an entry for this pgc?
@@ -1306,8 +1371,13 @@
        * Can one have time seek for multiangle pgc's?
        */
       { 
+	int cellN;
 	cell_playback_t *cells = state.pgc->cell_playback;
-	state.cellN = get_cellN_for_vobu(vobu_addr); //scan the cell table?
+	cellN = get_cellN_for_vobu(vobu_addr); //scan the cell table?
+	if(!cellN) {
+	  return 0;
+	}
+	state.cellN = cellN;
 	assert(vobu_addr >= cells[state.cellN - 1].first_sector);
 	assert(vobu_addr <= cells[state.cellN - 1].last_vobu_start_sector);
 	state.blockN = vobu_addr - cells[state.cellN - 1].first_sector;
@@ -1713,23 +1783,24 @@
   unsigned int i, j, entries;
   c_adt_t *c_adt = vtsi->vts_c_adt;
     //nr_of_vobs = c_adt->nr_of_vobs;
-  entries = (c_adt->last_byte + 1 - C_ADT_SIZE)/sizeof(c_adt_t);
+  entries = (c_adt->last_byte + 1 - C_ADT_SIZE)/sizeof(cell_adr_t);
+  
   
-  fprintf(stderr, "VOBU addr: 0x%x\n", vobu_addr);
+  DNOTE("VOBU addr: 0x%x\n", vobu_addr);
   for(i = 0; i < entries; i++) {
     if(c_adt->cell_adr_table[i].start_sector <= vobu_addr && 
        vobu_addr <= c_adt->cell_adr_table[i].last_sector) {
       uint16_t vob_id = c_adt->cell_adr_table[i].vob_id;
       uint8_t cell_id = c_adt->cell_adr_table[i].cell_id;
-      fprintf(stderr, "start_sector: 0x%x\n",
+      DNOTE("start_sector: 0x%x\n",
 	      c_adt->cell_adr_table[i].start_sector);
-      fprintf(stderr, "last_sector: 0x%x\n",
+      DNOTE("last_sector: 0x%x\n",
 	      c_adt->cell_adr_table[i].last_sector);
-      fprintf(stderr, "VOBID: %d CELLID: %d\n", vob_id, cell_id);
+      DNOTE("VOBID: %d CELLID: %d\n", vob_id, cell_id);
       for(j = 0; j < state.pgc->nr_of_cells; j++) {
 	if(state.pgc->cell_position[j].vob_id_nr == vob_id &&
 	   state.pgc->cell_position[j].cell_nr == cell_id) {
-	  fprintf(stderr, "VOBID: %d CELLID: %d, CellN: %d\n",
+	  DNOTE("VOBID: %d CELLID: %d, CellN: %d\n",
 		  vob_id, cell_id, j + 1);
 	  return j + 1; // cellN is 1 based
 	}
@@ -1741,9 +1812,10 @@
   }
   // Something crazy has happened!!
   // Unable to find the VOB / CELL id for the VOBU!
-  assert(0 & 14);
-
-  return 1;
+  //assert(0 & 14);
+  WARNING("Couldn't find Cell id for VOBU addr: 0x%x \n",
+	  vobu_addr);
+  return 0;
 }
 
 static int get_video_aspect(void)
diff -urN -x CVS -x .cvsignore ogle-0.9.2/vmg/vm.h ogle/vmg/vm.h
--- ogle-0.9.2/vmg/vm.h	2003-06-25 18:12:43.000000000 +0200
+++ ogle/vmg/vm.h	2006-01-25 17:54:11.000000000 +0100
@@ -55,7 +55,7 @@
   int pgcN; // either this or *pgc is enough. Which to use?
   int pgN;  // is this needed? can allways fid pgN from cellN?
   int cellN; // current cell
-  int blockN; // block offset to the VOPBU within the current cell
+  int blockN; // block offset to the VOBU within the current cell
   
   player_mode_t mode;
   
@@ -103,9 +103,13 @@
 int vm_jump_title_ptt(int titleN, int pttN);
 int vm_jump_title(int titleN);
 int vm_time_play(dvd_time_t *time, unsigned int offset);
-int vm_get_audio_stream(int audioN);
-int vm_get_subp_stream(int subpN);
+int vm_get_audio_stream_id(int audioN);
+int vm_get_audio_active_stream(void);
+int vm_audio_stream_enabled(int audioN);
+int vm_subp_stream_enabled(int subpN);
+int vm_get_subp_stream_id(int subpN);
 int vm_get_subp_active_stream(void);
+int vm_get_subp_display_flag(void);
 void vm_get_angle_info(int *num_avail, int *current);
 void vm_get_audio_info(int *num_avail, int *current);
 void vm_get_subp_info(int *num_avail, int *current);
@@ -114,9 +118,9 @@
 			int *side, int *nroftitles);
 int vm_get_titles(void);
 int vm_get_ptts_for_title(DVDTitle_t titleN);
-subp_attr_t vm_get_subp_attr(int streamN);
+int vm_get_subp_attr(int streamN, subp_attr_t *attr);
 user_ops_t vm_get_uops(void);
-audio_attr_t vm_get_audio_attr(int streamN);
+int vm_get_audio_attr(int audioN, audio_attr_t *attr);
 video_attr_t vm_get_video_attr(void);
 void vm_get_video_res(int *width, int *height);
 void vm_get_total_time(dvd_time_t *current_time);
diff -urN -x CVS -x .cvsignore ogle-0.9.2/vmg/vmg.c ogle/vmg/vmg.c
--- ogle-0.9.2/vmg/vmg.c	1970-01-01 01:00:00.000000000 +0100
+++ ogle/vmg/vmg.c	2001-06-21 18:57:00.000000000 +0200
@@ -0,0 +1,111 @@
+/* Ogle - A video player
+ * Copyright (C) 2000, 2001 Björn Englund, Håkan Hjort
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, 
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <inttypes.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#include "common.h"
+#include "queue.h"
+
+extern void handle_events(MsgEventQ_t *q, MsgEvent_t *ev);
+extern int get_q(char *buffer);
+
+extern int file_open(char *infile);
+extern int attach_ctrl_shm(int shmid);
+extern int attach_stream_buffer(uint8_t stream_id, uint8_t subtype, int shmid);
+
+static int msgqid = -1;
+static MsgEventQ_t *msgq;
+
+char *program_name;
+
+char buffer[2048];
+
+void usage()
+{
+  fprintf(stderr, "Usage: %s  [-m <msgid>]\n", 
+	  program_name);
+}
+
+int main(int argc, char *argv[])
+{
+  int c;
+  FILE *outfile;
+  program_name = argv[0];
+  
+  /* Parse command line options */
+  while ((c = getopt(argc, argv, "m:h?")) != EOF) {
+    switch (c) {
+    case 'm':
+      msgqid = atoi(optarg);
+      break;
+    case 'h':
+    case '?':
+      usage();
+      return 1;
+    }
+  }
+
+  if(msgqid == -1) {
+    if(argc - optind != 1){
+      usage();
+      return 1;
+    }
+  }
+  
+  // test
+  outfile = fopen("/tmp/vmg", "w");
+  
+
+  if(msgqid != -1) {
+    MsgEvent_t ev;
+    
+    if((msgq = MsgOpen(msgqid)) == NULL) {
+      fprintf(stderr, "ac3wrap: couldn't get message q\n");
+      exit(-1);
+    }
+    
+    ev.type = MsgEventQRegister;
+    ev.registercaps.capabilities = DECODE_DVD_NAV;
+    if(MsgSendEvent(msgq, CLIENT_RESOURCE_MANAGER, &ev, 0) == -1) {
+      fprintf(stderr, "ac3wrap: register capabilities\n");
+    }
+    
+    while(ev.type != MsgEventQDecodeStreamBuf) {
+      MsgNextEvent(msgq, &ev);
+      handle_events(msgq, &ev);
+    }
+  
+  } else {
+    fprintf(stderr, "what?\n");
+  }
+  
+  
+  while(1) {
+    int len;
+    len = get_q(buffer);
+    fwrite(&buffer, len, 1, outfile);
+  }
+
+  return 0;
+}
+
+
+
